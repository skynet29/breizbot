function getPeaksAtThreshold(e,o,t){console.log("getPeaksAtThreshold",o);const n=[],s=e.length;for(let l=0;l<s;)e[l]>o&&(n.push(l),l+=t/4-1),l++;return n}function countIntervalsBetweenNearbyPeaks(e){console.log("countIntervalsBetweenNearbyPeaks",e);const o=[];return e.forEach((t,n)=>{const s=Math.min(e.length-n,10);for(let l=1;l<s;l++){const s=e[n+l]-t;o.some(e=>e.interval===s&&(e.count++,console.log("interval",e),!0))||o.push({interval:s,count:1})}}),o}function trunc(e){return Math.trunc(10*e)/10}function groupNeighborsByTempo(e,o){console.log("groupNeighborsByTempo",e);const t=[];return e.forEach((e,n)=>{console.log(n,e);let s=60/(e.interval/o);for(console.log("theoreticalTempo",s);s<90;)s*=2;for(;s>160;)s/=2;s=trunc(s),console.log("theoreticalTempo",s),t.some(o=>{if(o.tempo===s)return o.count+=e.count})||t.push({tempo:s,count:e.count})}),t}function getMaximumValue(e){let o=0;const t=e.length;for(let n=0;n<t;n+=1)e[n]>o&&(o=e[n]);return o}self.onmessage=function(e){console.log("Message received:",e.data);const{channelData:o,sampleRate:t}=e.data,n=computeTempo(o,t);console.log("tempos",n),self.postMessage(n[0])};const MINUMUM_NUMBER_OF_PEAKS=30;function computeTempo(e,o){const t=getMaximumValue(e);console.log("maximumValue",t);const n=.3*t;let s=[],l=t-.05*t;if(console.log("threshold",l),t>.25)for(;s.length<MINUMUM_NUMBER_OF_PEAKS&&l>=n;)s=getPeaksAtThreshold(e,l,o),console.log("peaks length",s.length),l-=.05*t;const c=groupNeighborsByTempo(countIntervalsBetweenNearbyPeaks(s),o);return c.sort((e,o)=>o.count-e.count),c}