$$.control.registerControl("rootPage",{template:'<div>\n    <canvas width="512" height="512" bn-bind="canvas"></canvas>\n    <div class="info">\n        <button bn-event="click: onStart" bn-show="!running">Start</button>\n        <button bn-event="click: onStop" bn-show="running">Stop</button>\n\n        <div>\n            <label>Generation</label>\n            <span bn-text="step"></span>\n        </div>\n    </div>\n</div>\n',deps:["breizbot.pager"],props:{},init:async function(e,n){let t=0;const r=16,l=8;let i=null;const a=$$.viewController(e,{data:{step:t,running:!1},events:{onStart:function(){i=setInterval(w,200),a.setData({running:!0})},onStop:function(){clearInterval(i),a.setData({running:!1})}}}),c=a.scope.canvas.get(0);if(!navigator.gpu)throw new Error("WebGPU not supported on this browser.");const o=await navigator.gpu.requestAdapter();if(!o)throw new Error("No appropriate GPUAdapter found.");const u=await o.requestDevice(),s=new Float32Array([r,r]),f=u.createBuffer({label:"Grid Uniforms",size:s.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});u.queue.writeBuffer(f,0,s);const g=new Uint32Array(r*r),d=[u.createBuffer({label:"Cell State A",size:g.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),u.createBuffer({label:"Cell State B",size:g.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})];for(let e=0;e<g.length;++e)g[e]=Math.random()>.6?1:0;u.queue.writeBuffer(d[0],0,g);const p=c.getContext("webgpu"),b=navigator.gpu.getPreferredCanvasFormat();p.configure({device:u,format:b});const v=new Float32Array([-.8,-.8,.8,-.8,.8,.8,-.8,-.8,.8,.8,-.8,.8]),y=u.createBuffer({label:"Cell vertices",size:v.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});u.queue.writeBuffer(y,0,v);const h=u.createShaderModule({label:"Game of Life simulation shader",code:"@group(0) @binding(0) var<uniform> grid: vec2f;\n\n@group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n\n\nfn cellIndex(cell: vec2u) -> u32 {\n  return cell.y * u32(grid.x) + cell.x;\n}\n\nfn cellActive(x: u32, y: u32) -> u32 {\n  return cellStateIn[cellIndex(vec2(x, y))];\n}\n\n@compute\n@workgroup_size(8, 8)\nfn computeMain(@builtin(global_invocation_id) cell: vec3u) {\n  // New lines. Flip the cell state every step.\n//   if (cellStateIn[cellIndex(cell.xy)] == 1) {\n//     cellStateOut[cellIndex(cell.xy)] = 0;\n//   } else {\n//     cellStateOut[cellIndex(cell.xy)] = 1;\n//   }\n\n    // Determine how many active neighbors this cell has.\n    let activeNeighbors = cellActive(cell.x+1, cell.y+1) +\n                        cellActive(cell.x+1, cell.y) +\n                        cellActive(cell.x+1, cell.y-1) +\n                        cellActive(cell.x, cell.y-1) +\n                        cellActive(cell.x-1, cell.y-1) +\n                        cellActive(cell.x-1, cell.y) +\n                        cellActive(cell.x-1, cell.y+1) +\n                        cellActive(cell.x, cell.y+1);\n\n      let i = cellIndex(cell.xy);\n\n      // Conway's game of life rules:\n      switch activeNeighbors {\n        case 2: {\n          cellStateOut[i] = cellStateIn[i];\n        }\n        case 3: {\n          cellStateOut[i] = 1;\n        }\n        default: {\n          cellStateOut[i] = 0;\n        }\n      }\n    \n}"}),x=u.createShaderModule({label:"Cell shader",code:"@group(0) @binding(0) var<uniform> grid: vec2f;\n@group(0) @binding(1) var<storage> cellState: array<u32>; \n\nstruct VertexInput {\n  @location(0) pos: vec2f,\n  @builtin(instance_index) instance: u32,\n};\n\nstruct VertexOutput {\n  @builtin(position) pos: vec4f,\n  @location(0) cell: vec2f,\n};\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    //return vec4f(pos.x, pos.y, 0, 1);\n    //return vec4f(pos / grid, 0, 1);\n\n    // let cell = vec2f(1, 1); // Cell(1,1) in the image above\n    // let cellOffset = cell / grid * 2; // Compute the offset to cell\n    // let gridPos = (input.pos + 1) / grid - 1 + cellOffset; // Add it here!\n\n  let i = f32(input.instance);\n  let state = f32(cellState[input.instance]);\n\n  let cell = vec2f(i % grid.x, floor(i / grid.x));\n  let cellOffset = cell / grid * 2;\n  //let gridPos = (input.pos + 1) / grid - 1 + cellOffset;  \n  let gridPos = (input.pos*state+1) / grid - 1 + cellOffset;\n\n    //return vec4f(gridPos, 0, 1);\n    var output: VertexOutput;\n    output.pos = vec4f(gridPos, 0, 1);\n    output.cell = cell;\n    return output;\n}\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    //return vec4f(1, 0, 0, 1); // (Red, Green, Blue, Alpha)\n  \n    let c = input.cell / grid;\n    return vec4f(c, 1-c.x, 1);\n}"}),S=u.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),P=u.createPipelineLayout({bindGroupLayouts:[S]}),m=u.createRenderPipeline({label:"Cell pipeline",layout:P,vertex:{module:x,entryPoint:"vertexMain",buffers:[{arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]}]},fragment:{module:x,entryPoint:"fragmentMain",targets:[{format:b}]}}),U=u.createComputePipeline({label:"Simulation pipeline",layout:P,compute:{module:h,entryPoint:"computeMain"}}),G=[u.createBindGroup({label:"Cell renderer bind group A",layout:S,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:d[0]}},{binding:2,resource:{buffer:d[1]}}]}),u.createBindGroup({label:"Cell renderer bind group B",layout:S,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:d[1]}},{binding:2,resource:{buffer:d[0]}}]})];function w(){const e=u.createCommandEncoder(),n=e.beginComputePass();n.setPipeline(U),n.setBindGroup(0,G[t%2]);const i=Math.ceil(r/l);n.dispatchWorkgroups(i,i),n.end(),t++,a.setData({step:t});const c=e.beginRenderPass({colorAttachments:[{view:p.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:.4,a:1}}]});c.setPipeline(m),c.setBindGroup(0,G[t%2]),c.setVertexBuffer(0,y),c.draw(v.length/2,r*r),c.end(),u.queue.submit([e.finish()])}w()}});