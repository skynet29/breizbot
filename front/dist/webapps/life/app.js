$$.control.registerControl("rootPage",{template:'<div>\n    <canvas width="512" height="512" bn-bind="canvas"></canvas>\n</div>',deps:["breizbot.pager"],props:{},init:function(e,t){const r=$$.viewController(e,{data:{},events:{}}).scope.canvas.get(0);!async function(){const e=16;let t=0;if(!navigator.gpu)throw new Error("WebGPU not supported on this browser.");const n=await navigator.gpu.requestAdapter();if(!n)throw new Error("No appropriate GPUAdapter found.");const i=await n.requestDevice(),a=new Float32Array([e,e]),o=i.createBuffer({label:"Grid Uniforms",size:a.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(o,0,a);const u=new Uint32Array(e*e),l=[i.createBuffer({label:"Cell State A",size:u.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),i.createBuffer({label:"Cell State B",size:u.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})];for(let e=0;e<u.length;e+=3)u[e]=1;i.queue.writeBuffer(l[0],0,u);for(let e=0;e<u.length;e++)u[e]=e%2;i.queue.writeBuffer(l[1],0,u);const f=r.getContext("webgpu"),s=navigator.gpu.getPreferredCanvasFormat();f.configure({device:i,format:s});const c=new Float32Array([-.8,-.8,.8,-.8,.8,.8,-.8,-.8,.8,.8,-.8,.8]),g=i.createBuffer({label:"Cell vertices",size:c.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(g,0,c);const d=i.createShaderModule({label:"Cell shader",code:"@group(0) @binding(0) var<uniform> grid: vec2f;\n@group(0) @binding(1) var<storage, read> cellState: array<u32>; \n\nstruct VertexInput {\n  @location(0) pos: vec2f,\n  @builtin(instance_index) instance: u32,\n};\n\nstruct VertexOutput {\n  @builtin(position) pos: vec4f,\n  @location(0) cell: vec2f,\n};\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    //return vec4f(pos.x, pos.y, 0, 1);\n    //return vec4f(pos / grid, 0, 1);\n\n    // let cell = vec2f(1, 1); // Cell(1,1) in the image above\n    // let cellOffset = cell / grid * 2; // Compute the offset to cell\n    // let gridPos = (input.pos + 1) / grid - 1 + cellOffset; // Add it here!\n\n  let i = f32(input.instance);\n  let state = f32(cellState[input.instance]);\n\n  let cell = vec2f(i % grid.x, floor(i / grid.x));\n  let cellOffset = cell / grid * 2;\n  //let gridPos = (input.pos + 1) / grid - 1 + cellOffset;  \n  let gridPos = (input.pos*state+1) / grid - 1 + cellOffset;\n\n    //return vec4f(gridPos, 0, 1);\n    var output: VertexOutput;\n    output.pos = vec4f(gridPos, 0, 1);\n    output.cell = cell;\n    return output;\n}\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    //return vec4f(1, 0, 0, 1); // (Red, Green, Blue, Alpha)\n  \n    let c = input.cell / grid;\n    return vec4f(c, 1-c.x, 1);\n}"}),p=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),b=i.createPipelineLayout({bindGroupLayouts:[p]}),v=i.createRenderPipeline({label:"Cell pipeline",layout:b,vertex:{module:d,entryPoint:"vertexMain",buffers:[{arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]}]},fragment:{module:d,entryPoint:"fragmentMain",targets:[{format:s}]}}),P=[i.createBindGroup({label:"Cell renderer bind group A",layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:l[0]}}]}),i.createBindGroup({label:"Cell renderer bind group B",layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:l[1]}}]})];setInterval(function(){t++;const r=i.createCommandEncoder(),n=r.beginRenderPass({colorAttachments:[{view:f.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:.4,a:1}}]});n.setPipeline(v),n.setBindGroup(0,P[t%2]),n.setVertexBuffer(0,g),n.draw(c.length/2,e*e),n.end(),i.queue.submit([r.finish()])},200)}()}});