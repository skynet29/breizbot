{"version":3,"sources":["../../../../node_modules/browser-pack/_prelude.js","lib/CallbackEmitter.js","lib/ColorSensor.js","lib/Const.js","lib/Device.js","lib/DistanceSensor.js","lib/DoubleMotor.js","lib/Led.js","lib/Motor.js","lib/RgbLed.js","lib/TachoMotor.js","lib/TiltSensor.js","lib/Util.js","lib/hub.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hub.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","class CallbackEmitter {\n    constructor() {\n        this.callbacks = []\n    }\n\n    /**\n     * \n     * @param {(data) => boolean} callback \n     */\n    on(callback) {\n        this.callbacks.push(callback)\n    }\n\n    emit(data) {\n        console.log('emit', data)\n        let i = this.callbacks.length\n\n        while (i--) {\n            const callback = this.callbacks[i]\n            if (callback(data)) {\n                this.callbacks.splice(i, 1)\n            }\n        }\n    }\n}\n\nmodule.exports = CallbackEmitter","const Device = require('./Device')\n\n\nclass ColorSensor extends Device {\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    async setBrightness (firstSegment, secondSegment, thirdSegment) {\n        await this.setMode(0x03, false)\n\n        return this.writeDirectMode(0x03, firstSegment, secondSegment, thirdSegment)\n    }\n}\n\nmodule.exports = ColorSensor","//@ts-check\n\nconst { getEnumName } = $$.util\n\nconst Event = {\n    DETACHED_IO: 0x00,\n    ATTACHED_IO: 0x01,\n    ATTACHED_VIRTUAL_IO: 0x02,\n}\nconst EventNames = getEnumName(Event)\n\nconst HubAlertType = {\n    LOW_VOLTAGE: 0x01,\n    HIGH_CURRENT: 0x02,\n    LOW_SIGNAL_STRENGTH: 0x03,\n    OVER_POWER_CONDITION: 0x04\n}\n\nconst MessageType = {\n    HUB_PROPERTIES: 0x01,\n    HUB_ACTIONS: 0x02,\n    HUB_ALERTS: 0x03,\n    HUB_ATTACHED_IO: 0x04,\n    GENERIC_ERROR_MESSAGES: 0x05,\n    HW_NETWORK_COMMANDS: 0x08,\n    FW_UPDATE_GO_INTO_BOOT_MODE: 0x10,\n    FW_UPDATE_LOCK_MEMORY: 0x11,\n    FW_UPDATE_LOCK_STATUS_REQUEST: 0x12,\n    FW_LOCK_STATUS: 0x13,\n    PORT_INFORMATION_REQUEST: 0x21,\n    PORT_MODE_INFORMATION_REQUEST: 0x22,\n    PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,\n    PORT_INPUT_FORMAT_SETUP_COMBINEDMODE: 0x42,\n    PORT_INFORMATION: 0x43,\n    PORT_MODE_INFORMATION: 0x44,\n    PORT_VALUE_SINGLE: 0x45,\n    PORT_VALUE_COMBINEDMODE: 0x46,\n    PORT_INPUT_FORMAT_SINGLE: 0x47,\n    PORT_INPUT_FORMAT_COMBINEDMODE: 0x48,\n    VIRTUAL_PORT_SETUP: 0x61,\n    PORT_OUTPUT_COMMAND: 0x81,\n    PORT_OUTPUT_COMMAND_FEEDBACK: 0x82,\n}\n\n\n\nconst MessageTypeNames = getEnumName(MessageType)\n\nconst DeviceType = {\n    UNKNOWN: 0,\n    SIMPLE_MEDIUM_LINEAR_MOTOR: 1,\n    TRAIN_MOTOR: 2,\n    LIGHT: 8,\n    VOLTAGE_SENSOR: 20,\n    CURRENT_SENSOR: 21,\n    PIEZO_BUZZER: 22,\n    HUB_LED: 23,\n    TILT_SENSOR: 34,\n    MOTION_SENSOR: 35,\n    COLOR_DISTANCE_SENSOR: 37,\n    MEDIUM_LINEAR_MOTOR: 38,\n    MOVE_HUB_MEDIUM_LINEAR_MOTOR: 39,\n    MOVE_HUB_TILT_SENSOR: 40,\n    DUPLO_TRAIN_BASE_MOTOR: 41,\n    DUPLO_TRAIN_BASE_SPEAKER: 42,\n    DUPLO_TRAIN_BASE_COLOR_SENSOR: 43,\n    DUPLO_TRAIN_BASE_SPEEDOMETER: 44,\n    TECHNIC_LARGE_LINEAR_MOTOR: 46, // Technic Control+\n    TECHNIC_XLARGE_LINEAR_MOTOR: 47, // Technic Control+\n    TECHNIC_MEDIUM_ANGULAR_MOTOR: 48, // Spike Prime\n    TECHNIC_LARGE_ANGULAR_MOTOR: 49, // Spike Prime\n    TECHNIC_MEDIUM_HUB_GEST_SENSOR: 54,\n    REMOTE_CONTROL_BUTTON: 55,\n    REMOTE_CONTROL_RSSI: 56,\n    TECHNIC_MEDIUM_HUB_ACCELEROMETER: 57,\n    TECHNIC_MEDIUM_HUB_GYRO_SENSOR: 58,\n    TECHNIC_MEDIUM_HUB_TILT_SENSOR: 59,\n    TECHNIC_MEDIUM_HUB_TEMPERATURE_SENSOR: 60,\n    TECHNIC_COLOR_SENSOR: 61, // Spike Prime\n    TECHNIC_DISTANCE_SENSOR: 62, // Spike Prime\n    TECHNIC_FORCE_SENSOR: 63, // Spike Prime\n    TECHNIC_3X3_COLOR_LIGHT_MATRIX: 64, // Spike Essential\n    TECHNIC_SMALL_ANGULAR_MOTOR: 65, // Spike Essential\n    MARIO_ACCELEROMETER: 71,\n    MARIO_BARCODE_SENSOR: 73,\n    MARIO_PANTS_SENSOR: 74,\n    TECHNIC_MEDIUM_ANGULAR_MOTOR_GREY: 75, // Mindstorms\n    TECHNIC_LARGE_ANGULAR_MOTOR_GREY: 76, // Technic Control+\n    VIRTUAL_DEVICE: 100\n}\n\nconst DeviceTypeNames = getEnumName(DeviceType)\n\nconst ErrorCode = {\n    ACK: 0x01,\n    MACK: 0x02,\n    BUFFER_OVERFLOW: 0x03,\n    TIMEOUT: 0x04,\n    COMMAND_NOT_RECOGNIZED: 0x05,\n    INVALID_USE: 0x06,\n    OVERCURRENT: 0x07,\n    INTERNAL_ERROR: 0x08,\n}\n\nconst ErrorCodeNames = getEnumName(ErrorCode)\n\n\nconst HubPropertyPayload = {\n    ADVERTISING_NAME: 0x01,\n    BUTTON_STATE: 0x02,\n    FW_VERSION: 0x03,\n    HW_VERSION: 0x04,\n    RSSI: 0x05,\n    BATTERY_VOLTAGE: 0x06,\n    BATTERY_TYPE: 0x07,\n    MANUFACTURER_NAME: 0x08,\n    RADIO_FIRMWARE_VERSION: 0x09,\n    LWP_PROTOCOL_VERSION: 0x0A,\n    SYSTEM_TYPE_ID: 0x0B,\n    HW_NETWORK_ID: 0x0C,\n    PRIMARY_MAC_ADDRESS: 0x0D,\n    SECONDARY_MAC_ADDRESS: 0x0E,\n    HW_NETWORK_FAMILY: 0x0F\n}\n\nconst HubPropertyPayloadNames = getEnumName(HubPropertyPayload)\n\nconst ModeInformationType = {\n    NAME: 0x00,\n    RAW: 0x01,\n    PCT: 0x02,\n    SI: 0x03,\n    SYMBOL: 0x04,\n    MAPPING: 0x05,\n    USED_INTERNALLY: 0x06,\n    MOTOR_BIAS: 0x07,\n    CAPABILITY_BITS: 0x08,\n    VALUE_FORMAT: 0x80,\n}\n\nconst ModeInformationTypeNames = getEnumName(ModeInformationType)\n\nconst PortMap = {\n    \"A\": 0,\n    \"B\": 1,\n    \"C\": 2,\n    \"D\": 3,\n    \"HUB_LED\": 50,\n    \"CURRENT_SENSOR\": 59,\n    \"VOLTAGE_SENSOR\": 60,\n    \"ACCELEROMETER\": 97,\n    \"GYRO_SENSOR\": 98,\n    \"TILT_SENSOR\": 99\n}\n\nconst DeviceMode = {\n    POWER: 0x00,\n    SPEED: 0x01,\n    ROTATION: 0x02,\n    ABSOLUTE: 0x03,\n    COLOR: 0x00,\n    RGB: 0x01,\n    TILT_POS: 0x00,\n    TILT_INPACT_COUNT: 0x01\n}\n\nconst BrakingStyle = {\n    FLOAT: 0,\n    HOLD: 126,\n    BRAKE: 127\n}\n\nconst PortMapNames = getEnumName(PortMap)\n\nmodule.exports = {\n    MessageType,\n    MessageTypeNames,\n    Event,\n    EventNames,\n    BrakingStyle,\n    DeviceMode,\n    DeviceType,\n    DeviceTypeNames,\n    ModeInformationType,\n    ModeInformationTypeNames,\n    PortMap,\n    PortMapNames,\n    HubPropertyPayload,\n    HubPropertyPayloadNames,\n    ErrorCodeNames\n}","//@ts-check\n\nconst CallbackEmitter = require('./CallbackEmitter')\nconst { MessageType, PortMapNames } = require('./Const')\nconst { log, toUint32 } = require('./Util')\n\nconst deviceInfo = {}\n\nclass Device {\n    /**\n     * \n     * @param {HUB.HubDevice} hubDevice \n     * @param {number} portId \n     * @param {string} type \n     */\n    constructor(hubDevice, portId, type) {\n        this.hubDevice = hubDevice\n        this.portId = portId\n        this.type = type\n        this.name = PortMapNames[portId]\n        this.feedbackCallback = null\n        this.valueCallback = undefined\n        this.mode = undefined\n        this.waitEnd = false\n        this.notificationEnabled = false\n\n    }\n\n    /**\n     * \n     * @param {boolean} waitEnd \n     * @param  {...any} data \n     * @returns \n     */\n    async writePortCommand(waitEnd, ...data) {\n        this.waitEnd = waitEnd\n        return new Promise(async (resolve) => {\n            this.feedbackCallback = resolve\n            await this.hubDevice.writePortCommand(this.portId, data)\n        })  \n\n    }\n\n    handleFeedback(feedback) {\n        if (typeof this.feedbackCallback == 'function') {\n            if (feedback == 1 && !this.waitEnd) {\n                this.feedbackCallback()\n            }\n            else if (feedback == 10 && this.waitEnd) {\n                this.feedbackCallback()\n            }\n            \n        }\n    }\n\n    /**\n     * \n     * @param {number} mode\n     * @param  {...any} data \n     * @returns \n     */\n    writeDirectMode(mode, ...data) {\n        log('writeDirectMode', this.portId, { mode })\n        return this.writePortCommand(true, 0x51, mode, data)\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @param {boolean} notificationEnabled \n     * @param {number} deltaInterval \n     * @returns \n     */\n    setMode(mode, notificationEnabled, deltaInterval = 1) {\n        console.log('setMode', this.portId, { mode, notificationEnabled })\n\n        this.mode = mode\n        this.notificationEnabled = notificationEnabled\n\n        return this.hubDevice.sendMsg(MessageType.PORT_INPUT_FORMAT_SETUP_SINGLE,\n            this.portId, mode, toUint32(deltaInterval), notificationEnabled ? 0x01 : 0)\n    }\n\n    async readInfo() {\n        let info = deviceInfo[this.type]\n        if (info == undefined) {\n            info = await this.hubDevice.getPortInformation(this.portId)\n            deviceInfo[this.type] = info\n        }\n        return info\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        const info = deviceInfo[this.type]\n        if (info != undefined) {\n            const { VALUE_FORMAT, RAW, SI } = info.modes[this.mode]\n            const range = $$.util.mapRange(RAW.min, RAW.max, SI.min, SI.max)\n            const { dataType, numValues } = VALUE_FORMAT\n            const ret = []\n            let offset = 4\n            let val\n            for (let idx = 0; idx < numValues; idx++) {\n                switch (dataType) {\n                    case '16bit':\n                        val = msg.getInt16(offset, true)\n                        offset += 2\n                        break;\n                    case '8bit':\n                        val = msg.getInt8(offset)\n                        offset += 1\n                        break;\n                    case '32bit':\n                        val = msg.getInt32(offset, true)\n                        offset += 4\n                        break;\n                    case 'float':\n                        val = msg.getFloat32(offset, true)\n                        offset += 4\n                        break;\n\n                }\n                log('val', val)\n                ret.push(Math.trunc(range(val)))\n            }\n            if (ret.length == 1) {\n                return ret[0]\n            }\n            return ret\n\n        }\n    }\n    /**\n     * \n     * @param {DataView} msg \n     */\n    handleValue(msg) {\n        log('handleValue', this.portId, msg)\n        let value = this.decodeValue(msg)\n\n        if (value != undefined && typeof this.valueCallback == 'function') {\n            this.valueCallback(value)\n        }\n    }\n\n\n    /**\n     * \n     * @param {number} mode \n     * @returns \n    */\n    async getValue(mode) {\n        console.log('getValue', this.portId, { mode })\n\n        await this.setMode(mode, false)\n        return new Promise(async (resolve) => {\n            this.valueCallback = (data) => {\n                console.log('value', data)\n                resolve(data)\n                return true\n            }\n            await this.hubDevice.sendMsg(MessageType.PORT_INFORMATION_REQUEST, this.portId, 0x00)\n\n        })\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @param {(data) => Promise<boolean>} testFn \n     * @returns \n     */\n    async waitTestValue(mode, testFn) {\n        await this.setMode(mode, true)\n\n        await new Promise(async (resolve) => {\n            this.valueCallback = async (value) => {\n                log('waitTestValue', value)\n                const ret = await testFn(value)\n                if (ret) {\n                    log('waitTestValue OK')\n                    //await this.setMode(mode, false)\n                    resolve()\n                }\n            }\n\n        })\n        return this.setMode(mode, false)\n    }\n\n    async subscribe(mode, cbk, deltaInterval = 1) {\n        await this.setMode(mode, true, deltaInterval)\n        this.valueCallback = async (data) => {\n            await cbk(data)\n        }\n    }\n\n    async unsubscribe() {\n        if (this.notificationEnabled) {\n            this.setMode(this.mode, false)\n        }\n    }\n\n}\n\nmodule.exports = Device","const Device = require('./Device')\n\n\nclass DistanceSensor extends Device {\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    async setBrightness (topLeft, bottomLeft, topRight, bottomRight) {\n        await this.setMode(0x05, false)\n\n        return this.writeDirectMode(0x05, topLeft, topRight, bottomLeft, bottomRight)\n    }\n}\n\nmodule.exports = DistanceSensor","//@ts-check\n\nconst Motor = require('./Motor')\nconst {BrakingStyle} = require('./Const')\nconst {toInt16, toInt32} = require('./Util')\n\nconst maxPower = 100\n\nclass DoubleMotor extends Motor {\n\n\n    constructor(hubDevice, portId, name) {\n        super(hubDevice, portId, 'Virtual Device')\n        this.name = name\n\n    }\n\n    /**\n     * \n     * @param {number} speed1 \n     * @param {number} speed2 \n     * @returns \n     */\n    setSpeed(speed1, speed2) {\n        return this.writePortCommand(true, 0x08, speed1, speed2, maxPower, 0)\n    }\n\n    setSpeedForTime(speed1, speed2, time, waitFeedback = false, brakingStyle = BrakingStyle.BRAKE) {\n\n        console.log('setSpeedForTime', this.portId, { speed1, speed2, time, waitFeedback, brakingStyle })\n        return this.writePortCommand(waitFeedback, 0x0A, toInt16(time), speed1, speed2, maxPower, brakingStyle)\n    }\n\n    rotateDegrees(degrees, speed1, speed2, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('rotateDegrees', this.portId, { degrees, speed1, speed2, waitFeedback, brakingStyle })\n        return this.writePortCommand(waitFeedback, 0x0C, toInt32(degrees), speed1, speed2, maxPower, brakingStyle)\n    }\n\n    gotoAngle(angle1, angle2, speed, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('gotoAngle', this.portId, { angle1, angle2, speed, waitFeedback, brakingStyle })\n\n        return this.writePortCommand(waitFeedback, 0x0E, toInt32(angle1), toInt32(angle2), speed, maxPower, brakingStyle)\n    }\n}\n\nmodule.exports = DoubleMotor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass Led extends Device {\n\n    /**\n    * \n    * @param {HubDevice} hubDevice \n    * @param {number} portId \n    */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n\n    }\n\n    setBrightness(brightness) {\n        console.log('setBrightness', this.portId, { brightness })\n        return this.writeDirectMode(DeviceMode.POWER, brightness)\n    }\n\n\n}\n\nmodule.exports = Led","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nconst maxPower = 100\n\nclass Motor extends Device {\n\n    /**\n     * \n     * @param {HubDevice} hubDevice \n     * @param {number} portId \n     */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    setPower(power) {\n        console.log('setPower', this.portId, { power })\n        return this.writeDirectMode(DeviceMode.POWER, power)\n    }\n\n\n}\n\nmodule.exports = Motor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames} = require('./Const')\n\nconst DeviceMode = {\n    COLOR: 0x00,\n    RGB: 0x01\n}\n\nclass RgbLed extends Device {\n\n    /**\n    * \n    * @param {HubDevice} hubDevice \n    * @param {number} portId \n    */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n\n    }\n\n    async setColor(color) {\n        console.log('setColor', this.portId, { color })\n        await this.setMode(DeviceMode.COLOR, false)\n        return this.writeDirectMode(DeviceMode.COLOR, color)\n    }\n\n    async setRGBColor(r, g, b) {\n        console.log('setColor', this.portId, { r, g, b })\n        await this.setMode(DeviceMode.RGB, false)\n        return this.writeDirectMode(DeviceMode.RGB, r, g, b)\n    }\n}\n\nmodule.exports = RgbLed","//@ts-check\n\nconst Motor = require('./Motor')\nconst {PortMapNames, DeviceMode, BrakingStyle} = require('./Const')\nconst {toInt32, toInt16} = require('./Util')\n\nconst maxPower = 100\n\nclass TachoMotor extends Motor {\n\n    /**\n     * \n     * @param {HubDevice} hubDevice \n     * @param {number} portId \n     */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    setSpeed(speed) {\n        console.log('#setSpeed', this.portId, { speed })\n        if (speed == 0) {\n            return this.setPower(0)\n        }\n        return this.writePortCommand(true, 0x07, speed, maxPower, 0)\n    }\n\n    rotateDegrees(degrees, speed, waitEnd, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('rotateDegrees', this.portId, { degrees, speed, waitEnd, brakingStyle })\n        return this.writePortCommand(waitEnd, 0x0B, toInt32(degrees), speed, maxPower, brakingStyle)\n    }\n\n    /**\n     * \n     * @param {number} angle \n     * @param {number} speed \n     * @param {boolean} waitEnd \n     * @param {number} brakingStyle \n     * @returns \n     */\n    gotoAngle(angle, speed, waitEnd, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('gotoAngle', this.portId, { angle, speed, waitEnd, brakingStyle })\n\n        if (this.calibrationValue) {\n            angle *= this.calibrationValue\n        }\n\n        return this.writePortCommand(waitEnd, 0x0D, toInt32(angle), speed, maxPower, brakingStyle)\n    }\n\n    async gotoAbsPosition(angle, speed, waitEnd, brakingStyle = BrakingStyle.BRAKE) {\n        const absPos = await this.getAbsolutePosition()\n        console.log('gotoAbsPosition', this.portId, { angle, absPos, speed, waitEnd, brakingStyle })\n\n        let diff = angle - absPos\n        if (diff < 0) {\n            speed = -speed\n        }\n        diff = Math.abs(diff)\n        return this.rotateDegrees(diff, speed, waitEnd, brakingStyle)\n\n    }\n\n    setSpeedForTime(speed, time, waitEnd = false, brakingStyle = BrakingStyle.BRAKE) {\n\n        console.log('setSpeedForTime', this.portId, { speed, time, waitEnd, brakingStyle })\n        return this.writePortCommand(waitEnd, 0x09, toInt16(time), speed, maxPower, brakingStyle)\n    }\n\n    resetZero() {\n        console.log('resetZero', this.portId)\n        return this.writeDirectMode(DeviceMode.ROTATION, 0x00, 0x00, 0x00, 0x00)\n    }\n\n    getSpeed() {\n        return this.getValue(DeviceMode.SPEED)\n    }\n\n    getPosition() {\n        return this.getValue(DeviceMode.ROTATION)\n    }\n\n    async getAbsolutePosition() {\n        const angle = await this.getValue(DeviceMode.ABSOLUTE)\n        return (angle < 0) ? angle + 360 : angle\n    }\n\n    async calibrate() {\n\n        console.log('calibrate', this.portId)\n        this.setPower(50)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value > 10)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value == 0)\n\n\n        this.setPower(0)\n\n        await $$.util.wait(1000)\n\n        // await this.hubDevice.setPortFormat(this.portId, DeviceMode.ROTATION)\n        // let value = await this.hubDevice.getPortValue(this.portId)\n        // console.log(value)\t\n\n        await this.resetZero()\n\n\n        this.setPower(-50)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => Math.abs(value) > 10)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value == 0)\n\n        this.setPower(0)\n        const value = await this.getValue(DeviceMode.ROTATION)\n        console.log(value)\n        const offset = Math.floor(value / 2)\n        console.log({ offset })\n        await this.gotoAngle(offset, 10, true)\n        await this.resetZero()\n        this.calibrationValue = Math.abs(offset)\n    }\n\n}\n\nmodule.exports = TachoMotor","//@ts-check\n\nconst Device = require('./Device')\nconst { DeviceMode } = require('./Const')\nconst {toInt32} = require('./Util')\n\n\nclass TiltSensor extends Device {\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    getImpactCount() {\n        return this.getValue(DeviceMode.TILT_INPACT_COUNT)\n    }\n\n    setImpactCount(count) {\n        return this.writeDirectMode(DeviceMode.TILT_INPACT_COUNT, toInt32(count))\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        /**@type {Array<number>} */\n        const value = super.decodeValue(msg)\n\n        if (this.mode == DeviceMode.TILT_POS) {\n            const [yaw, pitch, roll] = value\n            return { yaw, pitch, roll }\n        }\n\n        return value\n    }\n}\n\nmodule.exports = TiltSensor\n","//@ts-check\n\n/**\n  * \n  * @param {number} val \n  * @returns {Array}\n  */\nfunction toInt16(val) {\n    const buff = new Uint8Array(2)\n    const view = new DataView(buff.buffer)\n    view.setInt16(0, val, true)\n    return Array.from(buff)\n}\n\n/**\n * \n * @param {number} val \n * @returns {Array}\n */\nfunction toInt32(val) {\n    const buff = new Uint8Array(4)\n    const view = new DataView(buff.buffer)\n    view.setInt32(0, val, true)\n    return Array.from(buff)\n}\n\nfunction toUint32(val) {\n    const buff = new Uint8Array(4)\n    const view = new DataView(buff.buffer)\n    view.setUint32(0, val, true)\n    return Array.from(buff)\n}\n\nconst debug = false\n\nconst log = function (...data) {\n    if (debug) {\n        console.log.apply(console, data)\n    }\n}\n\nmodule.exports = {\n    toInt16,\n    toInt32,\n    toUint32,\n    log\n}","//@ts-check\n\n\n(function () {\n\n    const CallbackEmitter = require('./CallbackEmitter')\n    const { EventNames, DeviceMode, DeviceTypeNames, BrakingStyle, PortMap, HubPropertyPayloadNames, ModeInformationTypeNames, Event, DeviceType, PortMapNames, MessageType, HubPropertyPayload, ModeInformationType, ErrorCodeNames, MessageTypeNames } = require('./Const')\n    const Motor = require('./Motor')\n    const DoubleMotor = require('./DoubleMotor')\n    const TachoMotor = require('./TachoMotor');\n    const Device = require('./Device')\n    const RgbLed = require('./RgbLed')\n    const Led = require('./Led')\n    const TiltSensor = require('./TiltSensor')\n    const ColorSensor = require('./ColorSensor')\n    const DistanceSensor = require('./DistanceSensor')\n    const { log } = require('./Util')\n\n    const Color = {\n        BLACK: 0,\n        PINK: 1,\n        PURPLE: 2,\n        BLUE: 3,\n        LIGHT_BLUE: 4,\n        CYAN: 5,\n        GREEN: 6,\n        YELLOW: 7,\n        ORANGE: 8,\n        RED: 9,\n        WHITE: 10,\n        NONE: 255\n    }\n\n    const LPF2_SERVICE_UUID = '00001623-1212-efde-1623-785feabcd123'\n    const LPF2_CHARAC_UUID = '00001624-1212-efde-1623-785feabcd123'\n\n\n    /**\n     * \n     * @param {ArrayBuffer} buf \n     */\n    function abToString(buf) {\n        const uint8buff = new Uint8Array(buf)\n        let ret = \"\"\n        for (let i = 0; i < uint8buff.byteLength && uint8buff[i] != 0; i++) {\n            ret += String.fromCharCode(uint8buff[i])\n        }\n        return ret\n    }\n\n\n    /**\n     * \n     * @param  {...any} data \n     * @returns {ArrayBuffer}\n     */\n    function formatMsg(msgType, ...data) {\n        const buff = data.flat(4)\n        const msgLen = buff.length + 3\n        const buffer = new ArrayBuffer(msgLen)\n        const uint8Buffer = new Uint8Array(buffer)\n        uint8Buffer[0] = msgLen\n        uint8Buffer[1] = 0\n        uint8Buffer[2] = msgType\n        uint8Buffer.set(buff, 3)\n        return buffer\n    }\n\n\n    function getVirtualPortName(portId1, portId2) {\n        const portIdA = PortMapNames[portId1]\n        const portIdB = PortMapNames[portId2]\n        return `${portIdA}_${portIdB}`\n    }\n\n    const constructorMap = {\n        [DeviceType.TECHNIC_LARGE_LINEAR_MOTOR]: TachoMotor,\n        [DeviceType.TECHNIC_LARGE_ANGULAR_MOTOR_GREY]: TachoMotor,\n        [DeviceType.TECHNIC_XLARGE_LINEAR_MOTOR]: TachoMotor,\n        [DeviceType.TECHNIC_MEDIUM_HUB_TILT_SENSOR]: TiltSensor,\n        [DeviceType.HUB_LED]: RgbLed,\n        [DeviceType.LIGHT]: Led,\n        [DeviceType.TECHNIC_MEDIUM_ANGULAR_MOTOR_GREY]: TachoMotor,\n        [DeviceType.TECHNIC_COLOR_SENSOR]: ColorSensor,\n        [DeviceType.TECHNIC_DISTANCE_SENSOR]: DistanceSensor\n    }\n\n    /**@implements HUB.HubDevice */\n    class HubDevice extends EventEmitter2 {\n\n        constructor() {\n            super()\n            this.charac = null\n            this.portCmdQueue = {}\n            this.portCmdCallback = {}\n            /**@type {{[portId: string]: Device}} */\n            this.hubDevices = {}\n            this.busy = false\n            this.attachCallbacks = new CallbackEmitter()\n            this.portCmdQueue = []\n\n        }\n\n        async writePortCommand(portId, ...data) {\n\n            console.log('#writePortCommand', { portId, data })\n\n            const buffer = formatMsg(MessageType.PORT_OUTPUT_COMMAND, portId, 0x11, data)\n\n            if (!this.busy) {\n                this.busy = true\n                await this.sendBuffer(buffer)\n            }\n            else {\n                this.portCmdQueue.push(buffer)\n                console.log('# Busy ! wait feedback')\n\n            }\n\n        }\n\n\n\n        /**\n         * \n         * @param {BluetoothDevice} device \n         */\n        async init(device) {\n\n            const server = await device.gatt.connect()\n            log('Connected')\n            const service = await server.getPrimaryService(LPF2_SERVICE_UUID)\n            this.charac = await service.getCharacteristic(LPF2_CHARAC_UUID)\n\n            const onCharacteristicvaluechanged = (event) => {\n                this.decodeMsg(event.target.value)\n            }\n\n            device.addEventListener('gattserverdisconnected', () => {\n                console.log('onGattServerDisconnected', this)\n                this.charac.removeEventListener('characteristicvaluechanged', onCharacteristicvaluechanged)\n\n                this.charac = null\n                this.emit('disconnected')\n            })\n\n            this.charac.addEventListener('characteristicvaluechanged', onCharacteristicvaluechanged)\n            await this.charac.startNotifications()\n            await $$.util.wait(100)\n        }\n\n        async startNotification() {\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_VOLTAGE, 0x02)\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.SYSTEM_TYPE_ID, 0x05)\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.PRIMARY_MAC_ADDRESS, 0x05)\n            await this.sendMsg(MessageType.HUB_ALERTS, 0x01, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x02, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x03, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x04, 0x01)\n\n        }\n\n\n        async getDblMotor(portId1, portId2) {\n            return new Promise(async (resolve) => {\n                const name = getVirtualPortName(portId1, portId2)\n                const device = Object.values(this.hubDevices).find((d) => d.name == name)\n                if (device) {\n                    resolve(device)\n\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.name == name) {\n                            console.log(`device on portId ${device.portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n\n                    await this.createVirtualPort(portId1, portId2)\n                }\n            })\n        }\n\n        /**\n         * \n         * @param  {ArrayBuffer} buffer \n         */\n        async sendBuffer(buffer) {\n            //console.log('# sendBuffer', buffer)\n            await this.charac.writeValueWithoutResponse(buffer)\n            // console.log('OK')\n            // if (!this.busy) {\n            //     this.busy = true\n            //     await this.charac.writeValueWithoutResponse(buffer)\n            //     this.busy = false\n            //     if (this.cmdQueue.length > 0) {\n            //         console.log('process queued cmd')\n            //         await this.charac.writeValueWithoutResponse(this.cmdQueue.shift())\n            //     }\n\n            // }\n            // else {\n            //     console.log('busy! push in queue')\n            //     this.cmdQueue.push(buffer)\n            // }\n\n        }\n\n        /**\n         * \n         * @param {number} msgType\n         * @param  {...any} data \n         */\n        sendMsg(msgType, ...data) {\n            log('sendMsg', MessageTypeNames[msgType], data)\n            return this.sendBuffer(formatMsg(msgType, data))\n        }\n\n        /**\n         * \n         * @param {string} name \n         * @returns {number}\n         */\n        getPortIdFromName(name) {\n            for (const info of Object.values(this.hubDevices)) {\n                if (info.name == name) {\n                    return info.portId\n                }\n            }\n        }\n\n        /**\n         * @param {number} portId1\n         * @param {number} portId2\n         */\n        createVirtualPort(portId1, portId2) {\n\n            return this.sendMsg(MessageType.VIRTUAL_PORT_SETUP, 0x01, portId1, portId2)\n        }\n\n        shutdown() {\n            return this.sendMsg(MessageType.HUB_ACTIONS, 0x01)\n        }\n\n\n        getHubDevices() {\n            return Object.values(this.hubDevices)\n        }\n\n        async readDeviceInfo() {\n            for (const device of this.getHubDevices()) {\n                await device.readInfo()\n            }\n        }\n\n        getDevice(portId) {\n            return this.hubDevices[portId]\n        }\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<HUB.PortInformation>}\n         */\n        async getPortInformation(portId) {\n\n            const portInfo = await this.getPortInformationRequest(portId)\n            const { count, output, input, capabilities } = portInfo\n            const modes = []\n            for (let mode = 0; mode < count; mode++) {\n                const data = {}\n                let ret\n                data.mode = 0\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.NAME)\n                data.name = ret.name\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.RAW)\n                data[ret.type] = { min: ret.min, max: ret.max }\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.SI)\n                data[ret.type] = { min: ret.min, max: ret.max }\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.SYMBOL)\n                data.unit = ret.symbol\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.VALUE_FORMAT)\n                const { numValues, dataType, totalFigures, decimals } = ret\n                data[ret.type] = { numValues, dataType, totalFigures, decimals }\n                if ((input >> mode) & 0x1) {\n                    data.mode |= 1\n                }\n                if ((output >> mode) & 0x1) {\n                    data.mode |= 2\n                }\n                modes.push(data)\n            }\n\n            return { modes, capabilities }\n        }\n\n\n        getPortInformationRequest(portId) {\n            return new Promise(async (resolve) => {\n                await this.sendMsg(MessageType.PORT_INFORMATION_REQUEST, portId, 0x01)\n                this.portCmdCallback[portId] = resolve\n            })\n        }\n\n\n\n        getPortModeInformationRequest(portId, mode, type) {\n            return new Promise(async (resolve) => {\n                await this.sendMsg(MessageType.PORT_MODE_INFORMATION_REQUEST, portId, mode, type)\n                this.portCmdCallback[portId] = resolve\n            })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        decodeMsg(msg) {\n            const bufferLen = msg.byteLength\n            const msgLen = msg.getUint8(0)\n            const msgType = msg.getUint8(2)\n            log('decodeMsg', { msgType: MessageTypeNames[msgType] })\n            switch (msgType) {\n                case MessageType.HUB_ATTACHED_IO:\n                    this.handlePortMsg(msg)\n                    break;\n                case MessageType.GENERIC_ERROR_MESSAGES:\n                    this.handleGenericErrorMsg(msg)\n                    break;\n                case MessageType.HUB_PROPERTIES:\n                    this.handleHubPropertyResponse(msg)\n                    break\n                case MessageType.HUB_ALERTS:\n                    this.handleHubAlerts(msg);\n                    break\n                case MessageType.PORT_OUTPUT_COMMAND_FEEDBACK:\n                    this.handlePortCommandFeedback(msg)\n                    break;\n                case MessageType.PORT_MODE_INFORMATION:\n                    this.handlePortModeInformation(msg)\n                    break;\n                case MessageType.PORT_INFORMATION:\n                    this.handlePortInformation(msg)\n                    break;\n                case MessageType.PORT_VALUE_SINGLE:\n                    this.handlePortValueSingle(msg)\n                    break;\n            }\n        }\n\n\n        /**\n          * \n          * @param {DataView} msg \n          */\n        handlePortValueSingle(msg) {\n            //log('msg', msg)\n            const portId = msg.getUint8(3)\n            const msgLen = msg.getUint8(0)\n            const device = this.hubDevices[portId]\n            log('handlePortValueSingle', { msgLen, portId })\n            device.handleValue(msg)\n        }\n\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortModeInformation(msg) {\n            const portId = msg.getUint8(3)\n            const mode = msg.getUint8(4)\n            const type = msg.getUint8(5)\n            const data = { portId, mode, type: ModeInformationTypeNames[type] }\n            switch (type) {\n                case ModeInformationType.NAME:\n                    data.name = abToString(msg.buffer.slice(6, msg.byteLength))\n                    break\n                case ModeInformationType.RAW:\n                case ModeInformationType.PCT:\n                case ModeInformationType.SI:\n                    data.min = msg.getFloat32(6, true)\n                    data.max = msg.getFloat32(10, true)\n                    break\n                case ModeInformationType.SYMBOL:\n                    data.symbol = abToString(msg.buffer.slice(6, msg.byteLength))\n                    break\n                case ModeInformationType.VALUE_FORMAT:\n                    data.numValues = msg.getUint8(6)\n                    data.dataType = [\"8bit\", \"16bit\", \"32bit\", \"float\"][msg.getUint8(7)]\n                    data.totalFigures = msg.getUint8(8)\n                    data.decimals = msg.getUint8(9)\n                    break\n            }\n            log('portModeInformation', data)\n            const cb = this.portCmdCallback[portId]\n            if (typeof cb == 'function') {\n                cb(data)\n                delete this.portCmdCallback[portId]\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortInformation(msg) {\n            const portId = msg.getUint8(3)\n            let capabilities = msg.getUint8(5)\n            const count = msg.getUint8(6)\n            const input = msg.getUint16(7, true)\n            const output = msg.getUint16(9, true)\n            log(`Port ${portId}, capabilities ${capabilities}, total modes ${count}, \n                    input modes ${input}, output modes ${output}`)\n            const availableCaps = 'output,input,logical combinable, logical synchronisable'.split(',')\n            let cap = []\n            for (let i = 0; i < 4; i++) {\n                if ((capabilities >> i) & 1) {\n                    cap.push(availableCaps[i])\n                }\n            }\n            const data = { portId, capabilities: cap.join(', '), count, input, output }\n            const cb = this.portCmdCallback[portId]\n            if (typeof cb == 'function') {\n                cb(data)\n            }\n        }\n\n\n        /**\n         * \n         * @param {DataView} msg \n         * @returns \n         */\n        handleHubPropertyResponse(msg) {\n            const property = msg.getUint8(3)\n            log({ property: HubPropertyPayloadNames[property] })\n            if (property == HubPropertyPayload.BATTERY_VOLTAGE) {\n                const batteryLevel = msg.getUint8(5)\n                log({ batteryLevel })\n                this.emit('batteryLevel', { batteryLevel })\n            }\n            else if (property == HubPropertyPayload.BUTTON_STATE) {\n                const buttonState = msg.getUint8(5)\n                log({ buttonState })\n                this.emit('buttonState', { buttonState })\n            }\n            else if (property == HubPropertyPayload.SYSTEM_TYPE_ID) {\n                const systemType = msg.getUint8(5)\n                log({ systemType })\n                //this.emit('buttonState', { buttonState })\n            }\n            else if (property == HubPropertyPayload.PRIMARY_MAC_ADDRESS) {\n                const bytes = []\n                for (let i = 0; i < 6; i++) {\n                    bytes.push(msg.getUint8(5 + i).toString(16).toLocaleUpperCase().padStart(2, '0'))\n                }\n                log({ bytes })\n                this.emit('address', { address: bytes.join(':') })\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handleGenericErrorMsg(msg) {\n            const cmdType = msg.getUint8(3)\n            const errorCode = msg.getUint8(4)\n            log({ cmdType, errorCode: ErrorCodeNames[errorCode] })\n            this.emit('error', { cmdType, errorCode: ErrorCodeNames[errorCode] })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handleHubAlerts(msg) {\n            const bufferLen = msg.byteLength\n            const msgLen = msg.getUint8(0)\n            const type = msg.getUint8(3)\n            const operation = msg.getUint8(4)\n            const payload = msg.getUint8(5)\n\n            log('handleHubAlerts', { bufferLen, msgLen, type, operation, payload })\n            this.emit('hubAlerts', { type, payload })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortCommandFeedback(msg) {\n            for (let offset = 3; offset < msg.byteLength; offset += 2) {\n                const portId = msg.getUint8(offset)\n                const feedback = msg.getUint8(offset + 1)\n                const device = this.hubDevices[portId]\n                console.log('#handlePortCommandFeedback', { portId, feedback })\n                this.busy = false\n                if (device != undefined) {\n                    device.handleFeedback(feedback)\n                }\n\n                const buffer = this.portCmdQueue.shift()\n                if (buffer) {\n                    console.log('# process queued cmd')\n                    this.busy = true\n                    this.sendBuffer(buffer)\n                }\n\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortMsg(msg) {\n\n            const portId = msg.getUint8(3)\n            const eventType = msg.getUint8(4)\n            const type = eventType ? msg.getUint16(5, true) : 0\n            const deviceTypeName = DeviceTypeNames[type] || \"Unknown\"\n            const eventName = EventNames[eventType]\n\n            console.log('handlePortMsg', { portId, eventName, deviceTypeName })\n            if (eventType == Event.ATTACHED_IO) {\n\n                let constructor = constructorMap[type]\n                if (!constructor) {\n                    constructor = Device\n                }\n                const device = new constructor(this, portId, deviceTypeName)\n                this.hubDevices[portId] = device\n                this.attachCallbacks.emit(device)\n\n                this.emit('attach', device)\n            }\n            else if (eventType == Event.DETACHED_IO) {\n                delete this.hubDevices[portId]\n                this.emit('detach', { portId })\n            }\n            else if (eventType == Event.ATTACHED_VIRTUAL_IO) {\n                const portId1 = msg.getUint8(7)\n                const portId2 = msg.getUint8(8)\n\n                const device = new DoubleMotor(this, portId, getVirtualPortName(portId1, portId2))\n                this.hubDevices[portId] = device\n                this.attachCallbacks.emit(device)\n\n                this.emit('attach', device)\n            }\n        }\n    }\n\n    $$.service.registerService('hub', {\n\n        init: function () {\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isMotor(device) {\n                return device instanceof Motor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isDoubleMotor(device) {\n                return device instanceof DoubleMotor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isLed(device) {\n                return device instanceof Led\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isTachoMotor(device) {\n                return device instanceof TachoMotor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isColorSensor(device) {\n                return device instanceof ColorSensor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isDistanceSensor(device) {\n                return device instanceof DistanceSensor\n            }\n\n            /**\n             * \n             * @returns {Promise<HubDevice>}\n             */\n            async function connect() {\n                log('connect')\n\n                const device = await navigator.bluetooth.requestDevice({\n                    acceptAllDevices: true,\n                    optionalServices: [LPF2_SERVICE_UUID]\n                })\n\n                const hubDevice = new HubDevice()\n                await hubDevice.init(device)\n\n                return hubDevice\n\n                //await sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_TYPE, 0x05)\n                //await sendMsg(formatMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_VOLTAGE, 0x02))\n                //await sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BUTTON_STATE, 0x02)\n            }\n\n            return {\n                connect,\n                Color,\n                PortMap,\n                PortMapNames,\n                DeviceMode,\n                BrakingStyle,\n                DeviceTypeNames,\n                isMotor,\n                isTachoMotor,\n                isLed,\n                isDoubleMotor,\n                isColorSensor,\n                isDistanceSensor\n            }\n        }\n    });\n\n})();\n\n\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvQ2FsbGJhY2tFbWl0dGVyLmpzIiwibGliL0NvbG9yU2Vuc29yLmpzIiwibGliL0NvbnN0LmpzIiwibGliL0RldmljZS5qcyIsImxpYi9EaXN0YW5jZVNlbnNvci5qcyIsImxpYi9Eb3VibGVNb3Rvci5qcyIsImxpYi9MZWQuanMiLCJsaWIvTW90b3IuanMiLCJsaWIvUmdiTGVkLmpzIiwibGliL1RhY2hvTW90b3IuanMiLCJsaWIvVGlsdFNlbnNvci5qcyIsImxpYi9VdGlsLmpzIiwibGliL2h1Yi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY2xhc3MgQ2FsbGJhY2tFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7KGRhdGEpID0+IGJvb2xlYW59IGNhbGxiYWNrIFxuICAgICAqL1xuICAgIG9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG4gICAgfVxuXG4gICAgZW1pdChkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlbWl0JywgZGF0YSlcbiAgICAgICAgbGV0IGkgPSB0aGlzLmNhbGxiYWNrcy5sZW5ndGhcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2ldXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja0VtaXR0ZXIiLCJjb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5cblxuY2xhc3MgQ29sb3JTZW5zb3IgZXh0ZW5kcyBEZXZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKVxuICAgIH1cblxuICAgIGFzeW5jIHNldEJyaWdodG5lc3MgKGZpcnN0U2VnbWVudCwgc2Vjb25kU2VnbWVudCwgdGhpcmRTZWdtZW50KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0TW9kZSgweDAzLCBmYWxzZSlcblxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoMHgwMywgZmlyc3RTZWdtZW50LCBzZWNvbmRTZWdtZW50LCB0aGlyZFNlZ21lbnQpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yU2Vuc29yIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgeyBnZXRFbnVtTmFtZSB9ID0gJCQudXRpbFxuXG5jb25zdCBFdmVudCA9IHtcbiAgICBERVRBQ0hFRF9JTzogMHgwMCxcbiAgICBBVFRBQ0hFRF9JTzogMHgwMSxcbiAgICBBVFRBQ0hFRF9WSVJUVUFMX0lPOiAweDAyLFxufVxuY29uc3QgRXZlbnROYW1lcyA9IGdldEVudW1OYW1lKEV2ZW50KVxuXG5jb25zdCBIdWJBbGVydFR5cGUgPSB7XG4gICAgTE9XX1ZPTFRBR0U6IDB4MDEsXG4gICAgSElHSF9DVVJSRU5UOiAweDAyLFxuICAgIExPV19TSUdOQUxfU1RSRU5HVEg6IDB4MDMsXG4gICAgT1ZFUl9QT1dFUl9DT05ESVRJT046IDB4MDRcbn1cblxuY29uc3QgTWVzc2FnZVR5cGUgPSB7XG4gICAgSFVCX1BST1BFUlRJRVM6IDB4MDEsXG4gICAgSFVCX0FDVElPTlM6IDB4MDIsXG4gICAgSFVCX0FMRVJUUzogMHgwMyxcbiAgICBIVUJfQVRUQUNIRURfSU86IDB4MDQsXG4gICAgR0VORVJJQ19FUlJPUl9NRVNTQUdFUzogMHgwNSxcbiAgICBIV19ORVRXT1JLX0NPTU1BTkRTOiAweDA4LFxuICAgIEZXX1VQREFURV9HT19JTlRPX0JPT1RfTU9ERTogMHgxMCxcbiAgICBGV19VUERBVEVfTE9DS19NRU1PUlk6IDB4MTEsXG4gICAgRldfVVBEQVRFX0xPQ0tfU1RBVFVTX1JFUVVFU1Q6IDB4MTIsXG4gICAgRldfTE9DS19TVEFUVVM6IDB4MTMsXG4gICAgUE9SVF9JTkZPUk1BVElPTl9SRVFVRVNUOiAweDIxLFxuICAgIFBPUlRfTU9ERV9JTkZPUk1BVElPTl9SRVFVRVNUOiAweDIyLFxuICAgIFBPUlRfSU5QVVRfRk9STUFUX1NFVFVQX1NJTkdMRTogMHg0MSxcbiAgICBQT1JUX0lOUFVUX0ZPUk1BVF9TRVRVUF9DT01CSU5FRE1PREU6IDB4NDIsXG4gICAgUE9SVF9JTkZPUk1BVElPTjogMHg0MyxcbiAgICBQT1JUX01PREVfSU5GT1JNQVRJT046IDB4NDQsXG4gICAgUE9SVF9WQUxVRV9TSU5HTEU6IDB4NDUsXG4gICAgUE9SVF9WQUxVRV9DT01CSU5FRE1PREU6IDB4NDYsXG4gICAgUE9SVF9JTlBVVF9GT1JNQVRfU0lOR0xFOiAweDQ3LFxuICAgIFBPUlRfSU5QVVRfRk9STUFUX0NPTUJJTkVETU9ERTogMHg0OCxcbiAgICBWSVJUVUFMX1BPUlRfU0VUVVA6IDB4NjEsXG4gICAgUE9SVF9PVVRQVVRfQ09NTUFORDogMHg4MSxcbiAgICBQT1JUX09VVFBVVF9DT01NQU5EX0ZFRURCQUNLOiAweDgyLFxufVxuXG5cblxuY29uc3QgTWVzc2FnZVR5cGVOYW1lcyA9IGdldEVudW1OYW1lKE1lc3NhZ2VUeXBlKVxuXG5jb25zdCBEZXZpY2VUeXBlID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgU0lNUExFX01FRElVTV9MSU5FQVJfTU9UT1I6IDEsXG4gICAgVFJBSU5fTU9UT1I6IDIsXG4gICAgTElHSFQ6IDgsXG4gICAgVk9MVEFHRV9TRU5TT1I6IDIwLFxuICAgIENVUlJFTlRfU0VOU09SOiAyMSxcbiAgICBQSUVaT19CVVpaRVI6IDIyLFxuICAgIEhVQl9MRUQ6IDIzLFxuICAgIFRJTFRfU0VOU09SOiAzNCxcbiAgICBNT1RJT05fU0VOU09SOiAzNSxcbiAgICBDT0xPUl9ESVNUQU5DRV9TRU5TT1I6IDM3LFxuICAgIE1FRElVTV9MSU5FQVJfTU9UT1I6IDM4LFxuICAgIE1PVkVfSFVCX01FRElVTV9MSU5FQVJfTU9UT1I6IDM5LFxuICAgIE1PVkVfSFVCX1RJTFRfU0VOU09SOiA0MCxcbiAgICBEVVBMT19UUkFJTl9CQVNFX01PVE9SOiA0MSxcbiAgICBEVVBMT19UUkFJTl9CQVNFX1NQRUFLRVI6IDQyLFxuICAgIERVUExPX1RSQUlOX0JBU0VfQ09MT1JfU0VOU09SOiA0MyxcbiAgICBEVVBMT19UUkFJTl9CQVNFX1NQRUVET01FVEVSOiA0NCxcbiAgICBURUNITklDX0xBUkdFX0xJTkVBUl9NT1RPUjogNDYsIC8vIFRlY2huaWMgQ29udHJvbCtcbiAgICBURUNITklDX1hMQVJHRV9MSU5FQVJfTU9UT1I6IDQ3LCAvLyBUZWNobmljIENvbnRyb2wrXG4gICAgVEVDSE5JQ19NRURJVU1fQU5HVUxBUl9NT1RPUjogNDgsIC8vIFNwaWtlIFByaW1lXG4gICAgVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SOiA0OSwgLy8gU3Bpa2UgUHJpbWVcbiAgICBURUNITklDX01FRElVTV9IVUJfR0VTVF9TRU5TT1I6IDU0LFxuICAgIFJFTU9URV9DT05UUk9MX0JVVFRPTjogNTUsXG4gICAgUkVNT1RFX0NPTlRST0xfUlNTSTogNTYsXG4gICAgVEVDSE5JQ19NRURJVU1fSFVCX0FDQ0VMRVJPTUVURVI6IDU3LFxuICAgIFRFQ0hOSUNfTUVESVVNX0hVQl9HWVJPX1NFTlNPUjogNTgsXG4gICAgVEVDSE5JQ19NRURJVU1fSFVCX1RJTFRfU0VOU09SOiA1OSxcbiAgICBURUNITklDX01FRElVTV9IVUJfVEVNUEVSQVRVUkVfU0VOU09SOiA2MCxcbiAgICBURUNITklDX0NPTE9SX1NFTlNPUjogNjEsIC8vIFNwaWtlIFByaW1lXG4gICAgVEVDSE5JQ19ESVNUQU5DRV9TRU5TT1I6IDYyLCAvLyBTcGlrZSBQcmltZVxuICAgIFRFQ0hOSUNfRk9SQ0VfU0VOU09SOiA2MywgLy8gU3Bpa2UgUHJpbWVcbiAgICBURUNITklDXzNYM19DT0xPUl9MSUdIVF9NQVRSSVg6IDY0LCAvLyBTcGlrZSBFc3NlbnRpYWxcbiAgICBURUNITklDX1NNQUxMX0FOR1VMQVJfTU9UT1I6IDY1LCAvLyBTcGlrZSBFc3NlbnRpYWxcbiAgICBNQVJJT19BQ0NFTEVST01FVEVSOiA3MSxcbiAgICBNQVJJT19CQVJDT0RFX1NFTlNPUjogNzMsXG4gICAgTUFSSU9fUEFOVFNfU0VOU09SOiA3NCxcbiAgICBURUNITklDX01FRElVTV9BTkdVTEFSX01PVE9SX0dSRVk6IDc1LCAvLyBNaW5kc3Rvcm1zXG4gICAgVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SX0dSRVk6IDc2LCAvLyBUZWNobmljIENvbnRyb2wrXG4gICAgVklSVFVBTF9ERVZJQ0U6IDEwMFxufVxuXG5jb25zdCBEZXZpY2VUeXBlTmFtZXMgPSBnZXRFbnVtTmFtZShEZXZpY2VUeXBlKVxuXG5jb25zdCBFcnJvckNvZGUgPSB7XG4gICAgQUNLOiAweDAxLFxuICAgIE1BQ0s6IDB4MDIsXG4gICAgQlVGRkVSX09WRVJGTE9XOiAweDAzLFxuICAgIFRJTUVPVVQ6IDB4MDQsXG4gICAgQ09NTUFORF9OT1RfUkVDT0dOSVpFRDogMHgwNSxcbiAgICBJTlZBTElEX1VTRTogMHgwNixcbiAgICBPVkVSQ1VSUkVOVDogMHgwNyxcbiAgICBJTlRFUk5BTF9FUlJPUjogMHgwOCxcbn1cblxuY29uc3QgRXJyb3JDb2RlTmFtZXMgPSBnZXRFbnVtTmFtZShFcnJvckNvZGUpXG5cblxuY29uc3QgSHViUHJvcGVydHlQYXlsb2FkID0ge1xuICAgIEFEVkVSVElTSU5HX05BTUU6IDB4MDEsXG4gICAgQlVUVE9OX1NUQVRFOiAweDAyLFxuICAgIEZXX1ZFUlNJT046IDB4MDMsXG4gICAgSFdfVkVSU0lPTjogMHgwNCxcbiAgICBSU1NJOiAweDA1LFxuICAgIEJBVFRFUllfVk9MVEFHRTogMHgwNixcbiAgICBCQVRURVJZX1RZUEU6IDB4MDcsXG4gICAgTUFOVUZBQ1RVUkVSX05BTUU6IDB4MDgsXG4gICAgUkFESU9fRklSTVdBUkVfVkVSU0lPTjogMHgwOSxcbiAgICBMV1BfUFJPVE9DT0xfVkVSU0lPTjogMHgwQSxcbiAgICBTWVNURU1fVFlQRV9JRDogMHgwQixcbiAgICBIV19ORVRXT1JLX0lEOiAweDBDLFxuICAgIFBSSU1BUllfTUFDX0FERFJFU1M6IDB4MEQsXG4gICAgU0VDT05EQVJZX01BQ19BRERSRVNTOiAweDBFLFxuICAgIEhXX05FVFdPUktfRkFNSUxZOiAweDBGXG59XG5cbmNvbnN0IEh1YlByb3BlcnR5UGF5bG9hZE5hbWVzID0gZ2V0RW51bU5hbWUoSHViUHJvcGVydHlQYXlsb2FkKVxuXG5jb25zdCBNb2RlSW5mb3JtYXRpb25UeXBlID0ge1xuICAgIE5BTUU6IDB4MDAsXG4gICAgUkFXOiAweDAxLFxuICAgIFBDVDogMHgwMixcbiAgICBTSTogMHgwMyxcbiAgICBTWU1CT0w6IDB4MDQsXG4gICAgTUFQUElORzogMHgwNSxcbiAgICBVU0VEX0lOVEVSTkFMTFk6IDB4MDYsXG4gICAgTU9UT1JfQklBUzogMHgwNyxcbiAgICBDQVBBQklMSVRZX0JJVFM6IDB4MDgsXG4gICAgVkFMVUVfRk9STUFUOiAweDgwLFxufVxuXG5jb25zdCBNb2RlSW5mb3JtYXRpb25UeXBlTmFtZXMgPSBnZXRFbnVtTmFtZShNb2RlSW5mb3JtYXRpb25UeXBlKVxuXG5jb25zdCBQb3J0TWFwID0ge1xuICAgIFwiQVwiOiAwLFxuICAgIFwiQlwiOiAxLFxuICAgIFwiQ1wiOiAyLFxuICAgIFwiRFwiOiAzLFxuICAgIFwiSFVCX0xFRFwiOiA1MCxcbiAgICBcIkNVUlJFTlRfU0VOU09SXCI6IDU5LFxuICAgIFwiVk9MVEFHRV9TRU5TT1JcIjogNjAsXG4gICAgXCJBQ0NFTEVST01FVEVSXCI6IDk3LFxuICAgIFwiR1lST19TRU5TT1JcIjogOTgsXG4gICAgXCJUSUxUX1NFTlNPUlwiOiA5OVxufVxuXG5jb25zdCBEZXZpY2VNb2RlID0ge1xuICAgIFBPV0VSOiAweDAwLFxuICAgIFNQRUVEOiAweDAxLFxuICAgIFJPVEFUSU9OOiAweDAyLFxuICAgIEFCU09MVVRFOiAweDAzLFxuICAgIENPTE9SOiAweDAwLFxuICAgIFJHQjogMHgwMSxcbiAgICBUSUxUX1BPUzogMHgwMCxcbiAgICBUSUxUX0lOUEFDVF9DT1VOVDogMHgwMVxufVxuXG5jb25zdCBCcmFraW5nU3R5bGUgPSB7XG4gICAgRkxPQVQ6IDAsXG4gICAgSE9MRDogMTI2LFxuICAgIEJSQUtFOiAxMjdcbn1cblxuY29uc3QgUG9ydE1hcE5hbWVzID0gZ2V0RW51bU5hbWUoUG9ydE1hcClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWVzc2FnZVR5cGUsXG4gICAgTWVzc2FnZVR5cGVOYW1lcyxcbiAgICBFdmVudCxcbiAgICBFdmVudE5hbWVzLFxuICAgIEJyYWtpbmdTdHlsZSxcbiAgICBEZXZpY2VNb2RlLFxuICAgIERldmljZVR5cGUsXG4gICAgRGV2aWNlVHlwZU5hbWVzLFxuICAgIE1vZGVJbmZvcm1hdGlvblR5cGUsXG4gICAgTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzLFxuICAgIFBvcnRNYXAsXG4gICAgUG9ydE1hcE5hbWVzLFxuICAgIEh1YlByb3BlcnR5UGF5bG9hZCxcbiAgICBIdWJQcm9wZXJ0eVBheWxvYWROYW1lcyxcbiAgICBFcnJvckNvZGVOYW1lc1xufSIsIi8vQHRzLWNoZWNrXG5cbmNvbnN0IENhbGxiYWNrRW1pdHRlciA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tFbWl0dGVyJylcbmNvbnN0IHsgTWVzc2FnZVR5cGUsIFBvcnRNYXBOYW1lcyB9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG5jb25zdCB7IGxvZywgdG9VaW50MzIgfSA9IHJlcXVpcmUoJy4vVXRpbCcpXG5cbmNvbnN0IGRldmljZUluZm8gPSB7fVxuXG5jbGFzcyBEZXZpY2Uge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7SFVCLkh1YkRldmljZX0gaHViRGV2aWNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5odWJEZXZpY2UgPSBodWJEZXZpY2VcbiAgICAgICAgdGhpcy5wb3J0SWQgPSBwb3J0SWRcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZVxuICAgICAgICB0aGlzLm5hbWUgPSBQb3J0TWFwTmFtZXNbcG9ydElkXVxuICAgICAgICB0aGlzLmZlZWRiYWNrQ2FsbGJhY2sgPSBudWxsXG4gICAgICAgIHRoaXMudmFsdWVDYWxsYmFjayA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLm1vZGUgPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy53YWl0RW5kID0gZmFsc2VcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25FbmFibGVkID0gZmFsc2VcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FpdEVuZCBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGRhdGEgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVQb3J0Q29tbWFuZCh3YWl0RW5kLCAuLi5kYXRhKSB7XG4gICAgICAgIHRoaXMud2FpdEVuZCA9IHdhaXRFbmRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrQ2FsbGJhY2sgPSByZXNvbHZlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmh1YkRldmljZS53cml0ZVBvcnRDb21tYW5kKHRoaXMucG9ydElkLCBkYXRhKVxuICAgICAgICB9KSAgXG5cbiAgICB9XG5cbiAgICBoYW5kbGVGZWVkYmFjayhmZWVkYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZmVlZGJhY2tDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZmVlZGJhY2sgPT0gMSAmJiAhdGhpcy53YWl0RW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWVkYmFja0NhbGxiYWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZlZWRiYWNrID09IDEwICYmIHRoaXMud2FpdEVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tDYWxsYmFjaygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBkYXRhIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHdyaXRlRGlyZWN0TW9kZShtb2RlLCAuLi5kYXRhKSB7XG4gICAgICAgIGxvZygnd3JpdGVEaXJlY3RNb2RlJywgdGhpcy5wb3J0SWQsIHsgbW9kZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHRydWUsIDB4NTEsIG1vZGUsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBub3RpZmljYXRpb25FbmFibGVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YUludGVydmFsIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHNldE1vZGUobW9kZSwgbm90aWZpY2F0aW9uRW5hYmxlZCwgZGVsdGFJbnRlcnZhbCA9IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldE1vZGUnLCB0aGlzLnBvcnRJZCwgeyBtb2RlLCBub3RpZmljYXRpb25FbmFibGVkIH0pXG5cbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZVxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbkVuYWJsZWQgPSBub3RpZmljYXRpb25FbmFibGVkXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaHViRGV2aWNlLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9JTlBVVF9GT1JNQVRfU0VUVVBfU0lOR0xFLFxuICAgICAgICAgICAgdGhpcy5wb3J0SWQsIG1vZGUsIHRvVWludDMyKGRlbHRhSW50ZXJ2YWwpLCBub3RpZmljYXRpb25FbmFibGVkID8gMHgwMSA6IDApXG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZEluZm8oKSB7XG4gICAgICAgIGxldCBpbmZvID0gZGV2aWNlSW5mb1t0aGlzLnR5cGVdXG4gICAgICAgIGlmIChpbmZvID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5mbyA9IGF3YWl0IHRoaXMuaHViRGV2aWNlLmdldFBvcnRJbmZvcm1hdGlvbih0aGlzLnBvcnRJZClcbiAgICAgICAgICAgIGRldmljZUluZm9bdGhpcy50eXBlXSA9IGluZm9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mb1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgKi9cbiAgICBkZWNvZGVWYWx1ZShtc2cpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGRldmljZUluZm9bdGhpcy50eXBlXVxuICAgICAgICBpZiAoaW5mbyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgVkFMVUVfRk9STUFULCBSQVcsIFNJIH0gPSBpbmZvLm1vZGVzW3RoaXMubW9kZV1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gJCQudXRpbC5tYXBSYW5nZShSQVcubWluLCBSQVcubWF4LCBTSS5taW4sIFNJLm1heClcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YVR5cGUsIG51bVZhbHVlcyB9ID0gVkFMVUVfRk9STUFUXG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDRcbiAgICAgICAgICAgIGxldCB2YWxcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG51bVZhbHVlczsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzE2Yml0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG1zZy5nZXRJbnQxNihvZmZzZXQsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzhiaXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbXNnLmdldEludDgob2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICczMmJpdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtc2cuZ2V0SW50MzIob2Zmc2V0LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtc2cuZ2V0RmxvYXQzMihvZmZzZXQsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nKCd2YWwnLCB2YWwpXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goTWF0aC50cnVuYyhyYW5nZSh2YWwpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0WzBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICovXG4gICAgaGFuZGxlVmFsdWUobXNnKSB7XG4gICAgICAgIGxvZygnaGFuZGxlVmFsdWUnLCB0aGlzLnBvcnRJZCwgbXNnKVxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRlY29kZVZhbHVlKG1zZylcblxuICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0aGlzLnZhbHVlQ2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNhbGxiYWNrKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbW9kZSBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAqL1xuICAgIGFzeW5jIGdldFZhbHVlKG1vZGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2dldFZhbHVlJywgdGhpcy5wb3J0SWQsIHsgbW9kZSB9KVxuXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0TW9kZShtb2RlLCBmYWxzZSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2FsbGJhY2sgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd2YWx1ZScsIGRhdGEpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmh1YkRldmljZS5zZW5kTXNnKE1lc3NhZ2VUeXBlLlBPUlRfSU5GT1JNQVRJT05fUkVRVUVTVCwgdGhpcy5wb3J0SWQsIDB4MDApXG5cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbW9kZSBcbiAgICAgKiBAcGFyYW0geyhkYXRhKSA9PiBQcm9taXNlPGJvb2xlYW4+fSB0ZXN0Rm4gXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgYXN5bmMgd2FpdFRlc3RWYWx1ZShtb2RlLCB0ZXN0Rm4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKG1vZGUsIHRydWUpXG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDYWxsYmFjayA9IGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZygnd2FpdFRlc3RWYWx1ZScsIHZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRlc3RGbih2YWx1ZSlcbiAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZygnd2FpdFRlc3RWYWx1ZSBPSycpXG4gICAgICAgICAgICAgICAgICAgIC8vYXdhaXQgdGhpcy5zZXRNb2RlKG1vZGUsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TW9kZShtb2RlLCBmYWxzZSlcbiAgICB9XG5cbiAgICBhc3luYyBzdWJzY3JpYmUobW9kZSwgY2JrLCBkZWx0YUludGVydmFsID0gMSkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldE1vZGUobW9kZSwgdHJ1ZSwgZGVsdGFJbnRlcnZhbClcbiAgICAgICAgdGhpcy52YWx1ZUNhbGxiYWNrID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGNiayhkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TW9kZSh0aGlzLm1vZGUsIGZhbHNlKVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGV2aWNlIiwiY29uc3QgRGV2aWNlID0gcmVxdWlyZSgnLi9EZXZpY2UnKVxuXG5cbmNsYXNzIERpc3RhbmNlU2Vuc29yIGV4dGVuZHMgRGV2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcbiAgICB9XG5cbiAgICBhc3luYyBzZXRCcmlnaHRuZXNzICh0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKDB4MDUsIGZhbHNlKVxuXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZSgweDA1LCB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlU2Vuc29yIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgTW90b3IgPSByZXF1aXJlKCcuL01vdG9yJylcbmNvbnN0IHtCcmFraW5nU3R5bGV9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG5jb25zdCB7dG9JbnQxNiwgdG9JbnQzMn0gPSByZXF1aXJlKCcuL1V0aWwnKVxuXG5jb25zdCBtYXhQb3dlciA9IDEwMFxuXG5jbGFzcyBEb3VibGVNb3RvciBleHRlbmRzIE1vdG9yIHtcblxuXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsICdWaXJ0dWFsIERldmljZScpXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWVcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZDEgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkMiBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICBzZXRTcGVlZChzcGVlZDEsIHNwZWVkMikge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHRydWUsIDB4MDgsIHNwZWVkMSwgc3BlZWQyLCBtYXhQb3dlciwgMClcbiAgICB9XG5cbiAgICBzZXRTcGVlZEZvclRpbWUoc3BlZWQxLCBzcGVlZDIsIHRpbWUsIHdhaXRGZWVkYmFjayA9IGZhbHNlLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnc2V0U3BlZWRGb3JUaW1lJywgdGhpcy5wb3J0SWQsIHsgc3BlZWQxLCBzcGVlZDIsIHRpbWUsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQod2FpdEZlZWRiYWNrLCAweDBBLCB0b0ludDE2KHRpbWUpLCBzcGVlZDEsIHNwZWVkMiwgbWF4UG93ZXIsIGJyYWtpbmdTdHlsZSlcbiAgICB9XG5cbiAgICByb3RhdGVEZWdyZWVzKGRlZ3JlZXMsIHNwZWVkMSwgc3BlZWQyLCB3YWl0RmVlZGJhY2ssIGJyYWtpbmdTdHlsZSA9IEJyYWtpbmdTdHlsZS5CUkFLRSkge1xuICAgICAgICBjb25zb2xlLmxvZygncm90YXRlRGVncmVlcycsIHRoaXMucG9ydElkLCB7IGRlZ3JlZXMsIHNwZWVkMSwgc3BlZWQyLCB3YWl0RmVlZGJhY2ssIGJyYWtpbmdTdHlsZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRGZWVkYmFjaywgMHgwQywgdG9JbnQzMihkZWdyZWVzKSwgc3BlZWQxLCBzcGVlZDIsIG1heFBvd2VyLCBicmFraW5nU3R5bGUpXG4gICAgfVxuXG4gICAgZ290b0FuZ2xlKGFuZ2xlMSwgYW5nbGUyLCBzcGVlZCwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2dvdG9BbmdsZScsIHRoaXMucG9ydElkLCB7IGFuZ2xlMSwgYW5nbGUyLCBzcGVlZCwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgfSlcblxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRGZWVkYmFjaywgMHgwRSwgdG9JbnQzMihhbmdsZTEpLCB0b0ludDMyKGFuZ2xlMiksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEb3VibGVNb3RvciIsIi8vQHRzLWNoZWNrXG5cbmNvbnN0IERldmljZSA9IHJlcXVpcmUoJy4vRGV2aWNlJylcbmNvbnN0IHtQb3J0TWFwTmFtZXMsIERldmljZU1vZGV9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG5cbmNsYXNzIExlZCBleHRlbmRzIERldmljZSB7XG5cbiAgICAvKipcbiAgICAqIFxuICAgICogQHBhcmFtIHtIdWJEZXZpY2V9IGh1YkRldmljZSBcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcblxuICAgIH1cblxuICAgIHNldEJyaWdodG5lc3MoYnJpZ2h0bmVzcykge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0QnJpZ2h0bmVzcycsIHRoaXMucG9ydElkLCB7IGJyaWdodG5lc3MgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVEaXJlY3RNb2RlKERldmljZU1vZGUuUE9XRVIsIGJyaWdodG5lc3MpXG4gICAgfVxuXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMZWQiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jb25zdCBtYXhQb3dlciA9IDEwMFxuXG5jbGFzcyBNb3RvciBleHRlbmRzIERldmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0h1YkRldmljZX0gaHViRGV2aWNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpXG4gICAgfVxuXG4gICAgc2V0UG93ZXIocG93ZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldFBvd2VyJywgdGhpcy5wb3J0SWQsIHsgcG93ZXIgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVEaXJlY3RNb2RlKERldmljZU1vZGUuUE9XRVIsIHBvd2VyKVxuICAgIH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jb25zdCBEZXZpY2VNb2RlID0ge1xuICAgIENPTE9SOiAweDAwLFxuICAgIFJHQjogMHgwMVxufVxuXG5jbGFzcyBSZ2JMZWQgZXh0ZW5kcyBEZXZpY2Uge1xuXG4gICAgLyoqXG4gICAgKiBcbiAgICAqIEBwYXJhbSB7SHViRGV2aWNlfSBodWJEZXZpY2UgXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpXG5cbiAgICB9XG5cbiAgICBhc3luYyBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0Q29sb3InLCB0aGlzLnBvcnRJZCwgeyBjb2xvciB9KVxuICAgICAgICBhd2FpdCB0aGlzLnNldE1vZGUoRGV2aWNlTW9kZS5DT0xPUiwgZmFsc2UpXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLkNPTE9SLCBjb2xvcilcbiAgICB9XG5cbiAgICBhc3luYyBzZXRSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzZXRDb2xvcicsIHRoaXMucG9ydElkLCB7IHIsIGcsIGIgfSlcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKERldmljZU1vZGUuUkdCLCBmYWxzZSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVEaXJlY3RNb2RlKERldmljZU1vZGUuUkdCLCByLCBnLCBiKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZ2JMZWQiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBNb3RvciA9IHJlcXVpcmUoJy4vTW90b3InKVxuY29uc3Qge1BvcnRNYXBOYW1lcywgRGV2aWNlTW9kZSwgQnJha2luZ1N0eWxlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuY29uc3Qge3RvSW50MzIsIHRvSW50MTZ9ID0gcmVxdWlyZSgnLi9VdGlsJylcblxuY29uc3QgbWF4UG93ZXIgPSAxMDBcblxuY2xhc3MgVGFjaG9Nb3RvciBleHRlbmRzIE1vdG9yIHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7SHViRGV2aWNlfSBodWJEZXZpY2UgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcbiAgICB9XG5cbiAgICBzZXRTcGVlZChzcGVlZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnI3NldFNwZWVkJywgdGhpcy5wb3J0SWQsIHsgc3BlZWQgfSlcbiAgICAgICAgaWYgKHNwZWVkID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBvd2VyKDApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh0cnVlLCAweDA3LCBzcGVlZCwgbWF4UG93ZXIsIDApXG4gICAgfVxuXG4gICAgcm90YXRlRGVncmVlcyhkZWdyZWVzLCBzcGVlZCwgd2FpdEVuZCwgYnJha2luZ1N0eWxlID0gQnJha2luZ1N0eWxlLkJSQUtFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyb3RhdGVEZWdyZWVzJywgdGhpcy5wb3J0SWQsIHsgZGVncmVlcywgc3BlZWQsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRFbmQsIDB4MEIsIHRvSW50MzIoZGVncmVlcyksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWQgXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3YWl0RW5kIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBicmFraW5nU3R5bGUgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgZ290b0FuZ2xlKGFuZ2xlLCBzcGVlZCwgd2FpdEVuZCwgYnJha2luZ1N0eWxlID0gQnJha2luZ1N0eWxlLkJSQUtFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnb3RvQW5nbGUnLCB0aGlzLnBvcnRJZCwgeyBhbmdsZSwgc3BlZWQsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSB9KVxuXG4gICAgICAgIGlmICh0aGlzLmNhbGlicmF0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIGFuZ2xlICo9IHRoaXMuY2FsaWJyYXRpb25WYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RW5kLCAweDBELCB0b0ludDMyKGFuZ2xlKSwgc3BlZWQsIG1heFBvd2VyLCBicmFraW5nU3R5bGUpXG4gICAgfVxuXG4gICAgYXN5bmMgZ290b0Fic1Bvc2l0aW9uKGFuZ2xlLCBzcGVlZCwgd2FpdEVuZCwgYnJha2luZ1N0eWxlID0gQnJha2luZ1N0eWxlLkJSQUtFKSB7XG4gICAgICAgIGNvbnN0IGFic1BvcyA9IGF3YWl0IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpXG4gICAgICAgIGNvbnNvbGUubG9nKCdnb3RvQWJzUG9zaXRpb24nLCB0aGlzLnBvcnRJZCwgeyBhbmdsZSwgYWJzUG9zLCBzcGVlZCwgd2FpdEVuZCwgYnJha2luZ1N0eWxlIH0pXG5cbiAgICAgICAgbGV0IGRpZmYgPSBhbmdsZSAtIGFic1Bvc1xuICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgIHNwZWVkID0gLXNwZWVkXG4gICAgICAgIH1cbiAgICAgICAgZGlmZiA9IE1hdGguYWJzKGRpZmYpXG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZURlZ3JlZXMoZGlmZiwgc3BlZWQsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSlcblxuICAgIH1cblxuICAgIHNldFNwZWVkRm9yVGltZShzcGVlZCwgdGltZSwgd2FpdEVuZCA9IGZhbHNlLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnc2V0U3BlZWRGb3JUaW1lJywgdGhpcy5wb3J0SWQsIHsgc3BlZWQsIHRpbWUsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRFbmQsIDB4MDksIHRvSW50MTYodGltZSksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIHJlc2V0WmVybygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0WmVybycsIHRoaXMucG9ydElkKVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoRGV2aWNlTW9kZS5ST1RBVElPTiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMClcbiAgICB9XG5cbiAgICBnZXRTcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5TUEVFRClcbiAgICB9XG5cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5ST1RBVElPTilcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBYnNvbHV0ZVBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGF3YWl0IHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5BQlNPTFVURSlcbiAgICAgICAgcmV0dXJuIChhbmdsZSA8IDApID8gYW5nbGUgKyAzNjAgOiBhbmdsZVxuICAgIH1cblxuICAgIGFzeW5jIGNhbGlicmF0ZSgpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnY2FsaWJyYXRlJywgdGhpcy5wb3J0SWQpXG4gICAgICAgIHRoaXMuc2V0UG93ZXIoNTApXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdFRlc3RWYWx1ZShEZXZpY2VNb2RlLlNQRUVELCAodmFsdWUpID0+IHZhbHVlID4gMTApXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdFRlc3RWYWx1ZShEZXZpY2VNb2RlLlNQRUVELCAodmFsdWUpID0+IHZhbHVlID09IDApXG5cblxuICAgICAgICB0aGlzLnNldFBvd2VyKDApXG5cbiAgICAgICAgYXdhaXQgJCQudXRpbC53YWl0KDEwMDApXG5cbiAgICAgICAgLy8gYXdhaXQgdGhpcy5odWJEZXZpY2Uuc2V0UG9ydEZvcm1hdCh0aGlzLnBvcnRJZCwgRGV2aWNlTW9kZS5ST1RBVElPTilcbiAgICAgICAgLy8gbGV0IHZhbHVlID0gYXdhaXQgdGhpcy5odWJEZXZpY2UuZ2V0UG9ydFZhbHVlKHRoaXMucG9ydElkKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSlcdFxuXG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRaZXJvKClcblxuXG4gICAgICAgIHRoaXMuc2V0UG93ZXIoLTUwKVxuICAgICAgICBhd2FpdCB0aGlzLndhaXRUZXN0VmFsdWUoRGV2aWNlTW9kZS5TUEVFRCwgKHZhbHVlKSA9PiBNYXRoLmFicyh2YWx1ZSkgPiAxMClcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0VGVzdFZhbHVlKERldmljZU1vZGUuU1BFRUQsICh2YWx1ZSkgPT4gdmFsdWUgPT0gMClcblxuICAgICAgICB0aGlzLnNldFBvd2VyKDApXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXRWYWx1ZShEZXZpY2VNb2RlLlJPVEFUSU9OKVxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSlcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcih2YWx1ZSAvIDIpXG4gICAgICAgIGNvbnNvbGUubG9nKHsgb2Zmc2V0IH0pXG4gICAgICAgIGF3YWl0IHRoaXMuZ290b0FuZ2xlKG9mZnNldCwgMTAsIHRydWUpXG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRaZXJvKClcbiAgICAgICAgdGhpcy5jYWxpYnJhdGlvblZhbHVlID0gTWF0aC5hYnMob2Zmc2V0KVxuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhY2hvTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7IERldmljZU1vZGUgfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuY29uc3Qge3RvSW50MzJ9ID0gcmVxdWlyZSgnLi9VdGlsJylcblxuXG5jbGFzcyBUaWx0U2Vuc29yIGV4dGVuZHMgRGV2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcbiAgICB9XG5cbiAgICBnZXRJbXBhY3RDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5USUxUX0lOUEFDVF9DT1VOVClcbiAgICB9XG5cbiAgICBzZXRJbXBhY3RDb3VudChjb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoRGV2aWNlTW9kZS5USUxUX0lOUEFDVF9DT1VOVCwgdG9JbnQzMihjb3VudCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAqL1xuICAgIGRlY29kZVZhbHVlKG1zZykge1xuICAgICAgICAvKipAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5kZWNvZGVWYWx1ZShtc2cpXG5cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PSBEZXZpY2VNb2RlLlRJTFRfUE9TKSB7XG4gICAgICAgICAgICBjb25zdCBbeWF3LCBwaXRjaCwgcm9sbF0gPSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIHsgeWF3LCBwaXRjaCwgcm9sbCB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsdFNlbnNvclxuIiwiLy9AdHMtY2hlY2tcblxuLyoqXG4gICogXG4gICogQHBhcmFtIHtudW1iZXJ9IHZhbCBcbiAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICovXG5mdW5jdGlvbiB0b0ludDE2KHZhbCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSgyKVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpXG4gICAgdmlldy5zZXRJbnQxNigwLCB2YWwsIHRydWUpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnVmZilcbn1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvSW50MzIodmFsKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpXG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcilcbiAgICB2aWV3LnNldEludDMyKDAsIHZhbCwgdHJ1ZSlcbiAgICByZXR1cm4gQXJyYXkuZnJvbShidWZmKVxufVxuXG5mdW5jdGlvbiB0b1VpbnQzMih2YWwpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoNClcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKVxuICAgIHZpZXcuc2V0VWludDMyKDAsIHZhbCwgdHJ1ZSlcbiAgICByZXR1cm4gQXJyYXkuZnJvbShidWZmKVxufVxuXG5jb25zdCBkZWJ1ZyA9IGZhbHNlXG5cbmNvbnN0IGxvZyA9IGZ1bmN0aW9uICguLi5kYXRhKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGRhdGEpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0b0ludDE2LFxuICAgIHRvSW50MzIsXG4gICAgdG9VaW50MzIsXG4gICAgbG9nXG59IiwiLy9AdHMtY2hlY2tcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgQ2FsbGJhY2tFbWl0dGVyID0gcmVxdWlyZSgnLi9DYWxsYmFja0VtaXR0ZXInKVxuICAgIGNvbnN0IHsgRXZlbnROYW1lcywgRGV2aWNlTW9kZSwgRGV2aWNlVHlwZU5hbWVzLCBCcmFraW5nU3R5bGUsIFBvcnRNYXAsIEh1YlByb3BlcnR5UGF5bG9hZE5hbWVzLCBNb2RlSW5mb3JtYXRpb25UeXBlTmFtZXMsIEV2ZW50LCBEZXZpY2VUeXBlLCBQb3J0TWFwTmFtZXMsIE1lc3NhZ2VUeXBlLCBIdWJQcm9wZXJ0eVBheWxvYWQsIE1vZGVJbmZvcm1hdGlvblR5cGUsIEVycm9yQ29kZU5hbWVzLCBNZXNzYWdlVHlwZU5hbWVzIH0gPSByZXF1aXJlKCcuL0NvbnN0JylcbiAgICBjb25zdCBNb3RvciA9IHJlcXVpcmUoJy4vTW90b3InKVxuICAgIGNvbnN0IERvdWJsZU1vdG9yID0gcmVxdWlyZSgnLi9Eb3VibGVNb3RvcicpXG4gICAgY29uc3QgVGFjaG9Nb3RvciA9IHJlcXVpcmUoJy4vVGFjaG9Nb3RvcicpO1xuICAgIGNvbnN0IERldmljZSA9IHJlcXVpcmUoJy4vRGV2aWNlJylcbiAgICBjb25zdCBSZ2JMZWQgPSByZXF1aXJlKCcuL1JnYkxlZCcpXG4gICAgY29uc3QgTGVkID0gcmVxdWlyZSgnLi9MZWQnKVxuICAgIGNvbnN0IFRpbHRTZW5zb3IgPSByZXF1aXJlKCcuL1RpbHRTZW5zb3InKVxuICAgIGNvbnN0IENvbG9yU2Vuc29yID0gcmVxdWlyZSgnLi9Db2xvclNlbnNvcicpXG4gICAgY29uc3QgRGlzdGFuY2VTZW5zb3IgPSByZXF1aXJlKCcuL0Rpc3RhbmNlU2Vuc29yJylcbiAgICBjb25zdCB7IGxvZyB9ID0gcmVxdWlyZSgnLi9VdGlsJylcblxuICAgIGNvbnN0IENvbG9yID0ge1xuICAgICAgICBCTEFDSzogMCxcbiAgICAgICAgUElOSzogMSxcbiAgICAgICAgUFVSUExFOiAyLFxuICAgICAgICBCTFVFOiAzLFxuICAgICAgICBMSUdIVF9CTFVFOiA0LFxuICAgICAgICBDWUFOOiA1LFxuICAgICAgICBHUkVFTjogNixcbiAgICAgICAgWUVMTE9XOiA3LFxuICAgICAgICBPUkFOR0U6IDgsXG4gICAgICAgIFJFRDogOSxcbiAgICAgICAgV0hJVEU6IDEwLFxuICAgICAgICBOT05FOiAyNTVcbiAgICB9XG5cbiAgICBjb25zdCBMUEYyX1NFUlZJQ0VfVVVJRCA9ICcwMDAwMTYyMy0xMjEyLWVmZGUtMTYyMy03ODVmZWFiY2QxMjMnXG4gICAgY29uc3QgTFBGMl9DSEFSQUNfVVVJRCA9ICcwMDAwMTYyNC0xMjEyLWVmZGUtMTYyMy03ODVmZWFiY2QxMjMnXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZiBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYlRvU3RyaW5nKGJ1Zikge1xuICAgICAgICBjb25zdCB1aW50OGJ1ZmYgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgICAgIGxldCByZXQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhidWZmLmJ5dGVMZW5ndGggJiYgdWludDhidWZmW2ldICE9IDA7IGkrKykge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhidWZmW2ldKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gZGF0YSBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0TXNnKG1zZ1R5cGUsIC4uLmRhdGEpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGRhdGEuZmxhdCg0KVxuICAgICAgICBjb25zdCBtc2dMZW4gPSBidWZmLmxlbmd0aCArIDNcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG1zZ0xlbilcbiAgICAgICAgY29uc3QgdWludDhCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgICAgIHVpbnQ4QnVmZmVyWzBdID0gbXNnTGVuXG4gICAgICAgIHVpbnQ4QnVmZmVyWzFdID0gMFxuICAgICAgICB1aW50OEJ1ZmZlclsyXSA9IG1zZ1R5cGVcbiAgICAgICAgdWludDhCdWZmZXIuc2V0KGJ1ZmYsIDMpXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldFZpcnR1YWxQb3J0TmFtZShwb3J0SWQxLCBwb3J0SWQyKSB7XG4gICAgICAgIGNvbnN0IHBvcnRJZEEgPSBQb3J0TWFwTmFtZXNbcG9ydElkMV1cbiAgICAgICAgY29uc3QgcG9ydElkQiA9IFBvcnRNYXBOYW1lc1twb3J0SWQyXVxuICAgICAgICByZXR1cm4gYCR7cG9ydElkQX1fJHtwb3J0SWRCfWBcbiAgICB9XG5cbiAgICBjb25zdCBjb25zdHJ1Y3Rvck1hcCA9IHtcbiAgICAgICAgW0RldmljZVR5cGUuVEVDSE5JQ19MQVJHRV9MSU5FQVJfTU9UT1JdOiBUYWNob01vdG9yLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX0xBUkdFX0FOR1VMQVJfTU9UT1JfR1JFWV06IFRhY2hvTW90b3IsXG4gICAgICAgIFtEZXZpY2VUeXBlLlRFQ0hOSUNfWExBUkdFX0xJTkVBUl9NT1RPUl06IFRhY2hvTW90b3IsXG4gICAgICAgIFtEZXZpY2VUeXBlLlRFQ0hOSUNfTUVESVVNX0hVQl9USUxUX1NFTlNPUl06IFRpbHRTZW5zb3IsXG4gICAgICAgIFtEZXZpY2VUeXBlLkhVQl9MRURdOiBSZ2JMZWQsXG4gICAgICAgIFtEZXZpY2VUeXBlLkxJR0hUXTogTGVkLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX01FRElVTV9BTkdVTEFSX01PVE9SX0dSRVldOiBUYWNob01vdG9yLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX0NPTE9SX1NFTlNPUl06IENvbG9yU2Vuc29yLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX0RJU1RBTkNFX1NFTlNPUl06IERpc3RhbmNlU2Vuc29yXG4gICAgfVxuXG4gICAgLyoqQGltcGxlbWVudHMgSFVCLkh1YkRldmljZSAqL1xuICAgIGNsYXNzIEh1YkRldmljZSBleHRlbmRzIEV2ZW50RW1pdHRlcjIge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKVxuICAgICAgICAgICAgdGhpcy5jaGFyYWMgPSBudWxsXG4gICAgICAgICAgICB0aGlzLnBvcnRDbWRRdWV1ZSA9IHt9XG4gICAgICAgICAgICB0aGlzLnBvcnRDbWRDYWxsYmFjayA9IHt9XG4gICAgICAgICAgICAvKipAdHlwZSB7e1twb3J0SWQ6IHN0cmluZ106IERldmljZX19ICovXG4gICAgICAgICAgICB0aGlzLmh1YkRldmljZXMgPSB7fVxuICAgICAgICAgICAgdGhpcy5idXN5ID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzID0gbmV3IENhbGxiYWNrRW1pdHRlcigpXG4gICAgICAgICAgICB0aGlzLnBvcnRDbWRRdWV1ZSA9IFtdXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIHdyaXRlUG9ydENvbW1hbmQocG9ydElkLCAuLi5kYXRhKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjd3JpdGVQb3J0Q29tbWFuZCcsIHsgcG9ydElkLCBkYXRhIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGZvcm1hdE1zZyhNZXNzYWdlVHlwZS5QT1JUX09VVFBVVF9DT01NQU5ELCBwb3J0SWQsIDB4MTEsIGRhdGEpXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5idXN5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZEJ1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnRDbWRRdWV1ZS5wdXNoKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnIyBCdXN5ICEgd2FpdCBmZWVkYmFjaycpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtCbHVldG9vdGhEZXZpY2V9IGRldmljZSBcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGluaXQoZGV2aWNlKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IGRldmljZS5nYXR0LmNvbm5lY3QoKVxuICAgICAgICAgICAgbG9nKCdDb25uZWN0ZWQnKVxuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IGF3YWl0IHNlcnZlci5nZXRQcmltYXJ5U2VydmljZShMUEYyX1NFUlZJQ0VfVVVJRClcbiAgICAgICAgICAgIHRoaXMuY2hhcmFjID0gYXdhaXQgc2VydmljZS5nZXRDaGFyYWN0ZXJpc3RpYyhMUEYyX0NIQVJBQ19VVUlEKVxuXG4gICAgICAgICAgICBjb25zdCBvbkNoYXJhY3RlcmlzdGljdmFsdWVjaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVNc2coZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXZpY2UuYWRkRXZlbnRMaXN0ZW5lcignZ2F0dHNlcnZlcmRpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb25HYXR0U2VydmVyRGlzY29ubmVjdGVkJywgdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJhYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFyYWN0ZXJpc3RpY3ZhbHVlY2hhbmdlZCcsIG9uQ2hhcmFjdGVyaXN0aWN2YWx1ZWNoYW5nZWQpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJhYyA9IG51bGxcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmNoYXJhYy5hZGRFdmVudExpc3RlbmVyKCdjaGFyYWN0ZXJpc3RpY3ZhbHVlY2hhbmdlZCcsIG9uQ2hhcmFjdGVyaXN0aWN2YWx1ZWNoYW5nZWQpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoYXJhYy5zdGFydE5vdGlmaWNhdGlvbnMoKVxuICAgICAgICAgICAgYXdhaXQgJCQudXRpbC53YWl0KDEwMClcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIHN0YXJ0Tm90aWZpY2F0aW9uKCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9QUk9QRVJUSUVTLCBIdWJQcm9wZXJ0eVBheWxvYWQuQkFUVEVSWV9WT0xUQUdFLCAweDAyKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9QUk9QRVJUSUVTLCBIdWJQcm9wZXJ0eVBheWxvYWQuU1lTVEVNX1RZUEVfSUQsIDB4MDUpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVMsIEh1YlByb3BlcnR5UGF5bG9hZC5QUklNQVJZX01BQ19BRERSRVNTLCAweDA1KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9BTEVSVFMsIDB4MDEsIDB4MDEpXG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX0FMRVJUUywgMHgwMiwgMHgwMSlcbiAgICAgICAgICAgIC8vIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfQUxFUlRTLCAweDAzLCAweDAxKVxuICAgICAgICAgICAgLy8gYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9BTEVSVFMsIDB4MDQsIDB4MDEpXG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgYXN5bmMgZ2V0RGJsTW90b3IocG9ydElkMSwgcG9ydElkMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldFZpcnR1YWxQb3J0TmFtZShwb3J0SWQxLCBwb3J0SWQyKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IE9iamVjdC52YWx1ZXModGhpcy5odWJEZXZpY2VzKS5maW5kKChkKSA9PiBkLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaENhbGxiYWNrcy5vbigoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBkZXZpY2Ugb24gcG9ydElkICR7ZGV2aWNlLnBvcnRJZH0gaXMgcmVhZHlgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVZpcnR1YWxQb3J0KHBvcnRJZDEsIHBvcnRJZDIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHNlbmRCdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcjIHNlbmRCdWZmZXInLCBidWZmZXIpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoYXJhYy53cml0ZVZhbHVlV2l0aG91dFJlc3BvbnNlKGJ1ZmZlcilcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdPSycpXG4gICAgICAgICAgICAvLyBpZiAoIXRoaXMuYnVzeSkge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuYnVzeSA9IHRydWVcbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLmNoYXJhYy53cml0ZVZhbHVlV2l0aG91dFJlc3BvbnNlKGJ1ZmZlcilcbiAgICAgICAgICAgIC8vICAgICB0aGlzLmJ1c3kgPSBmYWxzZVxuICAgICAgICAgICAgLy8gICAgIGlmICh0aGlzLmNtZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coJ3Byb2Nlc3MgcXVldWVkIGNtZCcpXG4gICAgICAgICAgICAvLyAgICAgICAgIGF3YWl0IHRoaXMuY2hhcmFjLndyaXRlVmFsdWVXaXRob3V0UmVzcG9uc2UodGhpcy5jbWRRdWV1ZS5zaGlmdCgpKVxuICAgICAgICAgICAgLy8gICAgIH1cblxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ2J1c3khIHB1c2ggaW4gcXVldWUnKVxuICAgICAgICAgICAgLy8gICAgIHRoaXMuY21kUXVldWUucHVzaChidWZmZXIpXG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ1R5cGVcbiAgICAgICAgICogQHBhcmFtICB7Li4uYW55fSBkYXRhIFxuICAgICAgICAgKi9cbiAgICAgICAgc2VuZE1zZyhtc2dUeXBlLCAuLi5kYXRhKSB7XG4gICAgICAgICAgICBsb2coJ3NlbmRNc2cnLCBNZXNzYWdlVHlwZU5hbWVzW21zZ1R5cGVdLCBkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEJ1ZmZlcihmb3JtYXRNc2cobXNnVHlwZSwgZGF0YSkpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UG9ydElkRnJvbU5hbWUobmFtZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmZvIG9mIE9iamVjdC52YWx1ZXModGhpcy5odWJEZXZpY2VzKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mby5wb3J0SWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZDFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZDJcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVZpcnR1YWxQb3J0KHBvcnRJZDEsIHBvcnRJZDIpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5WSVJUVUFMX1BPUlRfU0VUVVAsIDB4MDEsIHBvcnRJZDEsIHBvcnRJZDIpXG4gICAgICAgIH1cblxuICAgICAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX0FDVElPTlMsIDB4MDEpXG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldEh1YkRldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmh1YkRldmljZXMpXG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyByZWFkRGV2aWNlSW5mbygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHRoaXMuZ2V0SHViRGV2aWNlcygpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGV2aWNlLnJlYWRJbmZvKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldERldmljZShwb3J0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVUIuUG9ydEluZm9ybWF0aW9uPn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFBvcnRJbmZvcm1hdGlvbihwb3J0SWQpIHtcblxuICAgICAgICAgICAgY29uc3QgcG9ydEluZm8gPSBhd2FpdCB0aGlzLmdldFBvcnRJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkKVxuICAgICAgICAgICAgY29uc3QgeyBjb3VudCwgb3V0cHV0LCBpbnB1dCwgY2FwYWJpbGl0aWVzIH0gPSBwb3J0SW5mb1xuICAgICAgICAgICAgY29uc3QgbW9kZXMgPSBbXVxuICAgICAgICAgICAgZm9yIChsZXQgbW9kZSA9IDA7IG1vZGUgPCBjb3VudDsgbW9kZSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHt9XG4gICAgICAgICAgICAgICAgbGV0IHJldFxuICAgICAgICAgICAgICAgIGRhdGEubW9kZSA9IDBcbiAgICAgICAgICAgICAgICByZXQgPSBhd2FpdCB0aGlzLmdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgTW9kZUluZm9ybWF0aW9uVHlwZS5OQU1FKVxuICAgICAgICAgICAgICAgIGRhdGEubmFtZSA9IHJldC5uYW1lXG4gICAgICAgICAgICAgICAgcmV0ID0gYXdhaXQgdGhpcy5nZXRQb3J0TW9kZUluZm9ybWF0aW9uUmVxdWVzdChwb3J0SWQsIG1vZGUsIE1vZGVJbmZvcm1hdGlvblR5cGUuUkFXKVxuICAgICAgICAgICAgICAgIGRhdGFbcmV0LnR5cGVdID0geyBtaW46IHJldC5taW4sIG1heDogcmV0Lm1heCB9XG4gICAgICAgICAgICAgICAgcmV0ID0gYXdhaXQgdGhpcy5nZXRQb3J0TW9kZUluZm9ybWF0aW9uUmVxdWVzdChwb3J0SWQsIG1vZGUsIE1vZGVJbmZvcm1hdGlvblR5cGUuU0kpXG4gICAgICAgICAgICAgICAgZGF0YVtyZXQudHlwZV0gPSB7IG1pbjogcmV0Lm1pbiwgbWF4OiByZXQubWF4IH1cbiAgICAgICAgICAgICAgICByZXQgPSBhd2FpdCB0aGlzLmdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgTW9kZUluZm9ybWF0aW9uVHlwZS5TWU1CT0wpXG4gICAgICAgICAgICAgICAgZGF0YS51bml0ID0gcmV0LnN5bWJvbFxuICAgICAgICAgICAgICAgIHJldCA9IGF3YWl0IHRoaXMuZ2V0UG9ydE1vZGVJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkLCBtb2RlLCBNb2RlSW5mb3JtYXRpb25UeXBlLlZBTFVFX0ZPUk1BVClcbiAgICAgICAgICAgICAgICBjb25zdCB7IG51bVZhbHVlcywgZGF0YVR5cGUsIHRvdGFsRmlndXJlcywgZGVjaW1hbHMgfSA9IHJldFxuICAgICAgICAgICAgICAgIGRhdGFbcmV0LnR5cGVdID0geyBudW1WYWx1ZXMsIGRhdGFUeXBlLCB0b3RhbEZpZ3VyZXMsIGRlY2ltYWxzIH1cbiAgICAgICAgICAgICAgICBpZiAoKGlucHV0ID4+IG1vZGUpICYgMHgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubW9kZSB8PSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgob3V0cHV0ID4+IG1vZGUpICYgMHgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubW9kZSB8PSAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGVzLnB1c2goZGF0YSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgbW9kZXMsIGNhcGFiaWxpdGllcyB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldFBvcnRJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9JTkZPUk1BVElPTl9SRVFVRVNULCBwb3J0SWQsIDB4MDEpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0Q21kQ2FsbGJhY2tbcG9ydElkXSA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgZ2V0UG9ydE1vZGVJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkLCBtb2RlLCB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9NT0RFX0lORk9STUFUSU9OX1JFUVVFU1QsIHBvcnRJZCwgbW9kZSwgdHlwZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdID0gcmVzb2x2ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlTXNnKG1zZykge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gbXNnLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIGNvbnN0IG1zZ0xlbiA9IG1zZy5nZXRVaW50OCgwKVxuICAgICAgICAgICAgY29uc3QgbXNnVHlwZSA9IG1zZy5nZXRVaW50OCgyKVxuICAgICAgICAgICAgbG9nKCdkZWNvZGVNc2cnLCB7IG1zZ1R5cGU6IE1lc3NhZ2VUeXBlTmFtZXNbbXNnVHlwZV0gfSlcbiAgICAgICAgICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSFVCX0FUVEFDSEVEX0lPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRNc2cobXNnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkdFTkVSSUNfRVJST1JfTUVTU0FHRVM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlR2VuZXJpY0Vycm9yTXNnKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVIdWJQcm9wZXJ0eVJlc3BvbnNlKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkhVQl9BTEVSVFM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSHViQWxlcnRzKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QT1JUX09VVFBVVF9DT01NQU5EX0ZFRURCQUNLOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRDb21tYW5kRmVlZGJhY2sobXNnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBPUlRfTU9ERV9JTkZPUk1BVElPTjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb3J0TW9kZUluZm9ybWF0aW9uKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QT1JUX0lORk9STUFUSU9OOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRJbmZvcm1hdGlvbihtc2cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUE9SVF9WQUxVRV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9ydFZhbHVlU2luZ2xlKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICogXG4gICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9ydFZhbHVlU2luZ2xlKG1zZykge1xuICAgICAgICAgICAgLy9sb2coJ21zZycsIG1zZylcbiAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IG1zZy5nZXRVaW50OCgzKVxuICAgICAgICAgICAgY29uc3QgbXNnTGVuID0gbXNnLmdldFVpbnQ4KDApXG4gICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgbG9nKCdoYW5kbGVQb3J0VmFsdWVTaW5nbGUnLCB7IG1zZ0xlbiwgcG9ydElkIH0pXG4gICAgICAgICAgICBkZXZpY2UuaGFuZGxlVmFsdWUobXNnKVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvcnRNb2RlSW5mb3JtYXRpb24obXNnKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBtc2cuZ2V0VWludDgoNClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IHBvcnRJZCwgbW9kZSwgdHlwZTogTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzW3R5cGVdIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZUluZm9ybWF0aW9uVHlwZS5OQU1FOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLm5hbWUgPSBhYlRvU3RyaW5nKG1zZy5idWZmZXIuc2xpY2UoNiwgbXNnLmJ5dGVMZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZUluZm9ybWF0aW9uVHlwZS5SQVc6XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlSW5mb3JtYXRpb25UeXBlLlBDVDpcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVJbmZvcm1hdGlvblR5cGUuU0k6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWluID0gbXNnLmdldEZsb2F0MzIoNiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXggPSBtc2cuZ2V0RmxvYXQzMigxMCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVJbmZvcm1hdGlvblR5cGUuU1lNQk9MOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnN5bWJvbCA9IGFiVG9TdHJpbmcobXNnLmJ1ZmZlci5zbGljZSg2LCBtc2cuYnl0ZUxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlSW5mb3JtYXRpb25UeXBlLlZBTFVFX0ZPUk1BVDpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5udW1WYWx1ZXMgPSBtc2cuZ2V0VWludDgoNilcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhVHlwZSA9IFtcIjhiaXRcIiwgXCIxNmJpdFwiLCBcIjMyYml0XCIsIFwiZmxvYXRcIl1bbXNnLmdldFVpbnQ4KDcpXVxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRvdGFsRmlndXJlcyA9IG1zZy5nZXRVaW50OCg4KVxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRlY2ltYWxzID0gbXNnLmdldFVpbnQ4KDkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2coJ3BvcnRNb2RlSW5mb3JtYXRpb24nLCBkYXRhKVxuICAgICAgICAgICAgY29uc3QgY2IgPSB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYihkYXRhKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVQb3J0SW5mb3JtYXRpb24obXNnKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGxldCBjYXBhYmlsaXRpZXMgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gbXNnLmdldFVpbnQ4KDYpXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IG1zZy5nZXRVaW50MTYoNywgdHJ1ZSlcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG1zZy5nZXRVaW50MTYoOSwgdHJ1ZSlcbiAgICAgICAgICAgIGxvZyhgUG9ydCAke3BvcnRJZH0sIGNhcGFiaWxpdGllcyAke2NhcGFiaWxpdGllc30sIHRvdGFsIG1vZGVzICR7Y291bnR9LCBcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgbW9kZXMgJHtpbnB1dH0sIG91dHB1dCBtb2RlcyAke291dHB1dH1gKVxuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlQ2FwcyA9ICdvdXRwdXQsaW5wdXQsbG9naWNhbCBjb21iaW5hYmxlLCBsb2dpY2FsIHN5bmNocm9uaXNhYmxlJy5zcGxpdCgnLCcpXG4gICAgICAgICAgICBsZXQgY2FwID0gW11cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjYXBhYmlsaXRpZXMgPj4gaSkgJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcC5wdXNoKGF2YWlsYWJsZUNhcHNbaV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgcG9ydElkLCBjYXBhYmlsaXRpZXM6IGNhcC5qb2luKCcsICcpLCBjb3VudCwgaW5wdXQsIG91dHB1dCB9XG4gICAgICAgICAgICBjb25zdCBjYiA9IHRoaXMucG9ydENtZENhbGxiYWNrW3BvcnRJZF1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNiKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKiBAcmV0dXJucyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZUh1YlByb3BlcnR5UmVzcG9uc2UobXNnKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IG1zZy5nZXRVaW50OCgzKVxuICAgICAgICAgICAgbG9nKHsgcHJvcGVydHk6IEh1YlByb3BlcnR5UGF5bG9hZE5hbWVzW3Byb3BlcnR5XSB9KVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09IEh1YlByb3BlcnR5UGF5bG9hZC5CQVRURVJZX1ZPTFRBR0UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXR0ZXJ5TGV2ZWwgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgICAgICBsb2coeyBiYXR0ZXJ5TGV2ZWwgfSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2JhdHRlcnlMZXZlbCcsIHsgYmF0dGVyeUxldmVsIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PSBIdWJQcm9wZXJ0eVBheWxvYWQuQlVUVE9OX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uU3RhdGUgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgICAgICBsb2coeyBidXR0b25TdGF0ZSB9KVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYnV0dG9uU3RhdGUnLCB7IGJ1dHRvblN0YXRlIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PSBIdWJQcm9wZXJ0eVBheWxvYWQuU1lTVEVNX1RZUEVfSUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1UeXBlID0gbXNnLmdldFVpbnQ4KDUpXG4gICAgICAgICAgICAgICAgbG9nKHsgc3lzdGVtVHlwZSB9KVxuICAgICAgICAgICAgICAgIC8vdGhpcy5lbWl0KCdidXR0b25TdGF0ZScsIHsgYnV0dG9uU3RhdGUgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5ID09IEh1YlByb3BlcnR5UGF5bG9hZC5QUklNQVJZX01BQ19BRERSRVNTKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBbXVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2gobXNnLmdldFVpbnQ4KDUgKyBpKS50b1N0cmluZygxNikudG9Mb2NhbGVVcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2coeyBieXRlcyB9KVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYWRkcmVzcycsIHsgYWRkcmVzczogYnl0ZXMuam9pbignOicpIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVHZW5lcmljRXJyb3JNc2cobXNnKSB7XG4gICAgICAgICAgICBjb25zdCBjbWRUeXBlID0gbXNnLmdldFVpbnQ4KDMpXG4gICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBtc2cuZ2V0VWludDgoNClcbiAgICAgICAgICAgIGxvZyh7IGNtZFR5cGUsIGVycm9yQ29kZTogRXJyb3JDb2RlTmFtZXNbZXJyb3JDb2RlXSB9KVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHsgY21kVHlwZSwgZXJyb3JDb2RlOiBFcnJvckNvZGVOYW1lc1tlcnJvckNvZGVdIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZUh1YkFsZXJ0cyhtc2cpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbiA9IG1zZy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICBjb25zdCBtc2dMZW4gPSBtc2cuZ2V0VWludDgoMClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG1zZy5nZXRVaW50OCg0KVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1zZy5nZXRVaW50OCg1KVxuXG4gICAgICAgICAgICBsb2coJ2hhbmRsZUh1YkFsZXJ0cycsIHsgYnVmZmVyTGVuLCBtc2dMZW4sIHR5cGUsIG9wZXJhdGlvbiwgcGF5bG9hZCB9KVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdodWJBbGVydHMnLCB7IHR5cGUsIHBheWxvYWQgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9ydENvbW1hbmRGZWVkYmFjayhtc2cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDM7IG9mZnNldCA8IG1zZy5ieXRlTGVuZ3RoOyBvZmZzZXQgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IG1zZy5nZXRVaW50OChvZmZzZXQpXG4gICAgICAgICAgICAgICAgY29uc3QgZmVlZGJhY2sgPSBtc2cuZ2V0VWludDgob2Zmc2V0ICsgMSlcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjaGFuZGxlUG9ydENvbW1hbmRGZWVkYmFjaycsIHsgcG9ydElkLCBmZWVkYmFjayB9KVxuICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlLmhhbmRsZUZlZWRiYWNrKGZlZWRiYWNrKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucG9ydENtZFF1ZXVlLnNoaWZ0KClcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjIHByb2Nlc3MgcXVldWVkIGNtZCcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvcnRNc2cobXNnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IG1zZy5nZXRVaW50OCgzKVxuICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gbXNnLmdldFVpbnQ4KDQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZXZlbnRUeXBlID8gbXNnLmdldFVpbnQxNig1LCB0cnVlKSA6IDBcbiAgICAgICAgICAgIGNvbnN0IGRldmljZVR5cGVOYW1lID0gRGV2aWNlVHlwZU5hbWVzW3R5cGVdIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBFdmVudE5hbWVzW2V2ZW50VHlwZV1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhbmRsZVBvcnRNc2cnLCB7IHBvcnRJZCwgZXZlbnROYW1lLCBkZXZpY2VUeXBlTmFtZSB9KVxuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PSBFdmVudC5BVFRBQ0hFRF9JTykge1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3JNYXBbdHlwZV1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gRGV2aWNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IG5ldyBjb25zdHJ1Y3Rvcih0aGlzLCBwb3J0SWQsIGRldmljZVR5cGVOYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMuaHViRGV2aWNlc1twb3J0SWRdID0gZGV2aWNlXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDYWxsYmFja3MuZW1pdChkZXZpY2UpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2F0dGFjaCcsIGRldmljZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PSBFdmVudC5ERVRBQ0hFRF9JTykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGV0YWNoJywgeyBwb3J0SWQgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VHlwZSA9PSBFdmVudC5BVFRBQ0hFRF9WSVJUVUFMX0lPKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydElkMSA9IG1zZy5nZXRVaW50OCg3KVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZDIgPSBtc2cuZ2V0VWludDgoOClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IG5ldyBEb3VibGVNb3Rvcih0aGlzLCBwb3J0SWQsIGdldFZpcnR1YWxQb3J0TmFtZShwb3J0SWQxLCBwb3J0SWQyKSlcbiAgICAgICAgICAgICAgICB0aGlzLmh1YkRldmljZXNbcG9ydElkXSA9IGRldmljZVxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLmVtaXQoZGV2aWNlKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhdHRhY2gnLCBkZXZpY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkJC5zZXJ2aWNlLnJlZ2lzdGVyU2VydmljZSgnaHViJywge1xuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNNb3RvcihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlIGluc3RhbmNlb2YgTW90b3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNEb3VibGVNb3RvcihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlIGluc3RhbmNlb2YgRG91YmxlTW90b3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNMZWQoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZSBpbnN0YW5jZW9mIExlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIHtEZXZpY2V9IGRldmljZSBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1RhY2hvTW90b3IoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZSBpbnN0YW5jZW9mIFRhY2hvTW90b3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNDb2xvclNlbnNvcihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlIGluc3RhbmNlb2YgQ29sb3JTZW5zb3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNEaXN0YW5jZVNlbnNvcihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlIGluc3RhbmNlb2YgRGlzdGFuY2VTZW5zb3JcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEh1YkRldmljZT59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdjb25uZWN0JylcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdEFsbERldmljZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsU2VydmljZXM6IFtMUEYyX1NFUlZJQ0VfVVVJRF1cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaHViRGV2aWNlID0gbmV3IEh1YkRldmljZSgpXG4gICAgICAgICAgICAgICAgYXdhaXQgaHViRGV2aWNlLmluaXQoZGV2aWNlKVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGh1YkRldmljZVxuXG4gICAgICAgICAgICAgICAgLy9hd2FpdCBzZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9QUk9QRVJUSUVTLCBIdWJQcm9wZXJ0eVBheWxvYWQuQkFUVEVSWV9UWVBFLCAweDA1KVxuICAgICAgICAgICAgICAgIC8vYXdhaXQgc2VuZE1zZyhmb3JtYXRNc2coTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVMsIEh1YlByb3BlcnR5UGF5bG9hZC5CQVRURVJZX1ZPTFRBR0UsIDB4MDIpKVxuICAgICAgICAgICAgICAgIC8vYXdhaXQgc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUywgSHViUHJvcGVydHlQYXlsb2FkLkJVVFRPTl9TVEFURSwgMHgwMilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0LFxuICAgICAgICAgICAgICAgIENvbG9yLFxuICAgICAgICAgICAgICAgIFBvcnRNYXAsXG4gICAgICAgICAgICAgICAgUG9ydE1hcE5hbWVzLFxuICAgICAgICAgICAgICAgIERldmljZU1vZGUsXG4gICAgICAgICAgICAgICAgQnJha2luZ1N0eWxlLFxuICAgICAgICAgICAgICAgIERldmljZVR5cGVOYW1lcyxcbiAgICAgICAgICAgICAgICBpc01vdG9yLFxuICAgICAgICAgICAgICAgIGlzVGFjaG9Nb3RvcixcbiAgICAgICAgICAgICAgICBpc0xlZCxcbiAgICAgICAgICAgICAgICBpc0RvdWJsZU1vdG9yLFxuICAgICAgICAgICAgICAgIGlzQ29sb3JTZW5zb3IsXG4gICAgICAgICAgICAgICAgaXNEaXN0YW5jZVNlbnNvclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn0pKCk7XG5cblxuIl19"}