{"version":3,"sources":["../../../../node_modules/browser-pack/_prelude.js","lib/CallbackEmitter.js","lib/Const.js","lib/Device.js","lib/DoubleMotor.js","lib/Led.js","lib/Motor.js","lib/RgbLed.js","lib/TachoMotor.js","lib/TiltSensor.js","lib/Util.js","lib/hub.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hub.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","class CallbackEmitter {\n    constructor() {\n        this.callbacks = []\n    }\n\n    /**\n     * \n     * @param {(data) => boolean} callback \n     */\n    on(callback) {\n        this.callbacks.push(callback)\n    }\n\n    emit(data) {\n        console.log('emit', data)\n        let i = this.callbacks.length\n\n        while (i--) {\n            const callback = this.callbacks[i]\n            if (callback(data)) {\n                this.callbacks.splice(i, 1)\n            }\n        }\n    }\n}\n\nmodule.exports = CallbackEmitter","//@ts-check\n\nconst { getEnumName } = $$.util\n\nconst Event = {\n    DETACHED_IO: 0x00,\n    ATTACHED_IO: 0x01,\n    ATTACHED_VIRTUAL_IO: 0x02,\n}\nconst EventNames = getEnumName(Event)\n\nconst HubAlertType = {\n    LOW_VOLTAGE: 0x01,\n    HIGH_CURRENT: 0x02,\n    LOW_SIGNAL_STRENGTH: 0x03,\n    OVER_POWER_CONDITION: 0x04\n}\n\nconst MessageType = {\n    HUB_PROPERTIES: 0x01,\n    HUB_ACTIONS: 0x02,\n    HUB_ALERTS: 0x03,\n    HUB_ATTACHED_IO: 0x04,\n    GENERIC_ERROR_MESSAGES: 0x05,\n    HW_NETWORK_COMMANDS: 0x08,\n    FW_UPDATE_GO_INTO_BOOT_MODE: 0x10,\n    FW_UPDATE_LOCK_MEMORY: 0x11,\n    FW_UPDATE_LOCK_STATUS_REQUEST: 0x12,\n    FW_LOCK_STATUS: 0x13,\n    PORT_INFORMATION_REQUEST: 0x21,\n    PORT_MODE_INFORMATION_REQUEST: 0x22,\n    PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,\n    PORT_INPUT_FORMAT_SETUP_COMBINEDMODE: 0x42,\n    PORT_INFORMATION: 0x43,\n    PORT_MODE_INFORMATION: 0x44,\n    PORT_VALUE_SINGLE: 0x45,\n    PORT_VALUE_COMBINEDMODE: 0x46,\n    PORT_INPUT_FORMAT_SINGLE: 0x47,\n    PORT_INPUT_FORMAT_COMBINEDMODE: 0x48,\n    VIRTUAL_PORT_SETUP: 0x61,\n    PORT_OUTPUT_COMMAND: 0x81,\n    PORT_OUTPUT_COMMAND_FEEDBACK: 0x82,\n}\n\n\n\nconst MessageTypeNames = getEnumName(MessageType)\n\nconst DeviceType = {\n    UNKNOWN: 0,\n    SIMPLE_MEDIUM_LINEAR_MOTOR: 1,\n    TRAIN_MOTOR: 2,\n    LIGHT: 8,\n    VOLTAGE_SENSOR: 20,\n    CURRENT_SENSOR: 21,\n    PIEZO_BUZZER: 22,\n    HUB_LED: 23,\n    TILT_SENSOR: 34,\n    MOTION_SENSOR: 35,\n    COLOR_DISTANCE_SENSOR: 37,\n    MEDIUM_LINEAR_MOTOR: 38,\n    MOVE_HUB_MEDIUM_LINEAR_MOTOR: 39,\n    MOVE_HUB_TILT_SENSOR: 40,\n    DUPLO_TRAIN_BASE_MOTOR: 41,\n    DUPLO_TRAIN_BASE_SPEAKER: 42,\n    DUPLO_TRAIN_BASE_COLOR_SENSOR: 43,\n    DUPLO_TRAIN_BASE_SPEEDOMETER: 44,\n    TECHNIC_LARGE_LINEAR_MOTOR: 46, // Technic Control+\n    TECHNIC_XLARGE_LINEAR_MOTOR: 47, // Technic Control+\n    TECHNIC_MEDIUM_ANGULAR_MOTOR: 48, // Spike Prime\n    TECHNIC_LARGE_ANGULAR_MOTOR: 49, // Spike Prime\n    TECHNIC_MEDIUM_HUB_GEST_SENSOR: 54,\n    REMOTE_CONTROL_BUTTON: 55,\n    REMOTE_CONTROL_RSSI: 56,\n    TECHNIC_MEDIUM_HUB_ACCELEROMETER: 57,\n    TECHNIC_MEDIUM_HUB_GYRO_SENSOR: 58,\n    TECHNIC_MEDIUM_HUB_TILT_SENSOR: 59,\n    TECHNIC_MEDIUM_HUB_TEMPERATURE_SENSOR: 60,\n    TECHNIC_COLOR_SENSOR: 61, // Spike Prime\n    TECHNIC_DISTANCE_SENSOR: 62, // Spike Prime\n    TECHNIC_FORCE_SENSOR: 63, // Spike Prime\n    TECHNIC_3X3_COLOR_LIGHT_MATRIX: 64, // Spike Essential\n    TECHNIC_SMALL_ANGULAR_MOTOR: 65, // Spike Essential\n    MARIO_ACCELEROMETER: 71,\n    MARIO_BARCODE_SENSOR: 73,\n    MARIO_PANTS_SENSOR: 74,\n    TECHNIC_MEDIUM_ANGULAR_MOTOR_GREY: 75, // Mindstorms\n    TECHNIC_LARGE_ANGULAR_MOTOR_GREY: 76, // Technic Control+\n    VIRTUAL_DEVICE: 100\n}\n\nconst DeviceTypeNames = getEnumName(DeviceType)\n\nconst ErrorCode = {\n    ACK: 0x01,\n    MACK: 0x02,\n    BUFFER_OVERFLOW: 0x03,\n    TIMEOUT: 0x04,\n    COMMAND_NOT_RECOGNIZED: 0x05,\n    INVALID_USE: 0x06,\n    OVERCURRENT: 0x07,\n    INTERNAL_ERROR: 0x08,\n}\n\nconst ErrorCodeNames = getEnumName(ErrorCode)\n\n\nconst HubPropertyPayload = {\n    ADVERTISING_NAME: 0x01,\n    BUTTON_STATE: 0x02,\n    FW_VERSION: 0x03,\n    HW_VERSION: 0x04,\n    RSSI: 0x05,\n    BATTERY_VOLTAGE: 0x06,\n    BATTERY_TYPE: 0x07,\n    MANUFACTURER_NAME: 0x08,\n    RADIO_FIRMWARE_VERSION: 0x09,\n    LWP_PROTOCOL_VERSION: 0x0A,\n    SYSTEM_TYPE_ID: 0x0B,\n    HW_NETWORK_ID: 0x0C,\n    PRIMARY_MAC_ADDRESS: 0x0D,\n    SECONDARY_MAC_ADDRESS: 0x0E,\n    HW_NETWORK_FAMILY: 0x0F\n}\n\nconst HubPropertyPayloadNames = getEnumName(HubPropertyPayload)\n\nconst ModeInformationType = {\n    NAME: 0x00,\n    RAW: 0x01,\n    PCT: 0x02,\n    SI: 0x03,\n    SYMBOL: 0x04,\n    MAPPING: 0x05,\n    USED_INTERNALLY: 0x06,\n    MOTOR_BIAS: 0x07,\n    CAPABILITY_BITS: 0x08,\n    VALUE_FORMAT: 0x80,\n}\n\nconst ModeInformationTypeNames = getEnumName(ModeInformationType)\n\nconst PortMap = {\n    \"A\": 0,\n    \"B\": 1,\n    \"C\": 2,\n    \"D\": 3,\n    \"HUB_LED\": 50,\n    \"CURRENT_SENSOR\": 59,\n    \"VOLTAGE_SENSOR\": 60,\n    \"ACCELEROMETER\": 97,\n    \"GYRO_SENSOR\": 98,\n    \"TILT_SENSOR\": 99\n}\n\nconst DeviceMode = {\n    POWER: 0x00,\n    SPEED: 0x01,\n    ROTATION: 0x02,\n    ABSOLUTE: 0x03,\n    COLOR: 0x00,\n    RGB: 0x01,\n    TILT_POS: 0x00\n}\n\nconst BrakingStyle = {\n    FLOAT: 0,\n    HOLD: 126,\n    BRAKE: 127\n}\n\nconst PortMapNames = getEnumName(PortMap)\n\nmodule.exports = {\n    MessageType,\n    MessageTypeNames,\n    Event,\n    EventNames,\n    BrakingStyle,\n    DeviceMode,\n    DeviceType,\n    DeviceTypeNames,\n    ModeInformationType,\n    ModeInformationTypeNames,\n    PortMap,\n    PortMapNames,\n    HubPropertyPayload,\n    HubPropertyPayloadNames,\n    ErrorCodeNames\n}","//@ts-check\n\nconst CallbackEmitter = require('./CallbackEmitter')\nconst { MessageType, PortMapNames } = require('./Const')\nconst { log, toUint32 } = require('./Util')\n\nconst deviceInfo = {}\n\nclass Device {\n    /**\n     * \n     * @param {HUB.HubDevice} hubDevice \n     * @param {number} portId \n     * @param {string} type \n     */\n    constructor(hubDevice, portId, type) {\n        this.hubDevice = hubDevice\n        this.portId = portId\n        this.type = type\n        this.name = PortMapNames[portId]\n        this.feedbackCallback = null\n        this.valueCallback = undefined\n        this.mode = undefined\n        this.waitEnd = false\n        this.notificationEnabled = false\n\n    }\n\n    /**\n     * \n     * @param {boolean} waitEnd \n     * @param  {...any} data \n     * @returns \n     */\n    async writePortCommand(waitEnd, ...data) {\n        this.waitEnd = waitEnd\n        return new Promise(async (resolve) => {\n            this.feedbackCallback = resolve\n            await this.hubDevice.writePortCommand(this.portId, data)\n        })  \n\n    }\n\n    handleFeedback(feedback) {\n        if (typeof this.feedbackCallback == 'function') {\n            if (feedback == 1 && !this.waitEnd) {\n                this.feedbackCallback()\n            }\n            else if (feedback == 10 && this.waitEnd) {\n                this.feedbackCallback()\n            }\n            \n        }\n    }\n\n    /**\n     * \n     * @param {number} mode\n     * @param  {...any} data \n     * @returns \n     */\n    writeDirectMode(mode, ...data) {\n        log('writeDirectMode', this.portId, { mode })\n        return this.writePortCommand(true, 0x51, mode, data)\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @param {boolean} notificationEnabled \n     * @param {number} deltaInterval \n     * @returns \n     */\n    setMode(mode, notificationEnabled, deltaInterval = 1) {\n        console.log('setMode', this.portId, { mode, notificationEnabled })\n\n        this.mode = mode\n        this.notificationEnabled = notificationEnabled\n\n        return this.hubDevice.sendMsg(MessageType.PORT_INPUT_FORMAT_SETUP_SINGLE,\n            this.portId, mode, toUint32(deltaInterval), notificationEnabled ? 0x01 : 0)\n    }\n\n    async readInfo() {\n        let info = deviceInfo[this.type]\n        if (info == undefined) {\n            info = await this.hubDevice.getPortInformation(this.portId)\n            deviceInfo[this.type] = info\n        }\n        return info\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        const info = deviceInfo[this.type]\n        if (info != undefined) {\n            const { VALUE_FORMAT, RAW, SI } = info.modes[this.mode]\n            const range = $$.util.mapRange(RAW.min, RAW.max, SI.min, SI.max)\n            const { dataType, numValues } = VALUE_FORMAT\n            const ret = []\n            let offset = 4\n            let val\n            for (let idx = 0; idx < numValues; idx++) {\n                switch (dataType) {\n                    case '16bit':\n                        val = msg.getInt16(offset, true)\n                        offset += 2\n                        break;\n                    case '8bit':\n                        val = msg.getInt8(offset)\n                        offset += 1\n                        break;\n                    case '32bit':\n                        val = msg.getInt32(offset, true)\n                        offset += 4\n                        break;\n                    case 'float':\n                        val = msg.getFloat32(offset, true)\n                        offset += 4\n                        break;\n\n                }\n                log('val', val)\n                ret.push(Math.trunc(range(val)))\n            }\n            return ret\n\n        }\n    }\n    /**\n     * \n     * @param {DataView} msg \n     */\n    handleValue(msg) {\n        log('handleValue', this.portId, msg)\n        let value = this.decodeValue(msg)\n\n        if (value != undefined && typeof this.valueCallback == 'function') {\n            this.valueCallback(value)\n        }\n    }\n\n\n    /**\n     * \n     * @param {number} mode \n     * @returns \n    */\n    async getValue(mode) {\n        console.log('getValue', this.portId, { mode })\n\n        await this.setMode(mode, false)\n        return new Promise(async (resolve) => {\n            this.valueCallback = (data) => {\n                console.log('value', data)\n                resolve(data)\n                return true\n            }\n            await this.hubDevice.sendMsg(MessageType.PORT_INFORMATION_REQUEST, this.portId, 0x00)\n\n        })\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @param {(data) => Promise<boolean>} testFn \n     * @returns \n     */\n    async waitTestValue(mode, testFn) {\n        await this.setMode(mode, true)\n\n        await new Promise(async (resolve) => {\n            this.valueCallback = async (value) => {\n                log('waitTestValue', value)\n                const ret = await testFn(value)\n                if (ret) {\n                    log('waitTestValue OK')\n                    //await this.setMode(mode, false)\n                    resolve()\n                }\n            }\n\n        })\n        return this.setMode(mode, false)\n    }\n\n    async subscribe(mode, cbk, deltaInterval = 1) {\n        await this.setMode(mode, true, deltaInterval)\n        this.valueCallback = async (data) => {\n            await cbk(data)\n        }\n    }\n\n    async unsubscribe() {\n        if (this.notificationEnabled) {\n            this.setMode(this.mode, false)\n        }\n    }\n\n}\n\nmodule.exports = Device","//@ts-check\n\nconst Motor = require('./Motor')\nconst {BrakingStyle} = require('./Const')\nconst {toInt16, toInt32} = require('./Util')\n\nconst maxPower = 100\n\nclass DoubleMotor extends Motor {\n\n\n    constructor(hubDevice, portId, name) {\n        super(hubDevice, portId, 'Virtual Device')\n        this.name = name\n\n    }\n\n    /**\n     * \n     * @param {number} speed1 \n     * @param {number} speed2 \n     * @returns \n     */\n    setSpeed(speed1, speed2) {\n        return this.writePortCommand(false, 0x08, speed1, speed2, maxPower, 0)\n    }\n\n    setSpeedForTime(speed1, speed2, time, waitFeedback = false, brakingStyle = BrakingStyle.BRAKE) {\n\n        console.log('setSpeedForTime', this.portId, { speed1, speed2, time, waitFeedback, brakingStyle })\n        return this.writePortCommand(this.portId, waitFeedback, 0x0A, toInt16(time), speed1, speed2, maxPower, brakingStyle)\n    }\n\n    rotateDegrees(degrees, speed1, speed2, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('rotateDegrees', this.portId, { degrees, speed1, speed2, waitFeedback, brakingStyle })\n        return this.writePortCommand(waitFeedback, 0x0C, toInt32(degrees), speed1, speed2, maxPower, brakingStyle)\n    }\n\n    gotoAngle(angle1, angle2, speed, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('gotoAngle', this.portId, { angle1, angle2, speed, waitFeedback, brakingStyle })\n\n        return this.writePortCommand(waitFeedback, 0x0E, toInt32(angle1), toInt32(angle2), speed, maxPower, brakingStyle)\n    }\n}\n\nmodule.exports = DoubleMotor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass Led extends Device {\n\n    /**\n    * \n    * @param {HubDevice} hubDevice \n    * @param {number} portId \n    */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n\n    }\n\n    setBrightness(brightness) {\n        console.log('setBrightness', this.portId, { brightness })\n        return this.writeDirectMode(DeviceMode.POWER, brightness)\n    }\n\n\n}\n\nmodule.exports = Led","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nconst maxPower = 100\n\nclass Motor extends Device {\n\n    /**\n     * \n     * @param {HubDevice} hubDevice \n     * @param {number} portId \n     */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    setPower(power) {\n        console.log('setPower', this.portId, { power })\n        return this.writeDirectMode(DeviceMode.POWER, power)\n    }\n\n\n}\n\nmodule.exports = Motor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass RgbLed extends Device {\n\n    /**\n    * \n    * @param {HubDevice} hubDevice \n    * @param {number} portId \n    */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n\n    }\n\n    async setColor(color) {\n        console.log('setColor', this.portId, { color })\n        await this.setMode(DeviceMode.COLOR, false)\n        return this.writeDirectMode(DeviceMode.COLOR, color)\n    }\n\n    async setRGBColor(r, g, b) {\n        console.log('setColor', this.portId, { r, g, b })\n        await this.setMode(DeviceMode.RGB, false)\n        return this.writeDirectMode(DeviceMode.RGB, r, g, b)\n    }\n}\n\nmodule.exports = RgbLed","//@ts-check\n\nconst Motor = require('./Motor')\nconst {PortMapNames, DeviceMode, BrakingStyle} = require('./Const')\nconst {toInt32, toInt16} = require('./Util')\n\nconst maxPower = 100\n\nclass TachoMotor extends Motor {\n\n    /**\n     * \n     * @param {HubDevice} hubDevice \n     * @param {number} portId \n     */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    setSpeed(speed) {\n        console.log('#setSpeed', this.portId, { speed })\n        if (speed == 0) {\n            return this.setPower(0)\n        }\n        return this.writePortCommand(true, 0x07, speed, maxPower, 0)\n    }\n\n    rotateDegrees(degrees, speed, waitEnd, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('rotateDegrees', this.portId, { degrees, speed, waitEnd, brakingStyle })\n        return this.writePortCommand(waitEnd, 0x0B, toInt32(degrees), speed, maxPower, brakingStyle)\n    }\n\n    /**\n     * \n     * @param {number} angle \n     * @param {number} speed \n     * @param {boolean} waitEnd \n     * @param {number} brakingStyle \n     * @returns \n     */\n    gotoAngle(angle, speed, waitEnd, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('gotoAngle', this.portId, { angle, speed, waitEnd, brakingStyle })\n\n        if (this.calibrationValue) {\n            angle *= this.calibrationValue\n        }\n\n        return this.writePortCommand(waitEnd, 0x0D, toInt32(angle), speed, maxPower, brakingStyle)\n    }\n\n    setSpeedForTime(speed, time, waitEnd = false, brakingStyle = BrakingStyle.BRAKE) {\n\n        console.log('setSpeedForTime', this.portId, { speed, time, waitEnd, brakingStyle })\n        return this.writePortCommand(waitEnd, 0x09, toInt16(time), speed, maxPower, brakingStyle)\n    }\n\n    resetZero() {\n        console.log('resetZero', this.portId)\n        return this.writeDirectMode(DeviceMode.ROTATION, 0x00, 0x00, 0x00, 0x00)\n    }\n\n    getSpeed() {\n        return this.getValue(DeviceMode.SPEED)\n    }\n\n    getPosition() {\n        return this.getValue(DeviceMode.ROTATION)\n    }\n\n    getAbsolutePosition() {\n        return this.getValue(DeviceMode.ABSOLUTE)\n    }\n\n    async calibrate() {\n\n        console.log('calibrate', this.portId)\n        this.setPower(50)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value > 10)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value == 0)\n\n\n        this.setPower(0)\n\n        await $$.util.wait(1000)\n\n        // await this.hubDevice.setPortFormat(this.portId, DeviceMode.ROTATION)\n        // let value = await this.hubDevice.getPortValue(this.portId)\n        // console.log(value)\t\n\n        await this.resetZero()\n\n\n        this.setPower(-50)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => Math.abs(value) > 10)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value == 0)\n\n        this.setPower(0)\n        const value = await this.getValue(DeviceMode.ROTATION)\n        console.log(value)\n        const offset = Math.floor(value / 2)\n        console.log({ offset })\n        await this.gotoAngle(offset, 10, true)\n        await this.resetZero()\n        this.calibrationValue = Math.abs(offset)\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        let value\n        switch (this.mode) {\n            case DeviceMode.ABSOLUTE:\n                value = msg.getInt16(4, true)\n                break\n            case DeviceMode.ROTATION:\n                value = msg.getInt32(4, true)\n                break\n            case DeviceMode.SPEED:\n                value = msg.getInt8(4)\n                break\n\n        }\n        return value\n    }\n\n}\n\nmodule.exports = TachoMotor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass TiltSensor extends Device {\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        let value\n        switch (this.mode) {\n            case DeviceMode.TILT_POS:\n                value = {\n                    yaw: msg.getInt16(4, true),\n                    pitch: msg.getInt16(6, true),\n                    roll: msg.getInt16(8, true)\n                }\n                break\n            default:\n                value = super.decodeValue(msg)\n                break\n        }\n        return value\n    }\n}\n\nmodule.exports = TiltSensor\n","//@ts-check\n\n/**\n  * \n  * @param {number} val \n  * @returns {Array}\n  */\nfunction toInt16(val) {\n    const buff = new Uint8Array(2)\n    const view = new DataView(buff.buffer)\n    view.setInt16(0, val, true)\n    return Array.from(buff)\n}\n\n/**\n * \n * @param {number} val \n * @returns {Array}\n */\nfunction toInt32(val) {\n    const buff = new Uint8Array(4)\n    const view = new DataView(buff.buffer)\n    view.setInt32(0, val, true)\n    return Array.from(buff)\n}\n\nfunction toUint32(val) {\n    const buff = new Uint8Array(4)\n    const view = new DataView(buff.buffer)\n    view.setUint32(0, val, true)\n    return Array.from(buff)\n}\n\nconst debug = false\n\nconst log = function (...data) {\n    if (debug) {\n        console.log.apply(console, data)\n    }\n}\n\nmodule.exports = {\n    toInt16,\n    toInt32,\n    toUint32,\n    log\n}","//@ts-check\n\n\n(function () {\n\n    const CallbackEmitter = require('./CallbackEmitter')\n    const { EventNames, DeviceMode, DeviceTypeNames, BrakingStyle, PortMap, HubPropertyPayloadNames, ModeInformationTypeNames, Event, DeviceType, PortMapNames, MessageType, HubPropertyPayload, ModeInformationType, ErrorCodeNames, MessageTypeNames } = require('./Const')\n    const Motor = require('./Motor')\n    const DoubleMotor = require('./DoubleMotor')\n    const TachoMotor = require('./TachoMotor');\n    const Device = require('./Device')\n    const RgbLed = require('./RgbLed')\n    const Led = require('./Led')\n    const TiltSensor = require('./TiltSensor')\n    const { log } = require('./Util')\n\n    const Color = {\n        BLACK: 0,\n        PINK: 1,\n        PURPLE: 2,\n        BLUE: 3,\n        LIGHT_BLUE: 4,\n        CYAN: 5,\n        GREEN: 6,\n        YELLOW: 7,\n        ORANGE: 8,\n        RED: 9,\n        WHITE: 10,\n        NONE: 255\n    }\n\n    const LPF2_SERVICE_UUID = '00001623-1212-efde-1623-785feabcd123'\n    const LPF2_CHARAC_UUID = '00001624-1212-efde-1623-785feabcd123'\n\n\n    /**\n     * \n     * @param {ArrayBuffer} buf \n     */\n    function abToString(buf) {\n        const uint8buff = new Uint8Array(buf)\n        let ret = \"\"\n        for (let i = 0; i < uint8buff.byteLength && uint8buff[i] != 0; i++) {\n            ret += String.fromCharCode(uint8buff[i])\n        }\n        return ret\n    }\n\n\n    /**\n     * \n     * @param  {...any} data \n     * @returns {ArrayBuffer}\n     */\n    function formatMsg(msgType, ...data) {\n        const buff = data.flat(4)\n        const msgLen = buff.length + 3\n        const buffer = new ArrayBuffer(msgLen)\n        const uint8Buffer = new Uint8Array(buffer)\n        uint8Buffer[0] = msgLen\n        uint8Buffer[1] = 0\n        uint8Buffer[2] = msgType\n        uint8Buffer.set(buff, 3)\n        return buffer\n    }\n\n\n    function getVirtualPortName(portId1, portId2) {\n        const portIdA = PortMapNames[portId1]\n        const portIdB = PortMapNames[portId2]\n        return `${portIdA}_${portIdB}`\n    }\n\n    const constructorMap = {\n        [DeviceType.TECHNIC_LARGE_LINEAR_MOTOR]: TachoMotor,\n        [DeviceType.TECHNIC_LARGE_ANGULAR_MOTOR_GREY]: TachoMotor,\n        [DeviceType.TECHNIC_XLARGE_LINEAR_MOTOR]: TachoMotor,\n        [DeviceType.TECHNIC_MEDIUM_HUB_TILT_SENSOR]: TiltSensor,\n        [DeviceType.HUB_LED]: RgbLed,\n        [DeviceType.LIGHT]: Led\n    }\n\n    /**@implements HUB.HubDevice */\n    class HubDevice extends EventEmitter2 {\n\n        constructor() {\n            super()\n            this.charac = null\n            this.portCmdQueue = {}\n            this.portCmdCallback = {}\n            /**@type {{[portId: string]: Device}} */\n            this.hubDevices = {}\n            this.busy = false\n            this.attachCallbacks = new CallbackEmitter()\n            this.portCmdQueue = []\n\n        }\n\n        async writePortCommand(portId, ...data) {\n\n            console.log('#writePortCommand', { portId, data })\n\n            const buffer = formatMsg(MessageType.PORT_OUTPUT_COMMAND, portId, 0x11, data)\n\n            if (!this.busy)  {\n                this.busy = true\n                await this.sendBuffer(buffer)\n            }\n            else {\n                this.portCmdQueue.push(buffer)\n                console.log('# Busy ! wait feedback')\n                \n            }\n\n        }\n\n\n\n        /**\n         * \n         * @param {BluetoothDevice} device \n         */\n        async init(device) {\n\n            const server = await device.gatt.connect()\n            log('Connected')\n            const service = await server.getPrimaryService(LPF2_SERVICE_UUID)\n            this.charac = await service.getCharacteristic(LPF2_CHARAC_UUID)\n\n            const onCharacteristicvaluechanged = (event) => {\n                this.decodeMsg(event.target.value)\n            }\n\n            device.addEventListener('gattserverdisconnected', () => {\n                console.log('onGattServerDisconnected', this)\n                this.charac.removeEventListener('characteristicvaluechanged', onCharacteristicvaluechanged)\n\n                this.charac = null\n                this.emit('disconnected')\n            })\n\n            this.charac.addEventListener('characteristicvaluechanged', onCharacteristicvaluechanged)\n            await this.charac.startNotifications()\n            await $$.util.wait(100)\n        }\n\n        async startNotification() {\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_VOLTAGE, 0x02)\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.SYSTEM_TYPE_ID, 0x05)\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.PRIMARY_MAC_ADDRESS, 0x05)\n            await this.sendMsg(MessageType.HUB_ALERTS, 0x01, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x02, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x03, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x04, 0x01)\n\n        }\n\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<Motor>}\n         */\n        getMotor(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof Motor) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<Motor>}\n         */\n        getTachoMotor(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof TachoMotor) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n\n\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<TiltSensor>}\n         */\n        getTiltSensor(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof TiltSensor) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n\n        }\n\n        getRgbLed(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof RgbLed) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n\n        getLed(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof Led) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n        async getDblMotor(portId1, portId2) {\n            return new Promise(async (resolve) => {\n                const name = getVirtualPortName(portId1, portId2)\n                const device = Object.values(this.hubDevices).find((d) => d.name == name)\n                if (device) {\n                    resolve(device)\n\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.name == name) {\n                            console.log(`device on portId ${device.portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n\n                    await this.createVirtualPort(portId1, portId2)\n                }\n            })\n        }\n\n        /**\n         * \n         * @param  {ArrayBuffer} buffer \n         */\n        async sendBuffer(buffer) {\n            console.log('# sendBuffer', buffer)\n            await this.charac.writeValueWithoutResponse(buffer)\n            // console.log('OK')\n            // if (!this.busy) {\n            //     this.busy = true\n            //     await this.charac.writeValueWithoutResponse(buffer)\n            //     this.busy = false\n            //     if (this.cmdQueue.length > 0) {\n            //         console.log('process queued cmd')\n            //         await this.charac.writeValueWithoutResponse(this.cmdQueue.shift())\n            //     }\n\n            // }\n            // else {\n            //     console.log('busy! push in queue')\n            //     this.cmdQueue.push(buffer)\n            // }\n\n        }\n\n        /**\n         * \n         * @param {number} msgType\n         * @param  {...any} data \n         */\n        sendMsg(msgType, ...data) {\n            log('sendMsg', MessageTypeNames[msgType], data)\n            return this.sendBuffer(formatMsg(msgType, data))\n        }\n\n        /**\n         * \n         * @param {string} name \n         * @returns {number}\n         */\n        getPortIdFromName(name) {\n            for (const info of Object.values(this.hubDevices)) {\n                if (info.name == name) {\n                    return info.portId\n                }\n            }\n        }\n\n        /**\n         * @param {number} portId1\n         * @param {number} portId2\n         */\n        createVirtualPort(portId1, portId2) {\n\n            return this.sendMsg(MessageType.VIRTUAL_PORT_SETUP, 0x01, portId1, portId2)\n        }\n\n        shutdown() {\n            return this.sendMsg(MessageType.HUB_ACTIONS, 0x01)\n        }\n\n\n        getHubDevices() {\n            return Object.values(this.hubDevices)\n        }\n\n        async readDeviceInfo() {\n            for (const device of this.getHubDevices()) {\n                await device.readInfo()\n            }\n        }\n\n        getDevice(portId) {\n            return this.hubDevices[portId]\n        }\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<HUB.PortInformation>}\n         */\n        async getPortInformation(portId) {\n\n            const portInfo = await this.getPortInformationRequest(portId)\n            const { count, output, input, capabilities } = portInfo\n            const modes = []\n            for (let mode = 0; mode < count; mode++) {\n                const data = {}\n                let ret\n                data.mode = 0\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.NAME)\n                data.name = ret.name\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.RAW)\n                data[ret.type] = { min: ret.min, max: ret.max }\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.SI)\n                data[ret.type] = { min: ret.min, max: ret.max }\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.SYMBOL)\n                data.unit = ret.symbol\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.VALUE_FORMAT)\n                const { numValues, dataType, totalFigures, decimals } = ret\n                data[ret.type] = { numValues, dataType, totalFigures, decimals }\n                if ((input >> mode) & 0x1) {\n                    data.mode |= 1\n                }\n                if ((output >> mode) & 0x1) {\n                    data.mode |= 2\n                }\n                modes.push(data)\n            }\n\n            return { modes, capabilities }\n        }\n\n\n        getPortInformationRequest(portId) {\n            return new Promise(async (resolve) => {\n                await this.sendMsg(MessageType.PORT_INFORMATION_REQUEST, portId, 0x01)\n                this.portCmdCallback[portId] = resolve\n            })\n        }\n\n\n\n        getPortModeInformationRequest(portId, mode, type) {\n            return new Promise(async (resolve) => {\n                await this.sendMsg(MessageType.PORT_MODE_INFORMATION_REQUEST, portId, mode, type)\n                this.portCmdCallback[portId] = resolve\n            })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        decodeMsg(msg) {\n            const bufferLen = msg.byteLength\n            const msgLen = msg.getUint8(0)\n            const msgType = msg.getUint8(2)\n            log('decodeMsg', { msgType: MessageTypeNames[msgType] })\n            switch (msgType) {\n                case MessageType.HUB_ATTACHED_IO:\n                    this.handlePortMsg(msg)\n                    break;\n                case MessageType.GENERIC_ERROR_MESSAGES:\n                    this.handleGenericErrorMsg(msg)\n                    break;\n                case MessageType.HUB_PROPERTIES:\n                    this.handleHubPropertyResponse(msg)\n                    break\n                case MessageType.HUB_ALERTS:\n                    this.handleHubAlerts(msg);\n                    break\n                case MessageType.PORT_OUTPUT_COMMAND_FEEDBACK:\n                    this.handlePortCommandFeedback(msg)\n                    break;\n                case MessageType.PORT_MODE_INFORMATION:\n                    this.handlePortModeInformation(msg)\n                    break;\n                case MessageType.PORT_INFORMATION:\n                    this.handlePortInformation(msg)\n                    break;\n                case MessageType.PORT_VALUE_SINGLE:\n                    this.handlePortValueSingle(msg)\n                    break;\n            }\n        }\n\n\n        /**\n          * \n          * @param {DataView} msg \n          */\n        handlePortValueSingle(msg) {\n            //log('msg', msg)\n            const portId = msg.getUint8(3)\n            const msgLen = msg.getUint8(0)\n            const device = this.hubDevices[portId]\n            log('handlePortValueSingle', { msgLen, portId })\n            device.handleValue(msg)\n        }\n\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortModeInformation(msg) {\n            const portId = msg.getUint8(3)\n            const mode = msg.getUint8(4)\n            const type = msg.getUint8(5)\n            const data = { portId, mode, type: ModeInformationTypeNames[type] }\n            switch (type) {\n                case ModeInformationType.NAME:\n                    data.name = abToString(msg.buffer.slice(6, msg.byteLength))\n                    break\n                case ModeInformationType.RAW:\n                case ModeInformationType.PCT:\n                case ModeInformationType.SI:\n                    data.min = msg.getFloat32(6, true)\n                    data.max = msg.getFloat32(10, true)\n                    break\n                case ModeInformationType.SYMBOL:\n                    data.symbol = abToString(msg.buffer.slice(6, msg.byteLength))\n                    break\n                case ModeInformationType.VALUE_FORMAT:\n                    data.numValues = msg.getUint8(6)\n                    data.dataType = [\"8bit\", \"16bit\", \"32bit\", \"float\"][msg.getUint8(7)]\n                    data.totalFigures = msg.getUint8(8)\n                    data.decimals = msg.getUint8(9)\n                    break\n            }\n            log('portModeInformation', data)\n            const cb = this.portCmdCallback[portId]\n            if (typeof cb == 'function') {\n                cb(data)\n                delete this.portCmdCallback[portId]\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortInformation(msg) {\n            const portId = msg.getUint8(3)\n            let capabilities = msg.getUint8(5)\n            const count = msg.getUint8(6)\n            const input = msg.getUint16(7, true)\n            const output = msg.getUint16(9, true)\n            log(`Port ${portId}, capabilities ${capabilities}, total modes ${count}, \n                    input modes ${input}, output modes ${output}`)\n            const availableCaps = 'output,input,logical combinable, logical synchronisable'.split(',')\n            let cap = []\n            for (let i = 0; i < 4; i++) {\n                if ((capabilities >> i) & 1) {\n                    cap.push(availableCaps[i])\n                }\n            }\n            const data = { portId, capabilities: cap.join(', '), count, input, output }\n            const cb = this.portCmdCallback[portId]\n            if (typeof cb == 'function') {\n                cb(data)\n            }\n        }\n\n\n        /**\n         * \n         * @param {DataView} msg \n         * @returns \n         */\n        handleHubPropertyResponse(msg) {\n            const property = msg.getUint8(3)\n            log({ property: HubPropertyPayloadNames[property] })\n            if (property == HubPropertyPayload.BATTERY_VOLTAGE) {\n                const batteryLevel = msg.getUint8(5)\n                log({ batteryLevel })\n                this.emit('batteryLevel', { batteryLevel })\n            }\n            else if (property == HubPropertyPayload.BUTTON_STATE) {\n                const buttonState = msg.getUint8(5)\n                log({ buttonState })\n                this.emit('buttonState', { buttonState })\n            }\n            else if (property == HubPropertyPayload.SYSTEM_TYPE_ID) {\n                const systemType = msg.getUint8(5)\n                log({ systemType })\n                //this.emit('buttonState', { buttonState })\n            }\n            else if (property == HubPropertyPayload.PRIMARY_MAC_ADDRESS) {\n                const bytes = []\n                for (let i = 0; i < 6; i++) {\n                    bytes.push(msg.getUint8(5 + i).toString(16).toLocaleUpperCase().padStart(2, '0'))\n                }\n                log({ bytes })\n                this.emit('address', { address: bytes.join(':') })\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handleGenericErrorMsg(msg) {\n            const cmdType = msg.getUint8(3)\n            const errorCode = msg.getUint8(4)\n            log({ cmdType, errorCode: ErrorCodeNames[errorCode] })\n            this.emit('error', { cmdType, errorCode: ErrorCodeNames[errorCode] })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handleHubAlerts(msg) {\n            const bufferLen = msg.byteLength\n            const msgLen = msg.getUint8(0)\n            const type = msg.getUint8(3)\n            const operation = msg.getUint8(4)\n            const payload = msg.getUint8(5)\n\n            log('handleHubAlerts', { bufferLen, msgLen, type, operation, payload })\n            this.emit('hubAlerts', { type, payload })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortCommandFeedback(msg) {\n            for (let offset = 3; offset < msg.byteLength; offset += 2) {\n                const portId = msg.getUint8(offset)\n                const feedback = msg.getUint8(offset + 1)\n                const device = this.hubDevices[portId]\n                console.log('#handlePortCommandFeedback', { portId, feedback })\n                this.busy = false\n                if (device != undefined) {\n                    device.handleFeedback(feedback)\n                }\n                \n                const buffer = this.portCmdQueue.shift()\n                if (buffer) {\n                    console.log('# process queued cmd')\n                    this.busy = true\n                    this.sendBuffer(buffer)\n                }\n\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortMsg(msg) {\n\n            const portId = msg.getUint8(3)\n            const eventType = msg.getUint8(4)\n            const type = eventType ? msg.getUint16(5, true) : 0\n            const deviceTypeName = DeviceTypeNames[type] || \"Unknown\"\n            const eventName = EventNames[eventType]\n\n            console.log('handlePortMsg', { portId, eventName, deviceTypeName })\n            if (eventType == Event.ATTACHED_IO) {\n\n                let constructor = constructorMap[type]\n                if (!constructor) {\n                    constructor = Device\n                }\n                const device = new constructor(this, portId, deviceTypeName)\n                this.hubDevices[portId] = device\n                this.attachCallbacks.emit(device)\n\n                this.emit('attach', device)\n            }\n            else if (eventType == Event.DETACHED_IO) {\n                delete this.hubDevices[portId]\n                this.emit('detach', { portId })\n            }\n            else if (eventType == Event.ATTACHED_VIRTUAL_IO) {\n                const portId1 = msg.getUint8(7)\n                const portId2 = msg.getUint8(8)\n\n                const device = new DoubleMotor(this, portId, getVirtualPortName(portId1, portId2))\n                this.hubDevices[portId] = device\n                this.attachCallbacks.emit(device)\n\n                this.emit('attach', device)\n            }\n        }\n    }\n\n    $$.service.registerService('hub', {\n\n        init: function () {\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isMotor(device) {\n                return device instanceof Motor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isDoubleMotor(device) {\n                return device instanceof DoubleMotor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isLed(device) {\n                return device instanceof Led\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isTachoMotor(device) {\n                return device instanceof TachoMotor\n            }\n\n\n            /**\n             * \n             * @returns {Promise<HubDevice>}\n             */\n            async function connect() {\n                log('connect')\n\n                const device = await navigator.bluetooth.requestDevice({\n                    acceptAllDevices: true,\n                    optionalServices: [LPF2_SERVICE_UUID]\n                })\n\n                const hubDevice = new HubDevice()\n                await hubDevice.init(device)\n\n                return hubDevice\n\n                //await sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_TYPE, 0x05)\n                //await sendMsg(formatMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_VOLTAGE, 0x02))\n                //await sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BUTTON_STATE, 0x02)\n            }\n\n            return {\n                connect,\n                Color,\n                PortMap,\n                PortMapNames,\n                DeviceMode,\n                BrakingStyle,\n                DeviceTypeNames,\n                isMotor,\n                isTachoMotor,\n                isLed,\n                isDoubleMotor\n            }\n        }\n    });\n\n})();\n\n\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvQ2FsbGJhY2tFbWl0dGVyLmpzIiwibGliL0NvbnN0LmpzIiwibGliL0RldmljZS5qcyIsImxpYi9Eb3VibGVNb3Rvci5qcyIsImxpYi9MZWQuanMiLCJsaWIvTW90b3IuanMiLCJsaWIvUmdiTGVkLmpzIiwibGliL1RhY2hvTW90b3IuanMiLCJsaWIvVGlsdFNlbnNvci5qcyIsImxpYi9VdGlsLmpzIiwibGliL2h1Yi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImNsYXNzIENhbGxiYWNrRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyhkYXRhKSA9PiBib29sZWFufSBjYWxsYmFjayBcbiAgICAgKi9cbiAgICBvbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZW1pdCcsIGRhdGEpXG4gICAgICAgIGxldCBpID0gdGhpcy5jYWxsYmFja3MubGVuZ3RoXG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tpXVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Muc3BsaWNlKGksIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tFbWl0dGVyIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgeyBnZXRFbnVtTmFtZSB9ID0gJCQudXRpbFxuXG5jb25zdCBFdmVudCA9IHtcbiAgICBERVRBQ0hFRF9JTzogMHgwMCxcbiAgICBBVFRBQ0hFRF9JTzogMHgwMSxcbiAgICBBVFRBQ0hFRF9WSVJUVUFMX0lPOiAweDAyLFxufVxuY29uc3QgRXZlbnROYW1lcyA9IGdldEVudW1OYW1lKEV2ZW50KVxuXG5jb25zdCBIdWJBbGVydFR5cGUgPSB7XG4gICAgTE9XX1ZPTFRBR0U6IDB4MDEsXG4gICAgSElHSF9DVVJSRU5UOiAweDAyLFxuICAgIExPV19TSUdOQUxfU1RSRU5HVEg6IDB4MDMsXG4gICAgT1ZFUl9QT1dFUl9DT05ESVRJT046IDB4MDRcbn1cblxuY29uc3QgTWVzc2FnZVR5cGUgPSB7XG4gICAgSFVCX1BST1BFUlRJRVM6IDB4MDEsXG4gICAgSFVCX0FDVElPTlM6IDB4MDIsXG4gICAgSFVCX0FMRVJUUzogMHgwMyxcbiAgICBIVUJfQVRUQUNIRURfSU86IDB4MDQsXG4gICAgR0VORVJJQ19FUlJPUl9NRVNTQUdFUzogMHgwNSxcbiAgICBIV19ORVRXT1JLX0NPTU1BTkRTOiAweDA4LFxuICAgIEZXX1VQREFURV9HT19JTlRPX0JPT1RfTU9ERTogMHgxMCxcbiAgICBGV19VUERBVEVfTE9DS19NRU1PUlk6IDB4MTEsXG4gICAgRldfVVBEQVRFX0xPQ0tfU1RBVFVTX1JFUVVFU1Q6IDB4MTIsXG4gICAgRldfTE9DS19TVEFUVVM6IDB4MTMsXG4gICAgUE9SVF9JTkZPUk1BVElPTl9SRVFVRVNUOiAweDIxLFxuICAgIFBPUlRfTU9ERV9JTkZPUk1BVElPTl9SRVFVRVNUOiAweDIyLFxuICAgIFBPUlRfSU5QVVRfRk9STUFUX1NFVFVQX1NJTkdMRTogMHg0MSxcbiAgICBQT1JUX0lOUFVUX0ZPUk1BVF9TRVRVUF9DT01CSU5FRE1PREU6IDB4NDIsXG4gICAgUE9SVF9JTkZPUk1BVElPTjogMHg0MyxcbiAgICBQT1JUX01PREVfSU5GT1JNQVRJT046IDB4NDQsXG4gICAgUE9SVF9WQUxVRV9TSU5HTEU6IDB4NDUsXG4gICAgUE9SVF9WQUxVRV9DT01CSU5FRE1PREU6IDB4NDYsXG4gICAgUE9SVF9JTlBVVF9GT1JNQVRfU0lOR0xFOiAweDQ3LFxuICAgIFBPUlRfSU5QVVRfRk9STUFUX0NPTUJJTkVETU9ERTogMHg0OCxcbiAgICBWSVJUVUFMX1BPUlRfU0VUVVA6IDB4NjEsXG4gICAgUE9SVF9PVVRQVVRfQ09NTUFORDogMHg4MSxcbiAgICBQT1JUX09VVFBVVF9DT01NQU5EX0ZFRURCQUNLOiAweDgyLFxufVxuXG5cblxuY29uc3QgTWVzc2FnZVR5cGVOYW1lcyA9IGdldEVudW1OYW1lKE1lc3NhZ2VUeXBlKVxuXG5jb25zdCBEZXZpY2VUeXBlID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgU0lNUExFX01FRElVTV9MSU5FQVJfTU9UT1I6IDEsXG4gICAgVFJBSU5fTU9UT1I6IDIsXG4gICAgTElHSFQ6IDgsXG4gICAgVk9MVEFHRV9TRU5TT1I6IDIwLFxuICAgIENVUlJFTlRfU0VOU09SOiAyMSxcbiAgICBQSUVaT19CVVpaRVI6IDIyLFxuICAgIEhVQl9MRUQ6IDIzLFxuICAgIFRJTFRfU0VOU09SOiAzNCxcbiAgICBNT1RJT05fU0VOU09SOiAzNSxcbiAgICBDT0xPUl9ESVNUQU5DRV9TRU5TT1I6IDM3LFxuICAgIE1FRElVTV9MSU5FQVJfTU9UT1I6IDM4LFxuICAgIE1PVkVfSFVCX01FRElVTV9MSU5FQVJfTU9UT1I6IDM5LFxuICAgIE1PVkVfSFVCX1RJTFRfU0VOU09SOiA0MCxcbiAgICBEVVBMT19UUkFJTl9CQVNFX01PVE9SOiA0MSxcbiAgICBEVVBMT19UUkFJTl9CQVNFX1NQRUFLRVI6IDQyLFxuICAgIERVUExPX1RSQUlOX0JBU0VfQ09MT1JfU0VOU09SOiA0MyxcbiAgICBEVVBMT19UUkFJTl9CQVNFX1NQRUVET01FVEVSOiA0NCxcbiAgICBURUNITklDX0xBUkdFX0xJTkVBUl9NT1RPUjogNDYsIC8vIFRlY2huaWMgQ29udHJvbCtcbiAgICBURUNITklDX1hMQVJHRV9MSU5FQVJfTU9UT1I6IDQ3LCAvLyBUZWNobmljIENvbnRyb2wrXG4gICAgVEVDSE5JQ19NRURJVU1fQU5HVUxBUl9NT1RPUjogNDgsIC8vIFNwaWtlIFByaW1lXG4gICAgVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SOiA0OSwgLy8gU3Bpa2UgUHJpbWVcbiAgICBURUNITklDX01FRElVTV9IVUJfR0VTVF9TRU5TT1I6IDU0LFxuICAgIFJFTU9URV9DT05UUk9MX0JVVFRPTjogNTUsXG4gICAgUkVNT1RFX0NPTlRST0xfUlNTSTogNTYsXG4gICAgVEVDSE5JQ19NRURJVU1fSFVCX0FDQ0VMRVJPTUVURVI6IDU3LFxuICAgIFRFQ0hOSUNfTUVESVVNX0hVQl9HWVJPX1NFTlNPUjogNTgsXG4gICAgVEVDSE5JQ19NRURJVU1fSFVCX1RJTFRfU0VOU09SOiA1OSxcbiAgICBURUNITklDX01FRElVTV9IVUJfVEVNUEVSQVRVUkVfU0VOU09SOiA2MCxcbiAgICBURUNITklDX0NPTE9SX1NFTlNPUjogNjEsIC8vIFNwaWtlIFByaW1lXG4gICAgVEVDSE5JQ19ESVNUQU5DRV9TRU5TT1I6IDYyLCAvLyBTcGlrZSBQcmltZVxuICAgIFRFQ0hOSUNfRk9SQ0VfU0VOU09SOiA2MywgLy8gU3Bpa2UgUHJpbWVcbiAgICBURUNITklDXzNYM19DT0xPUl9MSUdIVF9NQVRSSVg6IDY0LCAvLyBTcGlrZSBFc3NlbnRpYWxcbiAgICBURUNITklDX1NNQUxMX0FOR1VMQVJfTU9UT1I6IDY1LCAvLyBTcGlrZSBFc3NlbnRpYWxcbiAgICBNQVJJT19BQ0NFTEVST01FVEVSOiA3MSxcbiAgICBNQVJJT19CQVJDT0RFX1NFTlNPUjogNzMsXG4gICAgTUFSSU9fUEFOVFNfU0VOU09SOiA3NCxcbiAgICBURUNITklDX01FRElVTV9BTkdVTEFSX01PVE9SX0dSRVk6IDc1LCAvLyBNaW5kc3Rvcm1zXG4gICAgVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SX0dSRVk6IDc2LCAvLyBUZWNobmljIENvbnRyb2wrXG4gICAgVklSVFVBTF9ERVZJQ0U6IDEwMFxufVxuXG5jb25zdCBEZXZpY2VUeXBlTmFtZXMgPSBnZXRFbnVtTmFtZShEZXZpY2VUeXBlKVxuXG5jb25zdCBFcnJvckNvZGUgPSB7XG4gICAgQUNLOiAweDAxLFxuICAgIE1BQ0s6IDB4MDIsXG4gICAgQlVGRkVSX09WRVJGTE9XOiAweDAzLFxuICAgIFRJTUVPVVQ6IDB4MDQsXG4gICAgQ09NTUFORF9OT1RfUkVDT0dOSVpFRDogMHgwNSxcbiAgICBJTlZBTElEX1VTRTogMHgwNixcbiAgICBPVkVSQ1VSUkVOVDogMHgwNyxcbiAgICBJTlRFUk5BTF9FUlJPUjogMHgwOCxcbn1cblxuY29uc3QgRXJyb3JDb2RlTmFtZXMgPSBnZXRFbnVtTmFtZShFcnJvckNvZGUpXG5cblxuY29uc3QgSHViUHJvcGVydHlQYXlsb2FkID0ge1xuICAgIEFEVkVSVElTSU5HX05BTUU6IDB4MDEsXG4gICAgQlVUVE9OX1NUQVRFOiAweDAyLFxuICAgIEZXX1ZFUlNJT046IDB4MDMsXG4gICAgSFdfVkVSU0lPTjogMHgwNCxcbiAgICBSU1NJOiAweDA1LFxuICAgIEJBVFRFUllfVk9MVEFHRTogMHgwNixcbiAgICBCQVRURVJZX1RZUEU6IDB4MDcsXG4gICAgTUFOVUZBQ1RVUkVSX05BTUU6IDB4MDgsXG4gICAgUkFESU9fRklSTVdBUkVfVkVSU0lPTjogMHgwOSxcbiAgICBMV1BfUFJPVE9DT0xfVkVSU0lPTjogMHgwQSxcbiAgICBTWVNURU1fVFlQRV9JRDogMHgwQixcbiAgICBIV19ORVRXT1JLX0lEOiAweDBDLFxuICAgIFBSSU1BUllfTUFDX0FERFJFU1M6IDB4MEQsXG4gICAgU0VDT05EQVJZX01BQ19BRERSRVNTOiAweDBFLFxuICAgIEhXX05FVFdPUktfRkFNSUxZOiAweDBGXG59XG5cbmNvbnN0IEh1YlByb3BlcnR5UGF5bG9hZE5hbWVzID0gZ2V0RW51bU5hbWUoSHViUHJvcGVydHlQYXlsb2FkKVxuXG5jb25zdCBNb2RlSW5mb3JtYXRpb25UeXBlID0ge1xuICAgIE5BTUU6IDB4MDAsXG4gICAgUkFXOiAweDAxLFxuICAgIFBDVDogMHgwMixcbiAgICBTSTogMHgwMyxcbiAgICBTWU1CT0w6IDB4MDQsXG4gICAgTUFQUElORzogMHgwNSxcbiAgICBVU0VEX0lOVEVSTkFMTFk6IDB4MDYsXG4gICAgTU9UT1JfQklBUzogMHgwNyxcbiAgICBDQVBBQklMSVRZX0JJVFM6IDB4MDgsXG4gICAgVkFMVUVfRk9STUFUOiAweDgwLFxufVxuXG5jb25zdCBNb2RlSW5mb3JtYXRpb25UeXBlTmFtZXMgPSBnZXRFbnVtTmFtZShNb2RlSW5mb3JtYXRpb25UeXBlKVxuXG5jb25zdCBQb3J0TWFwID0ge1xuICAgIFwiQVwiOiAwLFxuICAgIFwiQlwiOiAxLFxuICAgIFwiQ1wiOiAyLFxuICAgIFwiRFwiOiAzLFxuICAgIFwiSFVCX0xFRFwiOiA1MCxcbiAgICBcIkNVUlJFTlRfU0VOU09SXCI6IDU5LFxuICAgIFwiVk9MVEFHRV9TRU5TT1JcIjogNjAsXG4gICAgXCJBQ0NFTEVST01FVEVSXCI6IDk3LFxuICAgIFwiR1lST19TRU5TT1JcIjogOTgsXG4gICAgXCJUSUxUX1NFTlNPUlwiOiA5OVxufVxuXG5jb25zdCBEZXZpY2VNb2RlID0ge1xuICAgIFBPV0VSOiAweDAwLFxuICAgIFNQRUVEOiAweDAxLFxuICAgIFJPVEFUSU9OOiAweDAyLFxuICAgIEFCU09MVVRFOiAweDAzLFxuICAgIENPTE9SOiAweDAwLFxuICAgIFJHQjogMHgwMSxcbiAgICBUSUxUX1BPUzogMHgwMFxufVxuXG5jb25zdCBCcmFraW5nU3R5bGUgPSB7XG4gICAgRkxPQVQ6IDAsXG4gICAgSE9MRDogMTI2LFxuICAgIEJSQUtFOiAxMjdcbn1cblxuY29uc3QgUG9ydE1hcE5hbWVzID0gZ2V0RW51bU5hbWUoUG9ydE1hcClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWVzc2FnZVR5cGUsXG4gICAgTWVzc2FnZVR5cGVOYW1lcyxcbiAgICBFdmVudCxcbiAgICBFdmVudE5hbWVzLFxuICAgIEJyYWtpbmdTdHlsZSxcbiAgICBEZXZpY2VNb2RlLFxuICAgIERldmljZVR5cGUsXG4gICAgRGV2aWNlVHlwZU5hbWVzLFxuICAgIE1vZGVJbmZvcm1hdGlvblR5cGUsXG4gICAgTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzLFxuICAgIFBvcnRNYXAsXG4gICAgUG9ydE1hcE5hbWVzLFxuICAgIEh1YlByb3BlcnR5UGF5bG9hZCxcbiAgICBIdWJQcm9wZXJ0eVBheWxvYWROYW1lcyxcbiAgICBFcnJvckNvZGVOYW1lc1xufSIsIi8vQHRzLWNoZWNrXG5cbmNvbnN0IENhbGxiYWNrRW1pdHRlciA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tFbWl0dGVyJylcbmNvbnN0IHsgTWVzc2FnZVR5cGUsIFBvcnRNYXBOYW1lcyB9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG5jb25zdCB7IGxvZywgdG9VaW50MzIgfSA9IHJlcXVpcmUoJy4vVXRpbCcpXG5cbmNvbnN0IGRldmljZUluZm8gPSB7fVxuXG5jbGFzcyBEZXZpY2Uge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7SFVCLkh1YkRldmljZX0gaHViRGV2aWNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5odWJEZXZpY2UgPSBodWJEZXZpY2VcbiAgICAgICAgdGhpcy5wb3J0SWQgPSBwb3J0SWRcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZVxuICAgICAgICB0aGlzLm5hbWUgPSBQb3J0TWFwTmFtZXNbcG9ydElkXVxuICAgICAgICB0aGlzLmZlZWRiYWNrQ2FsbGJhY2sgPSBudWxsXG4gICAgICAgIHRoaXMudmFsdWVDYWxsYmFjayA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLm1vZGUgPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy53YWl0RW5kID0gZmFsc2VcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25FbmFibGVkID0gZmFsc2VcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FpdEVuZCBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGRhdGEgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVQb3J0Q29tbWFuZCh3YWl0RW5kLCAuLi5kYXRhKSB7XG4gICAgICAgIHRoaXMud2FpdEVuZCA9IHdhaXRFbmRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrQ2FsbGJhY2sgPSByZXNvbHZlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmh1YkRldmljZS53cml0ZVBvcnRDb21tYW5kKHRoaXMucG9ydElkLCBkYXRhKVxuICAgICAgICB9KSAgXG5cbiAgICB9XG5cbiAgICBoYW5kbGVGZWVkYmFjayhmZWVkYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZmVlZGJhY2tDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZmVlZGJhY2sgPT0gMSAmJiAhdGhpcy53YWl0RW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWVkYmFja0NhbGxiYWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZlZWRiYWNrID09IDEwICYmIHRoaXMud2FpdEVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tDYWxsYmFjaygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBkYXRhIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHdyaXRlRGlyZWN0TW9kZShtb2RlLCAuLi5kYXRhKSB7XG4gICAgICAgIGxvZygnd3JpdGVEaXJlY3RNb2RlJywgdGhpcy5wb3J0SWQsIHsgbW9kZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHRydWUsIDB4NTEsIG1vZGUsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBub3RpZmljYXRpb25FbmFibGVkIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YUludGVydmFsIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHNldE1vZGUobW9kZSwgbm90aWZpY2F0aW9uRW5hYmxlZCwgZGVsdGFJbnRlcnZhbCA9IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldE1vZGUnLCB0aGlzLnBvcnRJZCwgeyBtb2RlLCBub3RpZmljYXRpb25FbmFibGVkIH0pXG5cbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZVxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbkVuYWJsZWQgPSBub3RpZmljYXRpb25FbmFibGVkXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaHViRGV2aWNlLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9JTlBVVF9GT1JNQVRfU0VUVVBfU0lOR0xFLFxuICAgICAgICAgICAgdGhpcy5wb3J0SWQsIG1vZGUsIHRvVWludDMyKGRlbHRhSW50ZXJ2YWwpLCBub3RpZmljYXRpb25FbmFibGVkID8gMHgwMSA6IDApXG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZEluZm8oKSB7XG4gICAgICAgIGxldCBpbmZvID0gZGV2aWNlSW5mb1t0aGlzLnR5cGVdXG4gICAgICAgIGlmIChpbmZvID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5mbyA9IGF3YWl0IHRoaXMuaHViRGV2aWNlLmdldFBvcnRJbmZvcm1hdGlvbih0aGlzLnBvcnRJZClcbiAgICAgICAgICAgIGRldmljZUluZm9bdGhpcy50eXBlXSA9IGluZm9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mb1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgKi9cbiAgICBkZWNvZGVWYWx1ZShtc2cpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGRldmljZUluZm9bdGhpcy50eXBlXVxuICAgICAgICBpZiAoaW5mbyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgVkFMVUVfRk9STUFULCBSQVcsIFNJIH0gPSBpbmZvLm1vZGVzW3RoaXMubW9kZV1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gJCQudXRpbC5tYXBSYW5nZShSQVcubWluLCBSQVcubWF4LCBTSS5taW4sIFNJLm1heClcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YVR5cGUsIG51bVZhbHVlcyB9ID0gVkFMVUVfRk9STUFUXG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDRcbiAgICAgICAgICAgIGxldCB2YWxcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG51bVZhbHVlczsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzE2Yml0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG1zZy5nZXRJbnQxNihvZmZzZXQsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzhiaXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbXNnLmdldEludDgob2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICczMmJpdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtc2cuZ2V0SW50MzIob2Zmc2V0LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtc2cuZ2V0RmxvYXQzMihvZmZzZXQsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nKCd2YWwnLCB2YWwpXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goTWF0aC50cnVuYyhyYW5nZSh2YWwpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRcblxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgKi9cbiAgICBoYW5kbGVWYWx1ZShtc2cpIHtcbiAgICAgICAgbG9nKCdoYW5kbGVWYWx1ZScsIHRoaXMucG9ydElkLCBtc2cpXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGVjb2RlVmFsdWUobXNnKVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHRoaXMudmFsdWVDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2FsbGJhY2sodmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIFxuICAgICAqIEByZXR1cm5zIFxuICAgICovXG4gICAgYXN5bmMgZ2V0VmFsdWUobW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZ2V0VmFsdWUnLCB0aGlzLnBvcnRJZCwgeyBtb2RlIH0pXG5cbiAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKG1vZGUsIGZhbHNlKVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDYWxsYmFjayA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZhbHVlJywgZGF0YSlcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaHViRGV2aWNlLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9JTkZPUk1BVElPTl9SRVFVRVNULCB0aGlzLnBvcnRJZCwgMHgwMClcblxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIFxuICAgICAqIEBwYXJhbSB7KGRhdGEpID0+IFByb21pc2U8Ym9vbGVhbj59IHRlc3RGbiBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICBhc3luYyB3YWl0VGVzdFZhbHVlKG1vZGUsIHRlc3RGbikge1xuICAgICAgICBhd2FpdCB0aGlzLnNldE1vZGUobW9kZSwgdHJ1ZSlcblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNhbGxiYWNrID0gYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKCd3YWl0VGVzdFZhbHVlJywgdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gYXdhaXQgdGVzdEZuKHZhbHVlKVxuICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCd3YWl0VGVzdFZhbHVlIE9LJylcbiAgICAgICAgICAgICAgICAgICAgLy9hd2FpdCB0aGlzLnNldE1vZGUobW9kZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGhpcy5zZXRNb2RlKG1vZGUsIGZhbHNlKVxuICAgIH1cblxuICAgIGFzeW5jIHN1YnNjcmliZShtb2RlLCBjYmssIGRlbHRhSW50ZXJ2YWwgPSAxKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0TW9kZShtb2RlLCB0cnVlLCBkZWx0YUludGVydmFsKVxuICAgICAgICB0aGlzLnZhbHVlQ2FsbGJhY2sgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgY2JrKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm90aWZpY2F0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlKHRoaXMubW9kZSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZXZpY2UiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBNb3RvciA9IHJlcXVpcmUoJy4vTW90b3InKVxuY29uc3Qge0JyYWtpbmdTdHlsZX0gPSByZXF1aXJlKCcuL0NvbnN0JylcbmNvbnN0IHt0b0ludDE2LCB0b0ludDMyfSA9IHJlcXVpcmUoJy4vVXRpbCcpXG5cbmNvbnN0IG1heFBvd2VyID0gMTAwXG5cbmNsYXNzIERvdWJsZU1vdG9yIGV4dGVuZHMgTW90b3Ige1xuXG5cbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgbmFtZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgJ1ZpcnR1YWwgRGV2aWNlJylcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkMSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWQyIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHNldFNwZWVkKHNwZWVkMSwgc3BlZWQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQoZmFsc2UsIDB4MDgsIHNwZWVkMSwgc3BlZWQyLCBtYXhQb3dlciwgMClcbiAgICB9XG5cbiAgICBzZXRTcGVlZEZvclRpbWUoc3BlZWQxLCBzcGVlZDIsIHRpbWUsIHdhaXRGZWVkYmFjayA9IGZhbHNlLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnc2V0U3BlZWRGb3JUaW1lJywgdGhpcy5wb3J0SWQsIHsgc3BlZWQxLCBzcGVlZDIsIHRpbWUsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQodGhpcy5wb3J0SWQsIHdhaXRGZWVkYmFjaywgMHgwQSwgdG9JbnQxNih0aW1lKSwgc3BlZWQxLCBzcGVlZDIsIG1heFBvd2VyLCBicmFraW5nU3R5bGUpXG4gICAgfVxuXG4gICAgcm90YXRlRGVncmVlcyhkZWdyZWVzLCBzcGVlZDEsIHNwZWVkMiwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3JvdGF0ZURlZ3JlZXMnLCB0aGlzLnBvcnRJZCwgeyBkZWdyZWVzLCBzcGVlZDEsIHNwZWVkMiwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RmVlZGJhY2ssIDB4MEMsIHRvSW50MzIoZGVncmVlcyksIHNwZWVkMSwgc3BlZWQyLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIGdvdG9BbmdsZShhbmdsZTEsIGFuZ2xlMiwgc3BlZWQsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlID0gQnJha2luZ1N0eWxlLkJSQUtFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnb3RvQW5nbGUnLCB0aGlzLnBvcnRJZCwgeyBhbmdsZTEsIGFuZ2xlMiwgc3BlZWQsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RmVlZGJhY2ssIDB4MEUsIHRvSW50MzIoYW5nbGUxKSwgdG9JbnQzMihhbmdsZTIpLCBzcGVlZCwgbWF4UG93ZXIsIGJyYWtpbmdTdHlsZSlcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRG91YmxlTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jbGFzcyBMZWQgZXh0ZW5kcyBEZXZpY2Uge1xuXG4gICAgLyoqXG4gICAgKiBcbiAgICAqIEBwYXJhbSB7SHViRGV2aWNlfSBodWJEZXZpY2UgXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpXG5cbiAgICB9XG5cbiAgICBzZXRCcmlnaHRuZXNzKGJyaWdodG5lc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldEJyaWdodG5lc3MnLCB0aGlzLnBvcnRJZCwgeyBicmlnaHRuZXNzIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLlBPV0VSLCBicmlnaHRuZXNzKVxuICAgIH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGVkIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgRGV2aWNlID0gcmVxdWlyZSgnLi9EZXZpY2UnKVxuY29uc3Qge1BvcnRNYXBOYW1lcywgRGV2aWNlTW9kZX0gPSByZXF1aXJlKCcuL0NvbnN0JylcblxuY29uc3QgbWF4UG93ZXIgPSAxMDBcblxuY2xhc3MgTW90b3IgZXh0ZW5kcyBEZXZpY2Uge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtIdWJEZXZpY2V9IGh1YkRldmljZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKVxuICAgIH1cblxuICAgIHNldFBvd2VyKHBvd2VyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzZXRQb3dlcicsIHRoaXMucG9ydElkLCB7IHBvd2VyIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLlBPV0VSLCBwb3dlcilcbiAgICB9XG5cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdG9yIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgRGV2aWNlID0gcmVxdWlyZSgnLi9EZXZpY2UnKVxuY29uc3Qge1BvcnRNYXBOYW1lcywgRGV2aWNlTW9kZX0gPSByZXF1aXJlKCcuL0NvbnN0JylcblxuY2xhc3MgUmdiTGVkIGV4dGVuZHMgRGV2aWNlIHtcblxuICAgIC8qKlxuICAgICogXG4gICAgKiBAcGFyYW0ge0h1YkRldmljZX0gaHViRGV2aWNlIFxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKVxuXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldENvbG9yJywgdGhpcy5wb3J0SWQsIHsgY29sb3IgfSlcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKERldmljZU1vZGUuQ09MT1IsIGZhbHNlKVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoRGV2aWNlTW9kZS5DT0xPUiwgY29sb3IpXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0UkdCQ29sb3IociwgZywgYikge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0Q29sb3InLCB0aGlzLnBvcnRJZCwgeyByLCBnLCBiIH0pXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0TW9kZShEZXZpY2VNb2RlLlJHQiwgZmFsc2UpXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLlJHQiwgciwgZywgYilcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmdiTGVkIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgTW90b3IgPSByZXF1aXJlKCcuL01vdG9yJylcbmNvbnN0IHtQb3J0TWFwTmFtZXMsIERldmljZU1vZGUsIEJyYWtpbmdTdHlsZX0gPSByZXF1aXJlKCcuL0NvbnN0JylcbmNvbnN0IHt0b0ludDMyLCB0b0ludDE2fSA9IHJlcXVpcmUoJy4vVXRpbCcpXG5cbmNvbnN0IG1heFBvd2VyID0gMTAwXG5cbmNsYXNzIFRhY2hvTW90b3IgZXh0ZW5kcyBNb3RvciB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0h1YkRldmljZX0gaHViRGV2aWNlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpXG4gICAgfVxuXG4gICAgc2V0U3BlZWQoc3BlZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJyNzZXRTcGVlZCcsIHRoaXMucG9ydElkLCB7IHNwZWVkIH0pXG4gICAgICAgIGlmIChzcGVlZCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQb3dlcigwKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQodHJ1ZSwgMHgwNywgc3BlZWQsIG1heFBvd2VyLCAwKVxuICAgIH1cblxuICAgIHJvdGF0ZURlZ3JlZXMoZGVncmVlcywgc3BlZWQsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSA9IEJyYWtpbmdTdHlsZS5CUkFLRSkge1xuICAgICAgICBjb25zb2xlLmxvZygncm90YXRlRGVncmVlcycsIHRoaXMucG9ydElkLCB7IGRlZ3JlZXMsIHNwZWVkLCB3YWl0RW5kLCBicmFraW5nU3R5bGUgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RW5kLCAweDBCLCB0b0ludDMyKGRlZ3JlZXMpLCBzcGVlZCwgbWF4UG93ZXIsIGJyYWtpbmdTdHlsZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FpdEVuZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnJha2luZ1N0eWxlIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIGdvdG9BbmdsZShhbmdsZSwgc3BlZWQsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSA9IEJyYWtpbmdTdHlsZS5CUkFLRSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZ290b0FuZ2xlJywgdGhpcy5wb3J0SWQsIHsgYW5nbGUsIHNwZWVkLCB3YWl0RW5kLCBicmFraW5nU3R5bGUgfSlcblxuICAgICAgICBpZiAodGhpcy5jYWxpYnJhdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBhbmdsZSAqPSB0aGlzLmNhbGlicmF0aW9uVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQod2FpdEVuZCwgMHgwRCwgdG9JbnQzMihhbmdsZSksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIHNldFNwZWVkRm9yVGltZShzcGVlZCwgdGltZSwgd2FpdEVuZCA9IGZhbHNlLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnc2V0U3BlZWRGb3JUaW1lJywgdGhpcy5wb3J0SWQsIHsgc3BlZWQsIHRpbWUsIHdhaXRFbmQsIGJyYWtpbmdTdHlsZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRFbmQsIDB4MDksIHRvSW50MTYodGltZSksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIHJlc2V0WmVybygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0WmVybycsIHRoaXMucG9ydElkKVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoRGV2aWNlTW9kZS5ST1RBVElPTiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMClcbiAgICB9XG5cbiAgICBnZXRTcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5TUEVFRClcbiAgICB9XG5cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5ST1RBVElPTilcbiAgICB9XG5cbiAgICBnZXRBYnNvbHV0ZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShEZXZpY2VNb2RlLkFCU09MVVRFKVxuICAgIH1cblxuICAgIGFzeW5jIGNhbGlicmF0ZSgpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnY2FsaWJyYXRlJywgdGhpcy5wb3J0SWQpXG4gICAgICAgIHRoaXMuc2V0UG93ZXIoNTApXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdFRlc3RWYWx1ZShEZXZpY2VNb2RlLlNQRUVELCAodmFsdWUpID0+IHZhbHVlID4gMTApXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdFRlc3RWYWx1ZShEZXZpY2VNb2RlLlNQRUVELCAodmFsdWUpID0+IHZhbHVlID09IDApXG5cblxuICAgICAgICB0aGlzLnNldFBvd2VyKDApXG5cbiAgICAgICAgYXdhaXQgJCQudXRpbC53YWl0KDEwMDApXG5cbiAgICAgICAgLy8gYXdhaXQgdGhpcy5odWJEZXZpY2Uuc2V0UG9ydEZvcm1hdCh0aGlzLnBvcnRJZCwgRGV2aWNlTW9kZS5ST1RBVElPTilcbiAgICAgICAgLy8gbGV0IHZhbHVlID0gYXdhaXQgdGhpcy5odWJEZXZpY2UuZ2V0UG9ydFZhbHVlKHRoaXMucG9ydElkKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSlcdFxuXG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRaZXJvKClcblxuXG4gICAgICAgIHRoaXMuc2V0UG93ZXIoLTUwKVxuICAgICAgICBhd2FpdCB0aGlzLndhaXRUZXN0VmFsdWUoRGV2aWNlTW9kZS5TUEVFRCwgKHZhbHVlKSA9PiBNYXRoLmFicyh2YWx1ZSkgPiAxMClcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0VGVzdFZhbHVlKERldmljZU1vZGUuU1BFRUQsICh2YWx1ZSkgPT4gdmFsdWUgPT0gMClcblxuICAgICAgICB0aGlzLnNldFBvd2VyKDApXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXRWYWx1ZShEZXZpY2VNb2RlLlJPVEFUSU9OKVxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSlcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcih2YWx1ZSAvIDIpXG4gICAgICAgIGNvbnNvbGUubG9nKHsgb2Zmc2V0IH0pXG4gICAgICAgIGF3YWl0IHRoaXMuZ290b0FuZ2xlKG9mZnNldCwgMTAsIHRydWUpXG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRaZXJvKClcbiAgICAgICAgdGhpcy5jYWxpYnJhdGlvblZhbHVlID0gTWF0aC5hYnMob2Zmc2V0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgKi9cbiAgICBkZWNvZGVWYWx1ZShtc2cpIHtcbiAgICAgICAgbGV0IHZhbHVlXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERldmljZU1vZGUuQUJTT0xVVEU6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtc2cuZ2V0SW50MTYoNCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBEZXZpY2VNb2RlLlJPVEFUSU9OOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gbXNnLmdldEludDMyKDQsIHRydWUpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgRGV2aWNlTW9kZS5TUEVFRDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1zZy5nZXRJbnQ4KDQpXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhY2hvTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jbGFzcyBUaWx0U2Vuc29yIGV4dGVuZHMgRGV2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICovXG4gICAgZGVjb2RlVmFsdWUobXNnKSB7XG4gICAgICAgIGxldCB2YWx1ZVxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEZXZpY2VNb2RlLlRJTFRfUE9TOlxuICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICB5YXc6IG1zZy5nZXRJbnQxNig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgcGl0Y2g6IG1zZy5nZXRJbnQxNig2LCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgcm9sbDogbXNnLmdldEludDE2KDgsIHRydWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3VwZXIuZGVjb2RlVmFsdWUobXNnKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTZW5zb3JcbiIsIi8vQHRzLWNoZWNrXG5cbi8qKlxuICAqIFxuICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgXG4gICogQHJldHVybnMge0FycmF5fVxuICAqL1xuZnVuY3Rpb24gdG9JbnQxNih2YWwpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoMilcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKVxuICAgIHZpZXcuc2V0SW50MTYoMCwgdmFsLCB0cnVlKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGJ1ZmYpXG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0ludDMyKHZhbCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSg0KVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpXG4gICAgdmlldy5zZXRJbnQzMigwLCB2YWwsIHRydWUpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnVmZilcbn1cblxuZnVuY3Rpb24gdG9VaW50MzIodmFsKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpXG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcilcbiAgICB2aWV3LnNldFVpbnQzMigwLCB2YWwsIHRydWUpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnVmZilcbn1cblxuY29uc3QgZGVidWcgPSBmYWxzZVxuXG5jb25zdCBsb2cgPSBmdW5jdGlvbiAoLi4uZGF0YSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBkYXRhKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdG9JbnQxNixcbiAgICB0b0ludDMyLFxuICAgIHRvVWludDMyLFxuICAgIGxvZ1xufSIsIi8vQHRzLWNoZWNrXG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IENhbGxiYWNrRW1pdHRlciA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tFbWl0dGVyJylcbiAgICBjb25zdCB7IEV2ZW50TmFtZXMsIERldmljZU1vZGUsIERldmljZVR5cGVOYW1lcywgQnJha2luZ1N0eWxlLCBQb3J0TWFwLCBIdWJQcm9wZXJ0eVBheWxvYWROYW1lcywgTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzLCBFdmVudCwgRGV2aWNlVHlwZSwgUG9ydE1hcE5hbWVzLCBNZXNzYWdlVHlwZSwgSHViUHJvcGVydHlQYXlsb2FkLCBNb2RlSW5mb3JtYXRpb25UeXBlLCBFcnJvckNvZGVOYW1lcywgTWVzc2FnZVR5cGVOYW1lcyB9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG4gICAgY29uc3QgTW90b3IgPSByZXF1aXJlKCcuL01vdG9yJylcbiAgICBjb25zdCBEb3VibGVNb3RvciA9IHJlcXVpcmUoJy4vRG91YmxlTW90b3InKVxuICAgIGNvbnN0IFRhY2hvTW90b3IgPSByZXF1aXJlKCcuL1RhY2hvTW90b3InKTtcbiAgICBjb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG4gICAgY29uc3QgUmdiTGVkID0gcmVxdWlyZSgnLi9SZ2JMZWQnKVxuICAgIGNvbnN0IExlZCA9IHJlcXVpcmUoJy4vTGVkJylcbiAgICBjb25zdCBUaWx0U2Vuc29yID0gcmVxdWlyZSgnLi9UaWx0U2Vuc29yJylcbiAgICBjb25zdCB7IGxvZyB9ID0gcmVxdWlyZSgnLi9VdGlsJylcblxuICAgIGNvbnN0IENvbG9yID0ge1xuICAgICAgICBCTEFDSzogMCxcbiAgICAgICAgUElOSzogMSxcbiAgICAgICAgUFVSUExFOiAyLFxuICAgICAgICBCTFVFOiAzLFxuICAgICAgICBMSUdIVF9CTFVFOiA0LFxuICAgICAgICBDWUFOOiA1LFxuICAgICAgICBHUkVFTjogNixcbiAgICAgICAgWUVMTE9XOiA3LFxuICAgICAgICBPUkFOR0U6IDgsXG4gICAgICAgIFJFRDogOSxcbiAgICAgICAgV0hJVEU6IDEwLFxuICAgICAgICBOT05FOiAyNTVcbiAgICB9XG5cbiAgICBjb25zdCBMUEYyX1NFUlZJQ0VfVVVJRCA9ICcwMDAwMTYyMy0xMjEyLWVmZGUtMTYyMy03ODVmZWFiY2QxMjMnXG4gICAgY29uc3QgTFBGMl9DSEFSQUNfVVVJRCA9ICcwMDAwMTYyNC0xMjEyLWVmZGUtMTYyMy03ODVmZWFiY2QxMjMnXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZiBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYlRvU3RyaW5nKGJ1Zikge1xuICAgICAgICBjb25zdCB1aW50OGJ1ZmYgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgICAgIGxldCByZXQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhidWZmLmJ5dGVMZW5ndGggJiYgdWludDhidWZmW2ldICE9IDA7IGkrKykge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhidWZmW2ldKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gZGF0YSBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0TXNnKG1zZ1R5cGUsIC4uLmRhdGEpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGRhdGEuZmxhdCg0KVxuICAgICAgICBjb25zdCBtc2dMZW4gPSBidWZmLmxlbmd0aCArIDNcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG1zZ0xlbilcbiAgICAgICAgY29uc3QgdWludDhCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgICAgIHVpbnQ4QnVmZmVyWzBdID0gbXNnTGVuXG4gICAgICAgIHVpbnQ4QnVmZmVyWzFdID0gMFxuICAgICAgICB1aW50OEJ1ZmZlclsyXSA9IG1zZ1R5cGVcbiAgICAgICAgdWludDhCdWZmZXIuc2V0KGJ1ZmYsIDMpXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldFZpcnR1YWxQb3J0TmFtZShwb3J0SWQxLCBwb3J0SWQyKSB7XG4gICAgICAgIGNvbnN0IHBvcnRJZEEgPSBQb3J0TWFwTmFtZXNbcG9ydElkMV1cbiAgICAgICAgY29uc3QgcG9ydElkQiA9IFBvcnRNYXBOYW1lc1twb3J0SWQyXVxuICAgICAgICByZXR1cm4gYCR7cG9ydElkQX1fJHtwb3J0SWRCfWBcbiAgICB9XG5cbiAgICBjb25zdCBjb25zdHJ1Y3Rvck1hcCA9IHtcbiAgICAgICAgW0RldmljZVR5cGUuVEVDSE5JQ19MQVJHRV9MSU5FQVJfTU9UT1JdOiBUYWNob01vdG9yLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX0xBUkdFX0FOR1VMQVJfTU9UT1JfR1JFWV06IFRhY2hvTW90b3IsXG4gICAgICAgIFtEZXZpY2VUeXBlLlRFQ0hOSUNfWExBUkdFX0xJTkVBUl9NT1RPUl06IFRhY2hvTW90b3IsXG4gICAgICAgIFtEZXZpY2VUeXBlLlRFQ0hOSUNfTUVESVVNX0hVQl9USUxUX1NFTlNPUl06IFRpbHRTZW5zb3IsXG4gICAgICAgIFtEZXZpY2VUeXBlLkhVQl9MRURdOiBSZ2JMZWQsXG4gICAgICAgIFtEZXZpY2VUeXBlLkxJR0hUXTogTGVkXG4gICAgfVxuXG4gICAgLyoqQGltcGxlbWVudHMgSFVCLkh1YkRldmljZSAqL1xuICAgIGNsYXNzIEh1YkRldmljZSBleHRlbmRzIEV2ZW50RW1pdHRlcjIge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKVxuICAgICAgICAgICAgdGhpcy5jaGFyYWMgPSBudWxsXG4gICAgICAgICAgICB0aGlzLnBvcnRDbWRRdWV1ZSA9IHt9XG4gICAgICAgICAgICB0aGlzLnBvcnRDbWRDYWxsYmFjayA9IHt9XG4gICAgICAgICAgICAvKipAdHlwZSB7e1twb3J0SWQ6IHN0cmluZ106IERldmljZX19ICovXG4gICAgICAgICAgICB0aGlzLmh1YkRldmljZXMgPSB7fVxuICAgICAgICAgICAgdGhpcy5idXN5ID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzID0gbmV3IENhbGxiYWNrRW1pdHRlcigpXG4gICAgICAgICAgICB0aGlzLnBvcnRDbWRRdWV1ZSA9IFtdXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIHdyaXRlUG9ydENvbW1hbmQocG9ydElkLCAuLi5kYXRhKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjd3JpdGVQb3J0Q29tbWFuZCcsIHsgcG9ydElkLCBkYXRhIH0pXG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGZvcm1hdE1zZyhNZXNzYWdlVHlwZS5QT1JUX09VVFBVVF9DT01NQU5ELCBwb3J0SWQsIDB4MTEsIGRhdGEpXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5idXN5KSAge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9IHRydWVcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0Q21kUXVldWUucHVzaChidWZmZXIpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyMgQnVzeSAhIHdhaXQgZmVlZGJhY2snKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0JsdWV0b290aERldmljZX0gZGV2aWNlIFxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgaW5pdChkZXZpY2UpIHtcblxuICAgICAgICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgZGV2aWNlLmdhdHQuY29ubmVjdCgpXG4gICAgICAgICAgICBsb2coJ0Nvbm5lY3RlZCcpXG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmVyLmdldFByaW1hcnlTZXJ2aWNlKExQRjJfU0VSVklDRV9VVUlEKVxuICAgICAgICAgICAgdGhpcy5jaGFyYWMgPSBhd2FpdCBzZXJ2aWNlLmdldENoYXJhY3RlcmlzdGljKExQRjJfQ0hBUkFDX1VVSUQpXG5cbiAgICAgICAgICAgIGNvbnN0IG9uQ2hhcmFjdGVyaXN0aWN2YWx1ZWNoYW5nZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZU1zZyhldmVudC50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRldmljZS5hZGRFdmVudExpc3RlbmVyKCdnYXR0c2VydmVyZGlzY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkdhdHRTZXJ2ZXJEaXNjb25uZWN0ZWQnLCB0aGlzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhcmFjLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYXJhY3RlcmlzdGljdmFsdWVjaGFuZ2VkJywgb25DaGFyYWN0ZXJpc3RpY3ZhbHVlY2hhbmdlZClcblxuICAgICAgICAgICAgICAgIHRoaXMuY2hhcmFjID0gbnVsbFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuY2hhcmFjLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYXJhY3RlcmlzdGljdmFsdWVjaGFuZ2VkJywgb25DaGFyYWN0ZXJpc3RpY3ZhbHVlY2hhbmdlZClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hhcmFjLnN0YXJ0Tm90aWZpY2F0aW9ucygpXG4gICAgICAgICAgICBhd2FpdCAkJC51dGlsLndhaXQoMTAwKVxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgc3RhcnROb3RpZmljYXRpb24oKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVMsIEh1YlByb3BlcnR5UGF5bG9hZC5CQVRURVJZX1ZPTFRBR0UsIDB4MDIpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVMsIEh1YlByb3BlcnR5UGF5bG9hZC5TWVNURU1fVFlQRV9JRCwgMHgwNSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUywgSHViUHJvcGVydHlQYXlsb2FkLlBSSU1BUllfTUFDX0FERFJFU1MsIDB4MDUpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX0FMRVJUUywgMHgwMSwgMHgwMSlcbiAgICAgICAgICAgIC8vIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfQUxFUlRTLCAweDAyLCAweDAxKVxuICAgICAgICAgICAgLy8gYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9BTEVSVFMsIDB4MDMsIDB4MDEpXG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX0FMRVJUUywgMHgwNCwgMHgwMSlcblxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vdG9yPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1vdG9yKHBvcnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgICAgIGlmIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZSBpbnN0YW5jZW9mIE1vdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLm9uKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UucG9ydElkID09IHBvcnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhgZGV2aWNlIG9uIHBvcnRJZCAke3BvcnRJZH0gaXMgcmVhZHlgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vdG9yPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRhY2hvTW90b3IocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuaHViRGV2aWNlc1twb3J0SWRdXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlIGluc3RhbmNlb2YgVGFjaG9Nb3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaENhbGxiYWNrcy5vbigoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLnBvcnRJZCA9PSBwb3J0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coYGRldmljZSBvbiBwb3J0SWQgJHtwb3J0SWR9IGlzIHJlYWR5YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQgXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRpbHRTZW5zb3I+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlsdFNlbnNvcihwb3J0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgICAgICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UgaW5zdGFuY2VvZiBUaWx0U2Vuc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLm9uKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UucG9ydElkID09IHBvcnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhgZGV2aWNlIG9uIHBvcnRJZCAke3BvcnRJZH0gaXMgcmVhZHlgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cblxuICAgICAgICBnZXRSZ2JMZWQocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuaHViRGV2aWNlc1twb3J0SWRdXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlIGluc3RhbmNlb2YgUmdiTGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLm9uKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UucG9ydElkID09IHBvcnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhgZGV2aWNlIG9uIHBvcnRJZCAke3BvcnRJZH0gaXMgcmVhZHlgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0TGVkKHBvcnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgICAgIGlmIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZSBpbnN0YW5jZW9mIExlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaENhbGxiYWNrcy5vbigoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLnBvcnRJZCA9PSBwb3J0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coYGRldmljZSBvbiBwb3J0SWQgJHtwb3J0SWR9IGlzIHJlYWR5YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXREYmxNb3Rvcihwb3J0SWQxLCBwb3J0SWQyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0VmlydHVhbFBvcnROYW1lKHBvcnRJZDEsIHBvcnRJZDIpXG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gT2JqZWN0LnZhbHVlcyh0aGlzLmh1YkRldmljZXMpLmZpbmQoKGQpID0+IGQubmFtZSA9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGlmIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLm9uKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGRldmljZSBvbiBwb3J0SWQgJHtkZXZpY2UucG9ydElkfSBpcyByZWFkeWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlVmlydHVhbFBvcnQocG9ydElkMSwgcG9ydElkMilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgc2VuZEJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjIHNlbmRCdWZmZXInLCBidWZmZXIpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoYXJhYy53cml0ZVZhbHVlV2l0aG91dFJlc3BvbnNlKGJ1ZmZlcilcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdPSycpXG4gICAgICAgICAgICAvLyBpZiAoIXRoaXMuYnVzeSkge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuYnVzeSA9IHRydWVcbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLmNoYXJhYy53cml0ZVZhbHVlV2l0aG91dFJlc3BvbnNlKGJ1ZmZlcilcbiAgICAgICAgICAgIC8vICAgICB0aGlzLmJ1c3kgPSBmYWxzZVxuICAgICAgICAgICAgLy8gICAgIGlmICh0aGlzLmNtZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coJ3Byb2Nlc3MgcXVldWVkIGNtZCcpXG4gICAgICAgICAgICAvLyAgICAgICAgIGF3YWl0IHRoaXMuY2hhcmFjLndyaXRlVmFsdWVXaXRob3V0UmVzcG9uc2UodGhpcy5jbWRRdWV1ZS5zaGlmdCgpKVxuICAgICAgICAgICAgLy8gICAgIH1cblxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ2J1c3khIHB1c2ggaW4gcXVldWUnKVxuICAgICAgICAgICAgLy8gICAgIHRoaXMuY21kUXVldWUucHVzaChidWZmZXIpXG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ1R5cGVcbiAgICAgICAgICogQHBhcmFtICB7Li4uYW55fSBkYXRhIFxuICAgICAgICAgKi9cbiAgICAgICAgc2VuZE1zZyhtc2dUeXBlLCAuLi5kYXRhKSB7XG4gICAgICAgICAgICBsb2coJ3NlbmRNc2cnLCBNZXNzYWdlVHlwZU5hbWVzW21zZ1R5cGVdLCBkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEJ1ZmZlcihmb3JtYXRNc2cobXNnVHlwZSwgZGF0YSkpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UG9ydElkRnJvbU5hbWUobmFtZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmZvIG9mIE9iamVjdC52YWx1ZXModGhpcy5odWJEZXZpY2VzKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mby5wb3J0SWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZDFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZDJcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVZpcnR1YWxQb3J0KHBvcnRJZDEsIHBvcnRJZDIpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5WSVJUVUFMX1BPUlRfU0VUVVAsIDB4MDEsIHBvcnRJZDEsIHBvcnRJZDIpXG4gICAgICAgIH1cblxuICAgICAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX0FDVElPTlMsIDB4MDEpXG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldEh1YkRldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmh1YkRldmljZXMpXG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyByZWFkRGV2aWNlSW5mbygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGV2aWNlIG9mIHRoaXMuZ2V0SHViRGV2aWNlcygpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGV2aWNlLnJlYWRJbmZvKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldERldmljZShwb3J0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIVUIuUG9ydEluZm9ybWF0aW9uPn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFBvcnRJbmZvcm1hdGlvbihwb3J0SWQpIHtcblxuICAgICAgICAgICAgY29uc3QgcG9ydEluZm8gPSBhd2FpdCB0aGlzLmdldFBvcnRJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkKVxuICAgICAgICAgICAgY29uc3QgeyBjb3VudCwgb3V0cHV0LCBpbnB1dCwgY2FwYWJpbGl0aWVzIH0gPSBwb3J0SW5mb1xuICAgICAgICAgICAgY29uc3QgbW9kZXMgPSBbXVxuICAgICAgICAgICAgZm9yIChsZXQgbW9kZSA9IDA7IG1vZGUgPCBjb3VudDsgbW9kZSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHt9XG4gICAgICAgICAgICAgICAgbGV0IHJldFxuICAgICAgICAgICAgICAgIGRhdGEubW9kZSA9IDBcbiAgICAgICAgICAgICAgICByZXQgPSBhd2FpdCB0aGlzLmdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgTW9kZUluZm9ybWF0aW9uVHlwZS5OQU1FKVxuICAgICAgICAgICAgICAgIGRhdGEubmFtZSA9IHJldC5uYW1lXG4gICAgICAgICAgICAgICAgcmV0ID0gYXdhaXQgdGhpcy5nZXRQb3J0TW9kZUluZm9ybWF0aW9uUmVxdWVzdChwb3J0SWQsIG1vZGUsIE1vZGVJbmZvcm1hdGlvblR5cGUuUkFXKVxuICAgICAgICAgICAgICAgIGRhdGFbcmV0LnR5cGVdID0geyBtaW46IHJldC5taW4sIG1heDogcmV0Lm1heCB9XG4gICAgICAgICAgICAgICAgcmV0ID0gYXdhaXQgdGhpcy5nZXRQb3J0TW9kZUluZm9ybWF0aW9uUmVxdWVzdChwb3J0SWQsIG1vZGUsIE1vZGVJbmZvcm1hdGlvblR5cGUuU0kpXG4gICAgICAgICAgICAgICAgZGF0YVtyZXQudHlwZV0gPSB7IG1pbjogcmV0Lm1pbiwgbWF4OiByZXQubWF4IH1cbiAgICAgICAgICAgICAgICByZXQgPSBhd2FpdCB0aGlzLmdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgTW9kZUluZm9ybWF0aW9uVHlwZS5TWU1CT0wpXG4gICAgICAgICAgICAgICAgZGF0YS51bml0ID0gcmV0LnN5bWJvbFxuICAgICAgICAgICAgICAgIHJldCA9IGF3YWl0IHRoaXMuZ2V0UG9ydE1vZGVJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkLCBtb2RlLCBNb2RlSW5mb3JtYXRpb25UeXBlLlZBTFVFX0ZPUk1BVClcbiAgICAgICAgICAgICAgICBjb25zdCB7IG51bVZhbHVlcywgZGF0YVR5cGUsIHRvdGFsRmlndXJlcywgZGVjaW1hbHMgfSA9IHJldFxuICAgICAgICAgICAgICAgIGRhdGFbcmV0LnR5cGVdID0geyBudW1WYWx1ZXMsIGRhdGFUeXBlLCB0b3RhbEZpZ3VyZXMsIGRlY2ltYWxzIH1cbiAgICAgICAgICAgICAgICBpZiAoKGlucHV0ID4+IG1vZGUpICYgMHgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubW9kZSB8PSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgob3V0cHV0ID4+IG1vZGUpICYgMHgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubW9kZSB8PSAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGVzLnB1c2goZGF0YSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgbW9kZXMsIGNhcGFiaWxpdGllcyB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldFBvcnRJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9JTkZPUk1BVElPTl9SRVFVRVNULCBwb3J0SWQsIDB4MDEpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0Q21kQ2FsbGJhY2tbcG9ydElkXSA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgZ2V0UG9ydE1vZGVJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkLCBtb2RlLCB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuUE9SVF9NT0RFX0lORk9STUFUSU9OX1JFUVVFU1QsIHBvcnRJZCwgbW9kZSwgdHlwZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdID0gcmVzb2x2ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlTXNnKG1zZykge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyTGVuID0gbXNnLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIGNvbnN0IG1zZ0xlbiA9IG1zZy5nZXRVaW50OCgwKVxuICAgICAgICAgICAgY29uc3QgbXNnVHlwZSA9IG1zZy5nZXRVaW50OCgyKVxuICAgICAgICAgICAgbG9nKCdkZWNvZGVNc2cnLCB7IG1zZ1R5cGU6IE1lc3NhZ2VUeXBlTmFtZXNbbXNnVHlwZV0gfSlcbiAgICAgICAgICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSFVCX0FUVEFDSEVEX0lPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRNc2cobXNnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkdFTkVSSUNfRVJST1JfTUVTU0FHRVM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlR2VuZXJpY0Vycm9yTXNnKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVIdWJQcm9wZXJ0eVJlc3BvbnNlKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkhVQl9BTEVSVFM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSHViQWxlcnRzKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QT1JUX09VVFBVVF9DT01NQU5EX0ZFRURCQUNLOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRDb21tYW5kRmVlZGJhY2sobXNnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBPUlRfTU9ERV9JTkZPUk1BVElPTjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb3J0TW9kZUluZm9ybWF0aW9uKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QT1JUX0lORk9STUFUSU9OOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRJbmZvcm1hdGlvbihtc2cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUE9SVF9WQUxVRV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9ydFZhbHVlU2luZ2xlKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICogXG4gICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9ydFZhbHVlU2luZ2xlKG1zZykge1xuICAgICAgICAgICAgLy9sb2coJ21zZycsIG1zZylcbiAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IG1zZy5nZXRVaW50OCgzKVxuICAgICAgICAgICAgY29uc3QgbXNnTGVuID0gbXNnLmdldFVpbnQ4KDApXG4gICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgbG9nKCdoYW5kbGVQb3J0VmFsdWVTaW5nbGUnLCB7IG1zZ0xlbiwgcG9ydElkIH0pXG4gICAgICAgICAgICBkZXZpY2UuaGFuZGxlVmFsdWUobXNnKVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvcnRNb2RlSW5mb3JtYXRpb24obXNnKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBtc2cuZ2V0VWludDgoNClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IHBvcnRJZCwgbW9kZSwgdHlwZTogTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzW3R5cGVdIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZUluZm9ybWF0aW9uVHlwZS5OQU1FOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLm5hbWUgPSBhYlRvU3RyaW5nKG1zZy5idWZmZXIuc2xpY2UoNiwgbXNnLmJ5dGVMZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZUluZm9ybWF0aW9uVHlwZS5SQVc6XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlSW5mb3JtYXRpb25UeXBlLlBDVDpcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVJbmZvcm1hdGlvblR5cGUuU0k6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWluID0gbXNnLmdldEZsb2F0MzIoNiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXggPSBtc2cuZ2V0RmxvYXQzMigxMCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVJbmZvcm1hdGlvblR5cGUuU1lNQk9MOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnN5bWJvbCA9IGFiVG9TdHJpbmcobXNnLmJ1ZmZlci5zbGljZSg2LCBtc2cuYnl0ZUxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlSW5mb3JtYXRpb25UeXBlLlZBTFVFX0ZPUk1BVDpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5udW1WYWx1ZXMgPSBtc2cuZ2V0VWludDgoNilcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhVHlwZSA9IFtcIjhiaXRcIiwgXCIxNmJpdFwiLCBcIjMyYml0XCIsIFwiZmxvYXRcIl1bbXNnLmdldFVpbnQ4KDcpXVxuICAgICAgICAgICAgICAgICAgICBkYXRhLnRvdGFsRmlndXJlcyA9IG1zZy5nZXRVaW50OCg4KVxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRlY2ltYWxzID0gbXNnLmdldFVpbnQ4KDkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2coJ3BvcnRNb2RlSW5mb3JtYXRpb24nLCBkYXRhKVxuICAgICAgICAgICAgY29uc3QgY2IgPSB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYihkYXRhKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVQb3J0SW5mb3JtYXRpb24obXNnKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGxldCBjYXBhYmlsaXRpZXMgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gbXNnLmdldFVpbnQ4KDYpXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IG1zZy5nZXRVaW50MTYoNywgdHJ1ZSlcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG1zZy5nZXRVaW50MTYoOSwgdHJ1ZSlcbiAgICAgICAgICAgIGxvZyhgUG9ydCAke3BvcnRJZH0sIGNhcGFiaWxpdGllcyAke2NhcGFiaWxpdGllc30sIHRvdGFsIG1vZGVzICR7Y291bnR9LCBcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgbW9kZXMgJHtpbnB1dH0sIG91dHB1dCBtb2RlcyAke291dHB1dH1gKVxuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlQ2FwcyA9ICdvdXRwdXQsaW5wdXQsbG9naWNhbCBjb21iaW5hYmxlLCBsb2dpY2FsIHN5bmNocm9uaXNhYmxlJy5zcGxpdCgnLCcpXG4gICAgICAgICAgICBsZXQgY2FwID0gW11cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjYXBhYmlsaXRpZXMgPj4gaSkgJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcC5wdXNoKGF2YWlsYWJsZUNhcHNbaV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgcG9ydElkLCBjYXBhYmlsaXRpZXM6IGNhcC5qb2luKCcsICcpLCBjb3VudCwgaW5wdXQsIG91dHB1dCB9XG4gICAgICAgICAgICBjb25zdCBjYiA9IHRoaXMucG9ydENtZENhbGxiYWNrW3BvcnRJZF1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNiKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKiBAcmV0dXJucyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZUh1YlByb3BlcnR5UmVzcG9uc2UobXNnKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IG1zZy5nZXRVaW50OCgzKVxuICAgICAgICAgICAgbG9nKHsgcHJvcGVydHk6IEh1YlByb3BlcnR5UGF5bG9hZE5hbWVzW3Byb3BlcnR5XSB9KVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09IEh1YlByb3BlcnR5UGF5bG9hZC5CQVRURVJZX1ZPTFRBR0UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXR0ZXJ5TGV2ZWwgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgICAgICBsb2coeyBiYXR0ZXJ5TGV2ZWwgfSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2JhdHRlcnlMZXZlbCcsIHsgYmF0dGVyeUxldmVsIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PSBIdWJQcm9wZXJ0eVBheWxvYWQuQlVUVE9OX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uU3RhdGUgPSBtc2cuZ2V0VWludDgoNSlcbiAgICAgICAgICAgICAgICBsb2coeyBidXR0b25TdGF0ZSB9KVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYnV0dG9uU3RhdGUnLCB7IGJ1dHRvblN0YXRlIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PSBIdWJQcm9wZXJ0eVBheWxvYWQuU1lTVEVNX1RZUEVfSUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1UeXBlID0gbXNnLmdldFVpbnQ4KDUpXG4gICAgICAgICAgICAgICAgbG9nKHsgc3lzdGVtVHlwZSB9KVxuICAgICAgICAgICAgICAgIC8vdGhpcy5lbWl0KCdidXR0b25TdGF0ZScsIHsgYnV0dG9uU3RhdGUgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5ID09IEh1YlByb3BlcnR5UGF5bG9hZC5QUklNQVJZX01BQ19BRERSRVNTKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBbXVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2gobXNnLmdldFVpbnQ4KDUgKyBpKS50b1N0cmluZygxNikudG9Mb2NhbGVVcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2coeyBieXRlcyB9KVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYWRkcmVzcycsIHsgYWRkcmVzczogYnl0ZXMuam9pbignOicpIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVHZW5lcmljRXJyb3JNc2cobXNnKSB7XG4gICAgICAgICAgICBjb25zdCBjbWRUeXBlID0gbXNnLmdldFVpbnQ4KDMpXG4gICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBtc2cuZ2V0VWludDgoNClcbiAgICAgICAgICAgIGxvZyh7IGNtZFR5cGUsIGVycm9yQ29kZTogRXJyb3JDb2RlTmFtZXNbZXJyb3JDb2RlXSB9KVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHsgY21kVHlwZSwgZXJyb3JDb2RlOiBFcnJvckNvZGVOYW1lc1tlcnJvckNvZGVdIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZUh1YkFsZXJ0cyhtc2cpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbiA9IG1zZy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICBjb25zdCBtc2dMZW4gPSBtc2cuZ2V0VWludDgoMClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG1zZy5nZXRVaW50OCg0KVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1zZy5nZXRVaW50OCg1KVxuXG4gICAgICAgICAgICBsb2coJ2hhbmRsZUh1YkFsZXJ0cycsIHsgYnVmZmVyTGVuLCBtc2dMZW4sIHR5cGUsIG9wZXJhdGlvbiwgcGF5bG9hZCB9KVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdodWJBbGVydHMnLCB7IHR5cGUsIHBheWxvYWQgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9ydENvbW1hbmRGZWVkYmFjayhtc2cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDM7IG9mZnNldCA8IG1zZy5ieXRlTGVuZ3RoOyBvZmZzZXQgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IG1zZy5nZXRVaW50OChvZmZzZXQpXG4gICAgICAgICAgICAgICAgY29uc3QgZmVlZGJhY2sgPSBtc2cuZ2V0VWludDgob2Zmc2V0ICsgMSlcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcjaGFuZGxlUG9ydENvbW1hbmRGZWVkYmFjaycsIHsgcG9ydElkLCBmZWVkYmFjayB9KVxuICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlLmhhbmRsZUZlZWRiYWNrKGZlZWRiYWNrKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnBvcnRDbWRRdWV1ZS5zaGlmdCgpXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnIyBwcm9jZXNzIHF1ZXVlZCBjbWQnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1c3kgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVQb3J0TXNnKG1zZykge1xuXG4gICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IG1zZy5nZXRVaW50OCg0KVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGV2ZW50VHlwZSA/IG1zZy5nZXRVaW50MTYoNSwgdHJ1ZSkgOiAwXG4gICAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlTmFtZSA9IERldmljZVR5cGVOYW1lc1t0eXBlXSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gRXZlbnROYW1lc1tldmVudFR5cGVdXG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdoYW5kbGVQb3J0TXNnJywgeyBwb3J0SWQsIGV2ZW50TmFtZSwgZGV2aWNlVHlwZU5hbWUgfSlcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT0gRXZlbnQuQVRUQUNIRURfSU8pIHtcblxuICAgICAgICAgICAgICAgIGxldCBjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yTWFwW3R5cGVdXG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvciA9IERldmljZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSBuZXcgY29uc3RydWN0b3IodGhpcywgcG9ydElkLCBkZXZpY2VUeXBlTmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLmh1YkRldmljZXNbcG9ydElkXSA9IGRldmljZVxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLmVtaXQoZGV2aWNlKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhdHRhY2gnLCBkZXZpY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT0gRXZlbnQuREVUQUNIRURfSU8pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RldGFjaCcsIHsgcG9ydElkIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT0gRXZlbnQuQVRUQUNIRURfVklSVFVBTF9JTykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZDEgPSBtc2cuZ2V0VWludDgoNylcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0SWQyID0gbXNnLmdldFVpbnQ4KDgpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSBuZXcgRG91YmxlTW90b3IodGhpcywgcG9ydElkLCBnZXRWaXJ0dWFsUG9ydE5hbWUocG9ydElkMSwgcG9ydElkMikpXG4gICAgICAgICAgICAgICAgdGhpcy5odWJEZXZpY2VzW3BvcnRJZF0gPSBkZXZpY2VcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaENhbGxiYWNrcy5lbWl0KGRldmljZSlcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYXR0YWNoJywgZGV2aWNlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJCQuc2VydmljZS5yZWdpc3RlclNlcnZpY2UoJ2h1YicsIHtcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlIFxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzTW90b3IoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZSBpbnN0YW5jZW9mIE1vdG9yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlIFxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRG91YmxlTW90b3IoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZSBpbnN0YW5jZW9mIERvdWJsZU1vdG9yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlIFxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzTGVkKGRldmljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2UgaW5zdGFuY2VvZiBMZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNUYWNob01vdG9yKGRldmljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2UgaW5zdGFuY2VvZiBUYWNob01vdG9yXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEh1YkRldmljZT59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdjb25uZWN0JylcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IG5hdmlnYXRvci5ibHVldG9vdGgucmVxdWVzdERldmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdEFsbERldmljZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsU2VydmljZXM6IFtMUEYyX1NFUlZJQ0VfVVVJRF1cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaHViRGV2aWNlID0gbmV3IEh1YkRldmljZSgpXG4gICAgICAgICAgICAgICAgYXdhaXQgaHViRGV2aWNlLmluaXQoZGV2aWNlKVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGh1YkRldmljZVxuXG4gICAgICAgICAgICAgICAgLy9hd2FpdCBzZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9QUk9QRVJUSUVTLCBIdWJQcm9wZXJ0eVBheWxvYWQuQkFUVEVSWV9UWVBFLCAweDA1KVxuICAgICAgICAgICAgICAgIC8vYXdhaXQgc2VuZE1zZyhmb3JtYXRNc2coTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVMsIEh1YlByb3BlcnR5UGF5bG9hZC5CQVRURVJZX1ZPTFRBR0UsIDB4MDIpKVxuICAgICAgICAgICAgICAgIC8vYXdhaXQgc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUywgSHViUHJvcGVydHlQYXlsb2FkLkJVVFRPTl9TVEFURSwgMHgwMilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0LFxuICAgICAgICAgICAgICAgIENvbG9yLFxuICAgICAgICAgICAgICAgIFBvcnRNYXAsXG4gICAgICAgICAgICAgICAgUG9ydE1hcE5hbWVzLFxuICAgICAgICAgICAgICAgIERldmljZU1vZGUsXG4gICAgICAgICAgICAgICAgQnJha2luZ1N0eWxlLFxuICAgICAgICAgICAgICAgIERldmljZVR5cGVOYW1lcyxcbiAgICAgICAgICAgICAgICBpc01vdG9yLFxuICAgICAgICAgICAgICAgIGlzVGFjaG9Nb3RvcixcbiAgICAgICAgICAgICAgICBpc0xlZCxcbiAgICAgICAgICAgICAgICBpc0RvdWJsZU1vdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufSkoKTtcblxuXG4iXX0="}