{"version":3,"sources":["../../../../node_modules/browser-pack/_prelude.js","lib/CallbackEmitter.js","lib/Const.js","lib/Device.js","lib/DoubleMotor.js","lib/Led.js","lib/Motor.js","lib/RgbLed.js","lib/TachoMotor.js","lib/TiltSensor.js","lib/Util.js","lib/hub.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hub.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","class CallbackEmitter {\n    constructor() {\n        this.callbacks = []\n    }\n\n    /**\n     * \n     * @param {(data) => boolean} callback \n     */\n    on(callback) {\n        this.callbacks.push(callback)\n    }\n\n    emit(data) {\n        let i = this.callbacks.length\n\n        while (i--) {\n            const callback = this.callbacks[i]\n            if (callback(data)) {\n                this.callbacks.splice(i, 1)\n            }\n        }\n    }\n}\n\nmodule.exports = CallbackEmitter","//@ts-check\n\nconst { getEnumName } = $$.util\n\nconst Event = {\n    DETACHED_IO: 0x00,\n    ATTACHED_IO: 0x01,\n    ATTACHED_VIRTUAL_IO: 0x02,\n}\nconst EventNames = getEnumName(Event)\n\nconst HubAlertType = {\n    LOW_VOLTAGE: 0x01,\n    HIGH_CURRENT: 0x02,\n    LOW_SIGNAL_STRENGTH: 0x03,\n    OVER_POWER_CONDITION: 0x04\n}\n\nconst MessageType = {\n    HUB_PROPERTIES: 0x01,\n    HUB_ACTIONS: 0x02,\n    HUB_ALERTS: 0x03,\n    HUB_ATTACHED_IO: 0x04,\n    GENERIC_ERROR_MESSAGES: 0x05,\n    HW_NETWORK_COMMANDS: 0x08,\n    FW_UPDATE_GO_INTO_BOOT_MODE: 0x10,\n    FW_UPDATE_LOCK_MEMORY: 0x11,\n    FW_UPDATE_LOCK_STATUS_REQUEST: 0x12,\n    FW_LOCK_STATUS: 0x13,\n    PORT_INFORMATION_REQUEST: 0x21,\n    PORT_MODE_INFORMATION_REQUEST: 0x22,\n    PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,\n    PORT_INPUT_FORMAT_SETUP_COMBINEDMODE: 0x42,\n    PORT_INFORMATION: 0x43,\n    PORT_MODE_INFORMATION: 0x44,\n    PORT_VALUE_SINGLE: 0x45,\n    PORT_VALUE_COMBINEDMODE: 0x46,\n    PORT_INPUT_FORMAT_SINGLE: 0x47,\n    PORT_INPUT_FORMAT_COMBINEDMODE: 0x48,\n    VIRTUAL_PORT_SETUP: 0x61,\n    PORT_OUTPUT_COMMAND: 0x81,\n    PORT_OUTPUT_COMMAND_FEEDBACK: 0x82,\n}\n\n\n\nconst MessageTypeNames = getEnumName(MessageType)\n\nconst DeviceType = {\n    UNKNOWN: 0,\n    SIMPLE_MEDIUM_LINEAR_MOTOR: 1,\n    TRAIN_MOTOR: 2,\n    LIGHT: 8,\n    VOLTAGE_SENSOR: 20,\n    CURRENT_SENSOR: 21,\n    PIEZO_BUZZER: 22,\n    HUB_LED: 23,\n    TILT_SENSOR: 34,\n    MOTION_SENSOR: 35,\n    COLOR_DISTANCE_SENSOR: 37,\n    MEDIUM_LINEAR_MOTOR: 38,\n    MOVE_HUB_MEDIUM_LINEAR_MOTOR: 39,\n    MOVE_HUB_TILT_SENSOR: 40,\n    DUPLO_TRAIN_BASE_MOTOR: 41,\n    DUPLO_TRAIN_BASE_SPEAKER: 42,\n    DUPLO_TRAIN_BASE_COLOR_SENSOR: 43,\n    DUPLO_TRAIN_BASE_SPEEDOMETER: 44,\n    TECHNIC_LARGE_LINEAR_MOTOR: 46, // Technic Control+\n    TECHNIC_XLARGE_LINEAR_MOTOR: 47, // Technic Control+\n    TECHNIC_MEDIUM_ANGULAR_MOTOR: 48, // Spike Prime\n    TECHNIC_LARGE_ANGULAR_MOTOR: 49, // Spike Prime\n    TECHNIC_MEDIUM_HUB_GEST_SENSOR: 54,\n    REMOTE_CONTROL_BUTTON: 55,\n    REMOTE_CONTROL_RSSI: 56,\n    TECHNIC_MEDIUM_HUB_ACCELEROMETER: 57,\n    TECHNIC_MEDIUM_HUB_GYRO_SENSOR: 58,\n    TECHNIC_MEDIUM_HUB_TILT_SENSOR: 59,\n    TECHNIC_MEDIUM_HUB_TEMPERATURE_SENSOR: 60,\n    TECHNIC_COLOR_SENSOR: 61, // Spike Prime\n    TECHNIC_DISTANCE_SENSOR: 62, // Spike Prime\n    TECHNIC_FORCE_SENSOR: 63, // Spike Prime\n    TECHNIC_3X3_COLOR_LIGHT_MATRIX: 64, // Spike Essential\n    TECHNIC_SMALL_ANGULAR_MOTOR: 65, // Spike Essential\n    MARIO_ACCELEROMETER: 71,\n    MARIO_BARCODE_SENSOR: 73,\n    MARIO_PANTS_SENSOR: 74,\n    TECHNIC_MEDIUM_ANGULAR_MOTOR_GREY: 75, // Mindstorms\n    TECHNIC_LARGE_ANGULAR_MOTOR_GREY: 76, // Technic Control+\n    VIRTUAL_DEVICE: 100\n}\n\nconst DeviceTypeNames = getEnumName(DeviceType)\n\nconst ErrorCode = {\n    ACK: 0x01,\n    MACK: 0x02,\n    BUFFER_OVERFLOW: 0x03,\n    TIMEOUT: 0x04,\n    COMMAND_NOT_RECOGNIZED: 0x05,\n    INVALID_USE: 0x06,\n    OVERCURRENT: 0x07,\n    INTERNAL_ERROR: 0x08,\n}\n\nconst ErrorCodeNames = getEnumName(ErrorCode)\n\n\nconst HubPropertyPayload = {\n    ADVERTISING_NAME: 0x01,\n    BUTTON_STATE: 0x02,\n    FW_VERSION: 0x03,\n    HW_VERSION: 0x04,\n    RSSI: 0x05,\n    BATTERY_VOLTAGE: 0x06,\n    BATTERY_TYPE: 0x07,\n    MANUFACTURER_NAME: 0x08,\n    RADIO_FIRMWARE_VERSION: 0x09,\n    LWP_PROTOCOL_VERSION: 0x0A,\n    SYSTEM_TYPE_ID: 0x0B,\n    HW_NETWORK_ID: 0x0C,\n    PRIMARY_MAC_ADDRESS: 0x0D,\n    SECONDARY_MAC_ADDRESS: 0x0E,\n    HW_NETWORK_FAMILY: 0x0F\n}\n\nconst HubPropertyPayloadNames = getEnumName(HubPropertyPayload)\n\nconst ModeInformationType = {\n    NAME: 0x00,\n    RAW: 0x01,\n    PCT: 0x02,\n    SI: 0x03,\n    SYMBOL: 0x04,\n    MAPPING: 0x05,\n    USED_INTERNALLY: 0x06,\n    MOTOR_BIAS: 0x07,\n    CAPABILITY_BITS: 0x08,\n    VALUE_FORMAT: 0x80,\n}\n\nconst ModeInformationTypeNames = getEnumName(ModeInformationType)\n\nconst PortMap = {\n    \"A\": 0,\n    \"B\": 1,\n    \"C\": 2,\n    \"D\": 3,\n    \"HUB_LED\": 50,\n    \"CURRENT_SENSOR\": 59,\n    \"VOLTAGE_SENSOR\": 60,\n    \"ACCELEROMETER\": 97,\n    \"GYRO_SENSOR\": 98,\n    \"TILT_SENSOR\": 99\n}\n\nconst DeviceMode = {\n    POWER: 0x00,\n    SPEED: 0x01,\n    ROTATION: 0x02,\n    ABSOLUTE: 0x03,\n    COLOR: 0x00,\n    RGB: 0x01,\n    TILT_POS: 0x00\n}\n\nconst BrakingStyle = {\n    FLOAT: 0,\n    HOLD: 126,\n    BRAKE: 127\n}\n\nconst PortMapNames = getEnumName(PortMap)\n\nmodule.exports = {\n    MessageType,\n    MessageTypeNames,\n    Event,\n    EventNames,\n    BrakingStyle,\n    DeviceMode,\n    DeviceType,\n    DeviceTypeNames,\n    ModeInformationType,\n    ModeInformationTypeNames,\n    PortMap,\n    PortMapNames,\n    HubPropertyPayload,\n    HubPropertyPayloadNames,\n    ErrorCodeNames\n}","//@ts-check\n\nconst CallbackEmitter = require('./CallbackEmitter')\nconst {MessageType, PortMapNames} = require('./Const')\nconst {log, toUint32} = require('./Util')\n\nclass Device {\n    /**\n     * \n     * @param {HUB.HubDevice} hubDevice \n     * @param {number} portId \n     * @param {string} type \n     */\n    constructor(hubDevice, portId, type) {\n        this.hubDevice = hubDevice\n        this.portId = portId\n        this.type = type\n        this.name = PortMapNames[portId]\n        this.feedbackCallback = null\n        this.valueCallbacks = new CallbackEmitter()\n        this.mode = undefined\n        this.modes = undefined\n        this.capabilities = undefined\n    }\n\n    async writePortCommand(waitFeedback, ...data) {\n\n        log('writePortCommand', this.portId, { waitFeedback, data })\n\n        if (waitFeedback) {\n\n            return new Promise(async (resolve) => {\n\n                await this.hubDevice.sendMsg(MessageType.PORT_OUTPUT_COMMAND, this.portId, 0x11, data)\n\n                this.feedbackCallback = resolve\n            })\n        }\n        else {\n            return this.hubDevice.sendMsg(MessageType.PORT_OUTPUT_COMMAND, this.portId, 0x10, data)\n        }\n\n    }\n\n    /**\n     * \n     * @param {number} mode\n     * @param {boolean} waitFeedback \n     * @param  {...any} data \n     * @returns \n     */\n    writeDirectMode(mode, waitFeedback, ...data) {\n        log('writeDirectMode', this.portId, {mode, waitFeedback })\n        return this.writePortCommand(waitFeedback, 0x51, mode, data)\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @param {boolean} notificationEnabled \n     * @param {number} deltaInterval \n     * @returns \n     */\n    setMode(mode, notificationEnabled, deltaInterval = 1) {\n        console.log('setMode', this.portId, { mode, notificationEnabled })\n\n        this.mode = mode\n\n        return this.hubDevice.sendMsg(MessageType.PORT_INPUT_FORMAT_SETUP_SINGLE,\n            this.portId, mode, toUint32(deltaInterval), notificationEnabled ? 0x01 : 0)\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        if (this.modes != undefined) {\n            const {VALUE_FORMAT, RAW, SI} = this.modes[this.mode]\n            const range = $$.util.mapRange(RAW.min, RAW.max, SI.min, SI.max)\n            log('info', this.modes[this.mode])\n            const {dataType, numValues} = VALUE_FORMAT\n            const ret = []\n            let offset = 4\n            let val\n            for(let idx = 0; idx < numValues; idx++) {\n                switch(dataType) {\n                    case '16bit':\n                        val = msg.getInt16(offset, true)\n                        offset += 2\n                        break;\n                    case '8bit':\n                        val = msg.getInt8(offset)\n                        offset += 1\n                        break;\n                    case '32bit':\n                        val = msg.getInt32(offset, true)\n                        offset += 4\n                        break;\n                    case 'float':\n                        val = msg.getFloat32(offset, true)\n                        offset += 4\n                        break;    \n\n                }\n                log('val', val)\n                ret.push(Math.trunc(range(val)))\n            }\n            return ret\n\n        }\n    }\n    /**\n     * \n     * @param {DataView} msg \n     */\n    handleValue(msg) {\n        log('handleValue', this.portId, msg)\n        let value = this.decodeValue(msg)\n\n        if (value != undefined) {\n            this.valueCallbacks.emit(value)\n        }\n    }\n\n    handleFeedback() {\n        if (typeof this.feedbackCallback == 'function') {\n            this.feedbackCallback()\n        }\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @returns \n    */\n    async getValue(mode) {\n        console.log('getValue', this.portId, { mode })\n        if (this.modes == undefined) {\n            const {modes, capabilities} = await this.hubDevice.getPortInformation(this.portId)\n            this.modes = modes\n            this.capabilities = capabilities\n        }\n        await this.setMode(mode, false)\n        return new Promise(async (resolve) => {\n            this.valueCallbacks.on((data) => {\n                resolve(data)\n                return true\n            })\n            await this.hubDevice.sendMsg(MessageType.PORT_INFORMATION_REQUEST, this.portId, 0x00)\n\n        })\n    }\n\n    /**\n     * \n     * @param {number} mode \n     * @param {(data) => boolean} testFn \n     * @returns \n     */\n    async waitTestValue(mode, testFn) {\n        return new Promise(async (resolve) => {\n            await this.setMode(mode, true)\n            this.valueCallbacks.on(async (value) => {\n                log('waitTestValue', value)\n                if (testFn(value)) {\n                    log('waitTestValue OK')\n                    await this.setMode(mode, false)\n                    resolve()\n                    return true\n                }\n                return false\n            })\n                \n        })\n    }\n\n    async subscribe(mode, cbk, deltaInterval = 1) {\n        await this.setMode(mode, true, deltaInterval)\n        this.valueCallbacks.on((data) => {\n            cbk(data)\n            return false\n        })\n    }\n}\n\nmodule.exports = Device","//@ts-check\n\nconst Motor = require('./Motor')\nconst {BrakingStyle} = require('./Const')\nconst {toInt16, toInt32} = require('./Util')\n\nconst maxPower = 100\n\nclass DoubleMotor extends Motor {\n\n\n    constructor(hubDevice, portId, name) {\n        super(hubDevice, portId, 'Virtual Device')\n        this.name = name\n\n    }\n\n    /**\n     * \n     * @param {number} speed1 \n     * @param {number} speed2 \n     * @returns \n     */\n    setSpeed(speed1, speed2) {\n        return this.writePortCommand(false, 0x08, speed1, speed2, maxPower, 0)\n    }\n\n    setSpeedForTime(speed1, speed2, time, waitFeedback = false, brakingStyle = BrakingStyle.BRAKE) {\n\n        console.log('setSpeedForTime', this.portId, { speed1, speed2, time, waitFeedback, brakingStyle })\n        return this.writePortCommand(this.portId, waitFeedback, 0x0A, toInt16(time), speed1, speed2, maxPower, brakingStyle)\n    }\n\n    rotateDegrees(degrees, speed1, speed2, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('rotateDegrees', this.portId, { degrees, speed1, speed2, waitFeedback, brakingStyle })\n        return this.writePortCommand(waitFeedback, 0x0C, toInt32(degrees), speed1, speed2, maxPower, brakingStyle)\n    }\n\n    gotoAngle(angle1, angle2, speed, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('gotoAngle', this.portId, { angle1, angle2, speed, waitFeedback, brakingStyle })\n\n        return this.writePortCommand(waitFeedback, 0x0E, toInt32(angle1), toInt32(angle2), speed, maxPower, brakingStyle)\n    }\n}\n\nmodule.exports = DoubleMotor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass Led extends Device {\n\n    /**\n    * \n    * @param {HubDevice} hubDevice \n    * @param {number} portId \n    */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n\n    }\n\n    setBrightness(brightness) {\n        console.log('setBrightness', this.portId, { brightness })\n        return this.writeDirectMode(DeviceMode.POWER, false, brightness)\n    }\n\n\n}\n\nmodule.exports = Led","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nconst maxPower = 100\n\nclass Motor extends Device {\n\n    /**\n     * \n     * @param {HubDevice} hubDevice \n     * @param {number} portId \n     */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    setPower(power) {\n        console.log('setPower', this.portId, { power })\n        return this.writeDirectMode(DeviceMode.POWER, false, power)\n    }\n\n\n}\n\nmodule.exports = Motor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass RgbLed extends Device {\n\n    /**\n    * \n    * @param {HubDevice} hubDevice \n    * @param {number} portId \n    */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n\n    }\n\n    async setColor(color) {\n        console.log('setColor', this.portId, { color })\n        await this.setMode(DeviceMode.COLOR, false)\n        return this.writeDirectMode(DeviceMode.COLOR, false, color)\n    }\n\n    async setRGBColor(r, g, b) {\n        console.log('setColor', this.portId, { r, g, b })\n        await this.setMode(DeviceMode.RGB, false)\n        return this.writeDirectMode(DeviceMode.RGB, false, r, g, b)\n    }\n}\n\nmodule.exports = RgbLed","//@ts-check\n\nconst Motor = require('./Motor')\nconst {PortMapNames, DeviceMode, BrakingStyle} = require('./Const')\nconst {toInt32, toInt16} = require('./Util')\n\nconst maxPower = 100\n\nclass TachoMotor extends Motor {\n\n    /**\n     * \n     * @param {HubDevice} hubDevice \n     * @param {number} portId \n     */\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    setSpeed(speed) {\n        console.log('setSpeed', this.portId, { speed })\n        return this.writePortCommand(false, 0x07, speed, maxPower, 0)\n    }\n\n    rotateDegrees(degrees, speed, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('rotateDegrees', this.portId, { degrees, speed, waitFeedback, brakingStyle })\n        return this.writePortCommand(waitFeedback, 0x0B, toInt32(degrees), speed, maxPower, brakingStyle)\n    }\n\n    /**\n     * \n     * @param {number} angle \n     * @param {number} speed \n     * @param {boolean} waitFeedback \n     * @param {number} brakingStyle \n     * @returns \n     */\n    gotoAngle(angle, speed, waitFeedback, brakingStyle = BrakingStyle.BRAKE) {\n        console.log('gotoAngle', this.portId, { angle, speed, waitFeedback, brakingStyle })\n\n        if (this.calibrationValue) {\n            angle *= this.calibrationValue\n        }\n\n        return this.writePortCommand(waitFeedback, 0x0D, toInt32(angle), speed, maxPower, brakingStyle)\n    }\n\n    setSpeedForTime(speed, time, waitFeedback = false, brakingStyle = BrakingStyle.BRAKE) {\n\n        console.log('setSpeedForTime', this.portId, { speed, time, waitFeedback, brakingStyle })\n        return this.writePortCommand(waitFeedback, 0x09, toInt16(time), speed, maxPower, brakingStyle)\n    }\n\n    resetZero() {\n        console.log('resetZero', this.portId)\n        return this.writeDirectMode(DeviceMode.ROTATION, true, 0x00, 0x00, 0x00, 0x00)\n    }\n\n    getSpeed() {\n        return this.getValue(DeviceMode.SPEED)\n    }\n\n    getPosition() {\n        return this.getValue(DeviceMode.ROTATION)\n    }\n\n    getAbsolutePosition() {\n        return this.getValue(DeviceMode.ABSOLUTE)\n    }\n\n    async calibrate() {\n\n        console.log('calibrate', this.portId)\n        this.setPower(50)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value > 10)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value == 0)\n\n\n        this.setPower(0)\n\n        await $$.util.wait(1000)\n\n        // await this.hubDevice.setPortFormat(this.portId, DeviceMode.ROTATION)\n        // let value = await this.hubDevice.getPortValue(this.portId)\n        // console.log(value)\t\n\n        await this.resetZero()\n\n\n        this.setPower(-50)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => Math.abs(value) > 10)\n        await this.waitTestValue(DeviceMode.SPEED, (value) => value == 0)\n\n        this.setPower(0)\n        const value = await this.getValue(DeviceMode.ROTATION)\n        console.log(value)\n        const offset = Math.floor(value / 2)\n        console.log({ offset })\n        await this.gotoAngle(offset, 10, true)\n        await this.resetZero()\n        this.calibrationValue = Math.abs(offset)\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        let value\n        switch (this.mode) {\n            case DeviceMode.ABSOLUTE:\n                value = msg.getInt16(4, true)\n                break\n            case DeviceMode.ROTATION:\n                value = msg.getInt32(4, true)\n                break\n            case DeviceMode.SPEED:\n                value = msg.getInt8(4)\n                break\n\n        }\n        return value\n    }\n\n}\n\nmodule.exports = TachoMotor","//@ts-check\n\nconst Device = require('./Device')\nconst {PortMapNames, DeviceMode} = require('./Const')\n\nclass TiltSensor extends Device {\n    constructor(hubDevice, portId, type) {\n        super(hubDevice, portId, type)\n    }\n\n    /**\n     * \n     * @param {DataView} msg \n     */\n    decodeValue(msg) {\n        let value\n        switch (this.mode) {\n            case DeviceMode.TILT_POS:\n                value = {\n                    yaw: msg.getInt16(4, true),\n                    pitch: msg.getInt16(6, true),\n                    roll: msg.getInt16(8, true)\n                }\n                break\n            default:\n                value = super.decodeValue(msg)\n                break\n        }\n        return value\n    }\n}\n\nmodule.exports = TiltSensor\n","//@ts-check\n\n/**\n  * \n  * @param {number} val \n  * @returns {Array}\n  */\nfunction toInt16(val) {\n    const buff = new Uint8Array(2)\n    const view = new DataView(buff.buffer)\n    view.setInt16(0, val, true)\n    return Array.from(buff)\n}\n\n/**\n * \n * @param {number} val \n * @returns {Array}\n */\nfunction toInt32(val) {\n    const buff = new Uint8Array(4)\n    const view = new DataView(buff.buffer)\n    view.setInt32(0, val, true)\n    return Array.from(buff)\n}\n\nfunction toUint32(val) {\n    const buff = new Uint8Array(4)\n    const view = new DataView(buff.buffer)\n    view.setUint32(0, val, true)\n    return Array.from(buff)\n}\n\nconst debug = false\n\nconst log = function (...data) {\n    if (debug) {\n        console.log.apply(console, data)\n    }\n}\n\nmodule.exports = {\n    toInt16,\n    toInt32,\n    toUint32,\n    log\n}","//@ts-check\n\n\n(function () {\n\n    const CallbackEmitter = require('./CallbackEmitter')\n    const { EventNames, DeviceMode, DeviceTypeNames, BrakingStyle, PortMap, HubPropertyPayloadNames, ModeInformationTypeNames, Event, DeviceType, PortMapNames, MessageType, HubPropertyPayload, ModeInformationType, ErrorCodeNames, MessageTypeNames } = require('./Const')\n    const Motor = require('./Motor')\n    const DoubleMotor = require('./DoubleMotor')\n    const TachoMotor = require('./TachoMotor');\n    const Device = require('./Device')\n    const RgbLed = require('./RgbLed')\n    const Led = require('./Led')\n    const TiltSensor = require('./TiltSensor')\n    const { log } = require('./Util')\n\n    const Color = {\n        BLACK: 0,\n        PINK: 1,\n        PURPLE: 2,\n        BLUE: 3,\n        LIGHT_BLUE: 4,\n        CYAN: 5,\n        GREEN: 6,\n        YELLOW: 7,\n        ORANGE: 8,\n        RED: 9,\n        WHITE: 10,\n        NONE: 255\n    }\n\n    const LPF2_SERVICE_UUID = '00001623-1212-efde-1623-785feabcd123'\n    const LPF2_CHARAC_UUID = '00001624-1212-efde-1623-785feabcd123'\n\n\n    /**\n     * \n     * @param {ArrayBuffer} buf \n     */\n    function abToString(buf) {\n        const uint8buff = new Uint8Array(buf)\n        let ret = \"\"\n        for (let i = 0; i < uint8buff.byteLength && uint8buff[i] != 0; i++) {\n            ret += String.fromCharCode(uint8buff[i])\n        }\n        return ret\n    }\n\n\n\n\n    /**\n     * \n     * @param  {...any} data \n     * @returns {ArrayBuffer}\n     */\n    function formatMsg(msgType, ...data) {\n        const buff = data.flat(3)\n        const msgLen = buff.length + 3\n        const buffer = new ArrayBuffer(msgLen)\n        const uint8Buffer = new Uint8Array(buffer)\n        uint8Buffer[0] = msgLen\n        uint8Buffer[1] = 0\n        uint8Buffer[2] = msgType\n        uint8Buffer.set(buff, 3)\n        return buffer\n    }\n\n\n    function getVirtualPortName(portId1, portId2) {\n        const portIdA = PortMapNames[portId1]\n        const portIdB = PortMapNames[portId2]\n        return `${portIdA}_${portIdB}`\n    }\n\n    const constructorMap = {\n        [DeviceType.TECHNIC_LARGE_LINEAR_MOTOR]: TachoMotor,\n        [DeviceType.TECHNIC_LARGE_ANGULAR_MOTOR_GREY]: TachoMotor,\n        [DeviceType.TECHNIC_XLARGE_LINEAR_MOTOR]: TachoMotor,\n        [DeviceType.TECHNIC_MEDIUM_HUB_TILT_SENSOR]: TiltSensor,\n        [DeviceType.HUB_LED]: RgbLed,\n        [DeviceType.LIGHT]: Led\n    }\n\n    /**@implements HUB.HubDevice */\n    class HubDevice extends EventEmitter2 {\n\n        constructor() {\n            super()\n            this.charac = null\n            this.portCmdQueue = {}\n            this.portCmdCallback = {}\n            /**@type {{[portId: string]: Device}} */\n            this.hubDevices = {}\n            this.busy = false\n            this.cmdQueue = []\n            this.attachCallbacks = new CallbackEmitter()\n        }\n\n        /**\n         * \n         * @param {BluetoothDevice} device \n         */\n        async init(device) {\n\n            const server = await device.gatt.connect()\n            log('Connected')\n            const service = await server.getPrimaryService(LPF2_SERVICE_UUID)\n            this.charac = await service.getCharacteristic(LPF2_CHARAC_UUID)\n\n            const onCharacteristicvaluechanged = (event) => {\n                this.decodeMsg(event.target.value)\n            }\n\n            device.addEventListener('gattserverdisconnected', () => {\n                console.log('onGattServerDisconnected', this)\n                this.charac.removeEventListener('characteristicvaluechanged', onCharacteristicvaluechanged)\n\n                this.charac = null\n                this.emit('disconnected')\n            })\n\n            this.charac.addEventListener('characteristicvaluechanged', onCharacteristicvaluechanged)\n            await this.charac.startNotifications()\n            await $$.util.wait(100)\n        }\n\n        async startNotification() {\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_VOLTAGE, 0x02)\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.SYSTEM_TYPE_ID, 0x05)\n            await this.sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.PRIMARY_MAC_ADDRESS, 0x05)\n            await this.sendMsg(MessageType.HUB_ALERTS, 0x01, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x02, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x03, 0x01)\n            // await this.sendMsg(MessageType.HUB_ALERTS, 0x04, 0x01)\n\n        }\n\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<Motor>}\n         */\n        getMotor(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof Motor) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<Motor>}\n         */\n        getTachoMotor(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof TachoMotor) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n\n\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<TiltSensor>}\n         */\n        getTiltSensor(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof TiltSensor) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n\n        }\n\n        getRgbLed(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof RgbLed) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n\n        getLed(portId) {\n            return new Promise((resolve, reject) => {\n                const device = this.hubDevices[portId]\n                if (device) {\n                    if (device instanceof Led) {\n                        resolve(device)\n                    }\n                    else {\n                        reject()\n                    }\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.portId == portId) {\n                            log(`device on portId ${portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n                }\n            })\n        }\n        async getDblMotor(portId1, portId2) {\n            return new Promise(async (resolve) => {\n                const name = getVirtualPortName(portId1, portId2)\n                const device = Object.values(this.hubDevices).find((d) => d.name == name)\n                if (device) {\n                    resolve(device)\n\n                }\n                else {\n                    this.attachCallbacks.on((device) => {\n                        if (device.name == name) {\n                            console.log(`device on portId ${device.portId} is ready`)\n                            resolve(device)\n                            return true\n                        }\n                        return false\n                    })\n\n                    await this.createVirtualPort(portId1, portId2)\n                }\n            })\n        }\n\n        /**\n         * \n         * @param  {ArrayBuffer} buffer \n         */\n        async sendBuffer(buffer) {\n            console.log('sendBuffer', buffer)\n            if (!this.busy) {\n                this.busy = true\n                await this.charac.writeValueWithoutResponse(buffer)\n                this.busy = false\n                if (this.cmdQueue.length > 0) {\n                    await this.sendBuffer(this.cmdQueue.shift())\n                }\n\n            }\n            else {\n                console.log('busy! push in queue')\n                this.cmdQueue.push(buffer)\n            }\n\n        }\n\n        /**\n         * \n         * @param {number} msgType\n         * @param  {...any} data \n         */\n        sendMsg(msgType, ...data) {\n            log('sendMsg', MessageTypeNames[msgType], data)\n            return this.sendBuffer(formatMsg(msgType, data))\n        }\n\n        /**\n         * \n         * @param {string} name \n         * @returns {number}\n         */\n        getPortIdFromName(name) {\n            for (const info of Object.values(this.hubDevices)) {\n                if (info.name == name) {\n                    return info.portId\n                }\n            }\n        }\n\n        /**\n         * @param {number} portId1\n         * @param {number} portId2\n         */\n        createVirtualPort(portId1, portId2) {\n\n            return this.sendMsg(MessageType.VIRTUAL_PORT_SETUP, 0x01, portId1, portId2)\n        }\n\n        shutdown() {\n            return this.sendMsg(MessageType.HUB_ACTIONS, 0x01)\n        }\n\n\n        getHubDevices() {\n            return Object.values(this.hubDevices)\n        }\n\n        getDeviceType(portId) {\n            return this.hubDevices[portId].type\n        }\n\n        getDevice(portId) {\n            return this.hubDevices[portId]\n        }\n\n        /**\n         * \n         * @param {number} portId \n         * @returns {Promise<HUB.PortInformation>}\n         */\n        async getPortInformation(portId) {\n            let { modes, capabilities } = this.hubDevices[portId]\n            if (modes != undefined || capabilities != undefined) {\n                return { modes, capabilities }\n            }\n            const portInfo = await this.getPortInformationRequest(portId)\n            const { count, output, input } = portInfo\n            capabilities = portInfo.capabilities\n            modes = []\n            for (let mode = 0; mode < count; mode++) {\n                const data = {}\n                let ret\n                data.mode = 0\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.NAME)\n                data.name = ret.name\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.RAW)\n                data[ret.type] = { min: ret.min, max: ret.max }\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.SI)\n                data[ret.type] = { min: ret.min, max: ret.max }\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.SYMBOL)\n                data.unit = ret.symbol\n                ret = await this.getPortModeInformationRequest(portId, mode, ModeInformationType.VALUE_FORMAT)\n                const { numValues, dataType, totalFigures, decimals } = ret\n                data[ret.type] = { numValues, dataType, totalFigures, decimals }\n                if ((input >> mode) & 0x1) {\n                    data.mode |= 1\n                }\n                if ((output >> mode) & 0x1) {\n                    data.mode |= 2\n                }\n                modes.push(data)\n            }\n            this.hubDevices[portId].modes = modes\n            this.hubDevices[portId].capabilities = capabilities\n\n            return { modes, capabilities }\n        }\n\n\n        getPortInformationRequest(portId) {\n            return new Promise(async (resolve) => {\n                await this.sendMsg(MessageType.PORT_INFORMATION_REQUEST, portId, 0x01)\n                this.portCmdCallback[portId] = resolve\n            })\n        }\n\n\n\n        getPortModeInformationRequest(portId, mode, type) {\n            return new Promise(async (resolve) => {\n                await this.sendMsg(MessageType.PORT_MODE_INFORMATION_REQUEST, portId, mode, type)\n                this.portCmdCallback[portId] = resolve\n            })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        decodeMsg(msg) {\n            const bufferLen = msg.byteLength\n            const msgLen = msg.getUint8(0)\n            const msgType = msg.getUint8(2)\n            log('decodeMsg', { msgType: MessageTypeNames[msgType] })\n            switch (msgType) {\n                case MessageType.HUB_ATTACHED_IO:\n                    this.handlePortMsg(msg)\n                    break;\n                case MessageType.GENERIC_ERROR_MESSAGES:\n                    this.handleGenericErrorMsg(msg)\n                    break;\n                case MessageType.HUB_PROPERTIES:\n                    this.handleHubPropertyResponse(msg)\n                    break\n                case MessageType.HUB_ALERTS:\n                    this.handleHubAlerts(msg);\n                    break\n                case MessageType.PORT_OUTPUT_COMMAND_FEEDBACK:\n                    this.handlePortCommandFeedback(msg)\n                    break;\n                case MessageType.PORT_MODE_INFORMATION:\n                    this.handlePortModeInformation(msg)\n                    break;\n                case MessageType.PORT_INFORMATION:\n                    this.handlePortInformation(msg)\n                    break;\n                case MessageType.PORT_VALUE_SINGLE:\n                    this.handlePortValueSingle(msg)\n                    break;\n            }\n        }\n\n\n        /**\n          * \n          * @param {DataView} msg \n          */\n        handlePortValueSingle(msg) {\n            //log('msg', msg)\n            const portId = msg.getUint8(3)\n            const msgLen = msg.getUint8(0)\n            const device = this.hubDevices[portId]\n            log('handlePortValueSingle', { msgLen, portId })\n            device.handleValue(msg)\n        }\n\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortModeInformation(msg) {\n            const portId = msg.getUint8(3)\n            const mode = msg.getUint8(4)\n            const type = msg.getUint8(5)\n            const data = { portId, mode, type: ModeInformationTypeNames[type] }\n            switch (type) {\n                case ModeInformationType.NAME:\n                    data.name = abToString(msg.buffer.slice(6, msg.byteLength))\n                    break\n                case ModeInformationType.RAW:\n                case ModeInformationType.PCT:\n                case ModeInformationType.SI:\n                    data.min = msg.getFloat32(6, true)\n                    data.max = msg.getFloat32(10, true)\n                    break\n                case ModeInformationType.SYMBOL:\n                    data.symbol = abToString(msg.buffer.slice(6, msg.byteLength))\n                    break\n                case ModeInformationType.VALUE_FORMAT:\n                    data.numValues = msg.getUint8(6)\n                    data.dataType = [\"8bit\", \"16bit\", \"32bit\", \"float\"][msg.getUint8(7)]\n                    data.totalFigures = msg.getUint8(8)\n                    data.decimals = msg.getUint8(9)\n                    break\n            }\n            log('portModeInformation', data)\n            const cb = this.portCmdCallback[portId]\n            if (typeof cb == 'function') {\n                cb(data)\n                delete this.portCmdCallback[portId]\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortInformation(msg) {\n            const portId = msg.getUint8(3)\n            let capabilities = msg.getUint8(5)\n            const count = msg.getUint8(6)\n            const input = msg.getUint16(7, true)\n            const output = msg.getUint16(9, true)\n            log(`Port ${portId}, capabilities ${capabilities}, total modes ${count}, \n                    input modes ${input}, output modes ${output}`)\n            const availableCaps = 'output,input,logical combinable, logical synchronisable'.split(',')\n            let cap = []\n            for (let i = 0; i < 4; i++) {\n                if ((capabilities >> i) & 1) {\n                    cap.push(availableCaps[i])\n                }\n            }\n            const data = { portId, capabilities: cap.join(', '), count, input, output }\n            const cb = this.portCmdCallback[portId]\n            if (typeof cb == 'function') {\n                cb(data)\n            }\n        }\n\n\n        /**\n         * \n         * @param {DataView} msg \n         * @returns \n         */\n        handleHubPropertyResponse(msg) {\n            const property = msg.getUint8(3)\n            log({ property: HubPropertyPayloadNames[property] })\n            if (property == HubPropertyPayload.BATTERY_VOLTAGE) {\n                const batteryLevel = msg.getUint8(5)\n                log({ batteryLevel })\n                this.emit('batteryLevel', { batteryLevel })\n            }\n            else if (property == HubPropertyPayload.BUTTON_STATE) {\n                const buttonState = msg.getUint8(5)\n                log({ buttonState })\n                this.emit('buttonState', { buttonState })\n            }\n            else if (property == HubPropertyPayload.SYSTEM_TYPE_ID) {\n                const systemType = msg.getUint8(5)\n                log({ systemType })\n                //this.emit('buttonState', { buttonState })\n            }\n            else if (property == HubPropertyPayload.PRIMARY_MAC_ADDRESS) {\n                const bytes = []\n                for (let i = 0; i < 6; i++) {\n                    bytes.push(msg.getUint8(5 + i).toString(16).toLocaleUpperCase().padStart(2, '0'))\n                }\n                log({ bytes })\n                this.emit('address', { address: bytes.join(':') })\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handleGenericErrorMsg(msg) {\n            const cmdType = msg.getUint8(3)\n            const errorCode = msg.getUint8(4)\n            log({ cmdType, errorCode: ErrorCodeNames[errorCode] })\n            this.emit('error', { cmdType, errorCode: ErrorCodeNames[errorCode] })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handleHubAlerts(msg) {\n            const bufferLen = msg.byteLength\n            const msgLen = msg.getUint8(0)\n            const type = msg.getUint8(3)\n            const operation = msg.getUint8(4)\n            const payload = msg.getUint8(5)\n\n            log('handleHubAlerts', { bufferLen, msgLen, type, operation, payload })\n            this.emit('hubAlerts', { type, payload })\n        }\n\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortCommandFeedback(msg) {\n            for (let offset = 3; offset < msg.byteLength; offset += 2) {\n                const portId = msg.getUint8(offset)\n                const feedback = msg.getUint8(offset + 1)\n                const device = this.hubDevices[portId]\n                log('handlePortCommandFeedback', { portId, feedback })\n                if (feedback == 10 && device != undefined) {\n                    device.handleFeedback()\n                }\n\n            }\n        }\n        /**\n         * \n         * @param {DataView} msg \n         */\n        handlePortMsg(msg) {\n\n            const portId = msg.getUint8(3)\n            const eventType = msg.getUint8(4)\n            const type = eventType ? msg.getUint16(5, true) : 0\n            const deviceTypeName = DeviceTypeNames[type] || \"Unknown\"\n            const eventName = EventNames[eventType]\n\n            console.log('handlePortMsg', { portId, eventName, deviceTypeName })\n            if (eventType == Event.ATTACHED_IO) {\n\n                let constructor = constructorMap[type]\n                if (!constructor) {\n                    constructor = Device\n                }\n                const device = new constructor(this, portId, deviceTypeName)\n                this.hubDevices[portId] = device\n                this.attachCallbacks.emit(device)\n\n                this.emit('attach', device)\n            }\n            else if (eventType == Event.DETACHED_IO) {\n                delete this.hubDevices[portId]\n                this.emit('detach', { portId })\n            }\n            else if (eventType == Event.ATTACHED_VIRTUAL_IO) {\n                const portId1 = msg.getUint8(7)\n                const portId2 = msg.getUint8(8)\n\n                const device = new DoubleMotor(this, portId, getVirtualPortName(portId1, portId2))\n                this.hubDevices[portId] = device\n                this.attachCallbacks.emit(device)\n\n                this.emit('attach', device)\n            }\n        }\n    }\n\n    $$.service.registerService('hub', {\n\n        init: function () {\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isMotor(device) {\n                return device instanceof Motor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isDoubleMotor(device) {\n                return device instanceof DoubleMotor\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isLed(device) {\n                return device instanceof Led\n            }\n\n            /**\n             * \n             * @param {Device} device \n             * @returns {boolean}\n             */\n            function isTachoMotor(device) {\n                return device instanceof TachoMotor\n            }\n\n            /**\n             * \n             * @returns {Promise<HubDevice>}\n             */\n            async function connect() {\n                log('connect')\n\n                const device = await navigator.bluetooth.requestDevice({\n                    acceptAllDevices: true,\n                    optionalServices: [LPF2_SERVICE_UUID]\n                })\n\n                const hubDevice = new HubDevice()\n                await hubDevice.init(device)\n\n                return hubDevice\n\n                //await sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_TYPE, 0x05)\n                //await sendMsg(formatMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BATTERY_VOLTAGE, 0x02))\n                //await sendMsg(MessageType.HUB_PROPERTIES, HubPropertyPayload.BUTTON_STATE, 0x02)\n            }\n\n            return {\n                connect,\n                Color,\n                PortMap,\n                PortMapNames,\n                DeviceMode,\n                BrakingStyle,\n                DeviceTypeNames,\n                isMotor,\n                isTachoMotor,\n                isLed,\n                isDoubleMotor\n            }\n        }\n    });\n\n})();\n\n\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvQ2FsbGJhY2tFbWl0dGVyLmpzIiwibGliL0NvbnN0LmpzIiwibGliL0RldmljZS5qcyIsImxpYi9Eb3VibGVNb3Rvci5qcyIsImxpYi9MZWQuanMiLCJsaWIvTW90b3IuanMiLCJsaWIvUmdiTGVkLmpzIiwibGliL1RhY2hvTW90b3IuanMiLCJsaWIvVGlsdFNlbnNvci5qcyIsImxpYi9VdGlsLmpzIiwibGliL2h1Yi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY2xhc3MgQ2FsbGJhY2tFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7KGRhdGEpID0+IGJvb2xlYW59IGNhbGxiYWNrIFxuICAgICAqL1xuICAgIG9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG4gICAgfVxuXG4gICAgZW1pdChkYXRhKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5jYWxsYmFja3MubGVuZ3RoXG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tpXVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Muc3BsaWNlKGksIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tFbWl0dGVyIiwiLy9AdHMtY2hlY2tcblxuY29uc3QgeyBnZXRFbnVtTmFtZSB9ID0gJCQudXRpbFxuXG5jb25zdCBFdmVudCA9IHtcbiAgICBERVRBQ0hFRF9JTzogMHgwMCxcbiAgICBBVFRBQ0hFRF9JTzogMHgwMSxcbiAgICBBVFRBQ0hFRF9WSVJUVUFMX0lPOiAweDAyLFxufVxuY29uc3QgRXZlbnROYW1lcyA9IGdldEVudW1OYW1lKEV2ZW50KVxuXG5jb25zdCBIdWJBbGVydFR5cGUgPSB7XG4gICAgTE9XX1ZPTFRBR0U6IDB4MDEsXG4gICAgSElHSF9DVVJSRU5UOiAweDAyLFxuICAgIExPV19TSUdOQUxfU1RSRU5HVEg6IDB4MDMsXG4gICAgT1ZFUl9QT1dFUl9DT05ESVRJT046IDB4MDRcbn1cblxuY29uc3QgTWVzc2FnZVR5cGUgPSB7XG4gICAgSFVCX1BST1BFUlRJRVM6IDB4MDEsXG4gICAgSFVCX0FDVElPTlM6IDB4MDIsXG4gICAgSFVCX0FMRVJUUzogMHgwMyxcbiAgICBIVUJfQVRUQUNIRURfSU86IDB4MDQsXG4gICAgR0VORVJJQ19FUlJPUl9NRVNTQUdFUzogMHgwNSxcbiAgICBIV19ORVRXT1JLX0NPTU1BTkRTOiAweDA4LFxuICAgIEZXX1VQREFURV9HT19JTlRPX0JPT1RfTU9ERTogMHgxMCxcbiAgICBGV19VUERBVEVfTE9DS19NRU1PUlk6IDB4MTEsXG4gICAgRldfVVBEQVRFX0xPQ0tfU1RBVFVTX1JFUVVFU1Q6IDB4MTIsXG4gICAgRldfTE9DS19TVEFUVVM6IDB4MTMsXG4gICAgUE9SVF9JTkZPUk1BVElPTl9SRVFVRVNUOiAweDIxLFxuICAgIFBPUlRfTU9ERV9JTkZPUk1BVElPTl9SRVFVRVNUOiAweDIyLFxuICAgIFBPUlRfSU5QVVRfRk9STUFUX1NFVFVQX1NJTkdMRTogMHg0MSxcbiAgICBQT1JUX0lOUFVUX0ZPUk1BVF9TRVRVUF9DT01CSU5FRE1PREU6IDB4NDIsXG4gICAgUE9SVF9JTkZPUk1BVElPTjogMHg0MyxcbiAgICBQT1JUX01PREVfSU5GT1JNQVRJT046IDB4NDQsXG4gICAgUE9SVF9WQUxVRV9TSU5HTEU6IDB4NDUsXG4gICAgUE9SVF9WQUxVRV9DT01CSU5FRE1PREU6IDB4NDYsXG4gICAgUE9SVF9JTlBVVF9GT1JNQVRfU0lOR0xFOiAweDQ3LFxuICAgIFBPUlRfSU5QVVRfRk9STUFUX0NPTUJJTkVETU9ERTogMHg0OCxcbiAgICBWSVJUVUFMX1BPUlRfU0VUVVA6IDB4NjEsXG4gICAgUE9SVF9PVVRQVVRfQ09NTUFORDogMHg4MSxcbiAgICBQT1JUX09VVFBVVF9DT01NQU5EX0ZFRURCQUNLOiAweDgyLFxufVxuXG5cblxuY29uc3QgTWVzc2FnZVR5cGVOYW1lcyA9IGdldEVudW1OYW1lKE1lc3NhZ2VUeXBlKVxuXG5jb25zdCBEZXZpY2VUeXBlID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgU0lNUExFX01FRElVTV9MSU5FQVJfTU9UT1I6IDEsXG4gICAgVFJBSU5fTU9UT1I6IDIsXG4gICAgTElHSFQ6IDgsXG4gICAgVk9MVEFHRV9TRU5TT1I6IDIwLFxuICAgIENVUlJFTlRfU0VOU09SOiAyMSxcbiAgICBQSUVaT19CVVpaRVI6IDIyLFxuICAgIEhVQl9MRUQ6IDIzLFxuICAgIFRJTFRfU0VOU09SOiAzNCxcbiAgICBNT1RJT05fU0VOU09SOiAzNSxcbiAgICBDT0xPUl9ESVNUQU5DRV9TRU5TT1I6IDM3LFxuICAgIE1FRElVTV9MSU5FQVJfTU9UT1I6IDM4LFxuICAgIE1PVkVfSFVCX01FRElVTV9MSU5FQVJfTU9UT1I6IDM5LFxuICAgIE1PVkVfSFVCX1RJTFRfU0VOU09SOiA0MCxcbiAgICBEVVBMT19UUkFJTl9CQVNFX01PVE9SOiA0MSxcbiAgICBEVVBMT19UUkFJTl9CQVNFX1NQRUFLRVI6IDQyLFxuICAgIERVUExPX1RSQUlOX0JBU0VfQ09MT1JfU0VOU09SOiA0MyxcbiAgICBEVVBMT19UUkFJTl9CQVNFX1NQRUVET01FVEVSOiA0NCxcbiAgICBURUNITklDX0xBUkdFX0xJTkVBUl9NT1RPUjogNDYsIC8vIFRlY2huaWMgQ29udHJvbCtcbiAgICBURUNITklDX1hMQVJHRV9MSU5FQVJfTU9UT1I6IDQ3LCAvLyBUZWNobmljIENvbnRyb2wrXG4gICAgVEVDSE5JQ19NRURJVU1fQU5HVUxBUl9NT1RPUjogNDgsIC8vIFNwaWtlIFByaW1lXG4gICAgVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SOiA0OSwgLy8gU3Bpa2UgUHJpbWVcbiAgICBURUNITklDX01FRElVTV9IVUJfR0VTVF9TRU5TT1I6IDU0LFxuICAgIFJFTU9URV9DT05UUk9MX0JVVFRPTjogNTUsXG4gICAgUkVNT1RFX0NPTlRST0xfUlNTSTogNTYsXG4gICAgVEVDSE5JQ19NRURJVU1fSFVCX0FDQ0VMRVJPTUVURVI6IDU3LFxuICAgIFRFQ0hOSUNfTUVESVVNX0hVQl9HWVJPX1NFTlNPUjogNTgsXG4gICAgVEVDSE5JQ19NRURJVU1fSFVCX1RJTFRfU0VOU09SOiA1OSxcbiAgICBURUNITklDX01FRElVTV9IVUJfVEVNUEVSQVRVUkVfU0VOU09SOiA2MCxcbiAgICBURUNITklDX0NPTE9SX1NFTlNPUjogNjEsIC8vIFNwaWtlIFByaW1lXG4gICAgVEVDSE5JQ19ESVNUQU5DRV9TRU5TT1I6IDYyLCAvLyBTcGlrZSBQcmltZVxuICAgIFRFQ0hOSUNfRk9SQ0VfU0VOU09SOiA2MywgLy8gU3Bpa2UgUHJpbWVcbiAgICBURUNITklDXzNYM19DT0xPUl9MSUdIVF9NQVRSSVg6IDY0LCAvLyBTcGlrZSBFc3NlbnRpYWxcbiAgICBURUNITklDX1NNQUxMX0FOR1VMQVJfTU9UT1I6IDY1LCAvLyBTcGlrZSBFc3NlbnRpYWxcbiAgICBNQVJJT19BQ0NFTEVST01FVEVSOiA3MSxcbiAgICBNQVJJT19CQVJDT0RFX1NFTlNPUjogNzMsXG4gICAgTUFSSU9fUEFOVFNfU0VOU09SOiA3NCxcbiAgICBURUNITklDX01FRElVTV9BTkdVTEFSX01PVE9SX0dSRVk6IDc1LCAvLyBNaW5kc3Rvcm1zXG4gICAgVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SX0dSRVk6IDc2LCAvLyBUZWNobmljIENvbnRyb2wrXG4gICAgVklSVFVBTF9ERVZJQ0U6IDEwMFxufVxuXG5jb25zdCBEZXZpY2VUeXBlTmFtZXMgPSBnZXRFbnVtTmFtZShEZXZpY2VUeXBlKVxuXG5jb25zdCBFcnJvckNvZGUgPSB7XG4gICAgQUNLOiAweDAxLFxuICAgIE1BQ0s6IDB4MDIsXG4gICAgQlVGRkVSX09WRVJGTE9XOiAweDAzLFxuICAgIFRJTUVPVVQ6IDB4MDQsXG4gICAgQ09NTUFORF9OT1RfUkVDT0dOSVpFRDogMHgwNSxcbiAgICBJTlZBTElEX1VTRTogMHgwNixcbiAgICBPVkVSQ1VSUkVOVDogMHgwNyxcbiAgICBJTlRFUk5BTF9FUlJPUjogMHgwOCxcbn1cblxuY29uc3QgRXJyb3JDb2RlTmFtZXMgPSBnZXRFbnVtTmFtZShFcnJvckNvZGUpXG5cblxuY29uc3QgSHViUHJvcGVydHlQYXlsb2FkID0ge1xuICAgIEFEVkVSVElTSU5HX05BTUU6IDB4MDEsXG4gICAgQlVUVE9OX1NUQVRFOiAweDAyLFxuICAgIEZXX1ZFUlNJT046IDB4MDMsXG4gICAgSFdfVkVSU0lPTjogMHgwNCxcbiAgICBSU1NJOiAweDA1LFxuICAgIEJBVFRFUllfVk9MVEFHRTogMHgwNixcbiAgICBCQVRURVJZX1RZUEU6IDB4MDcsXG4gICAgTUFOVUZBQ1RVUkVSX05BTUU6IDB4MDgsXG4gICAgUkFESU9fRklSTVdBUkVfVkVSU0lPTjogMHgwOSxcbiAgICBMV1BfUFJPVE9DT0xfVkVSU0lPTjogMHgwQSxcbiAgICBTWVNURU1fVFlQRV9JRDogMHgwQixcbiAgICBIV19ORVRXT1JLX0lEOiAweDBDLFxuICAgIFBSSU1BUllfTUFDX0FERFJFU1M6IDB4MEQsXG4gICAgU0VDT05EQVJZX01BQ19BRERSRVNTOiAweDBFLFxuICAgIEhXX05FVFdPUktfRkFNSUxZOiAweDBGXG59XG5cbmNvbnN0IEh1YlByb3BlcnR5UGF5bG9hZE5hbWVzID0gZ2V0RW51bU5hbWUoSHViUHJvcGVydHlQYXlsb2FkKVxuXG5jb25zdCBNb2RlSW5mb3JtYXRpb25UeXBlID0ge1xuICAgIE5BTUU6IDB4MDAsXG4gICAgUkFXOiAweDAxLFxuICAgIFBDVDogMHgwMixcbiAgICBTSTogMHgwMyxcbiAgICBTWU1CT0w6IDB4MDQsXG4gICAgTUFQUElORzogMHgwNSxcbiAgICBVU0VEX0lOVEVSTkFMTFk6IDB4MDYsXG4gICAgTU9UT1JfQklBUzogMHgwNyxcbiAgICBDQVBBQklMSVRZX0JJVFM6IDB4MDgsXG4gICAgVkFMVUVfRk9STUFUOiAweDgwLFxufVxuXG5jb25zdCBNb2RlSW5mb3JtYXRpb25UeXBlTmFtZXMgPSBnZXRFbnVtTmFtZShNb2RlSW5mb3JtYXRpb25UeXBlKVxuXG5jb25zdCBQb3J0TWFwID0ge1xuICAgIFwiQVwiOiAwLFxuICAgIFwiQlwiOiAxLFxuICAgIFwiQ1wiOiAyLFxuICAgIFwiRFwiOiAzLFxuICAgIFwiSFVCX0xFRFwiOiA1MCxcbiAgICBcIkNVUlJFTlRfU0VOU09SXCI6IDU5LFxuICAgIFwiVk9MVEFHRV9TRU5TT1JcIjogNjAsXG4gICAgXCJBQ0NFTEVST01FVEVSXCI6IDk3LFxuICAgIFwiR1lST19TRU5TT1JcIjogOTgsXG4gICAgXCJUSUxUX1NFTlNPUlwiOiA5OVxufVxuXG5jb25zdCBEZXZpY2VNb2RlID0ge1xuICAgIFBPV0VSOiAweDAwLFxuICAgIFNQRUVEOiAweDAxLFxuICAgIFJPVEFUSU9OOiAweDAyLFxuICAgIEFCU09MVVRFOiAweDAzLFxuICAgIENPTE9SOiAweDAwLFxuICAgIFJHQjogMHgwMSxcbiAgICBUSUxUX1BPUzogMHgwMFxufVxuXG5jb25zdCBCcmFraW5nU3R5bGUgPSB7XG4gICAgRkxPQVQ6IDAsXG4gICAgSE9MRDogMTI2LFxuICAgIEJSQUtFOiAxMjdcbn1cblxuY29uc3QgUG9ydE1hcE5hbWVzID0gZ2V0RW51bU5hbWUoUG9ydE1hcClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWVzc2FnZVR5cGUsXG4gICAgTWVzc2FnZVR5cGVOYW1lcyxcbiAgICBFdmVudCxcbiAgICBFdmVudE5hbWVzLFxuICAgIEJyYWtpbmdTdHlsZSxcbiAgICBEZXZpY2VNb2RlLFxuICAgIERldmljZVR5cGUsXG4gICAgRGV2aWNlVHlwZU5hbWVzLFxuICAgIE1vZGVJbmZvcm1hdGlvblR5cGUsXG4gICAgTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzLFxuICAgIFBvcnRNYXAsXG4gICAgUG9ydE1hcE5hbWVzLFxuICAgIEh1YlByb3BlcnR5UGF5bG9hZCxcbiAgICBIdWJQcm9wZXJ0eVBheWxvYWROYW1lcyxcbiAgICBFcnJvckNvZGVOYW1lc1xufSIsIi8vQHRzLWNoZWNrXG5cbmNvbnN0IENhbGxiYWNrRW1pdHRlciA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tFbWl0dGVyJylcbmNvbnN0IHtNZXNzYWdlVHlwZSwgUG9ydE1hcE5hbWVzfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuY29uc3Qge2xvZywgdG9VaW50MzJ9ID0gcmVxdWlyZSgnLi9VdGlsJylcblxuY2xhc3MgRGV2aWNlIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0hVQi5IdWJEZXZpY2V9IGh1YkRldmljZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaHViRGV2aWNlID0gaHViRGV2aWNlXG4gICAgICAgIHRoaXMucG9ydElkID0gcG9ydElkXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAgICAgdGhpcy5uYW1lID0gUG9ydE1hcE5hbWVzW3BvcnRJZF1cbiAgICAgICAgdGhpcy5mZWVkYmFja0NhbGxiYWNrID0gbnVsbFxuICAgICAgICB0aGlzLnZhbHVlQ2FsbGJhY2tzID0gbmV3IENhbGxiYWNrRW1pdHRlcigpXG4gICAgICAgIHRoaXMubW9kZSA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLm1vZGVzID0gdW5kZWZpbmVkXG4gICAgICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgYXN5bmMgd3JpdGVQb3J0Q29tbWFuZCh3YWl0RmVlZGJhY2ssIC4uLmRhdGEpIHtcblxuICAgICAgICBsb2coJ3dyaXRlUG9ydENvbW1hbmQnLCB0aGlzLnBvcnRJZCwgeyB3YWl0RmVlZGJhY2ssIGRhdGEgfSlcblxuICAgICAgICBpZiAod2FpdEZlZWRiYWNrKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5odWJEZXZpY2Uuc2VuZE1zZyhNZXNzYWdlVHlwZS5QT1JUX09VVFBVVF9DT01NQU5ELCB0aGlzLnBvcnRJZCwgMHgxMSwgZGF0YSlcblxuICAgICAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tDYWxsYmFjayA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odWJEZXZpY2Uuc2VuZE1zZyhNZXNzYWdlVHlwZS5QT1JUX09VVFBVVF9DT01NQU5ELCB0aGlzLnBvcnRJZCwgMHgxMCwgZGF0YSlcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdhaXRGZWVkYmFjayBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGRhdGEgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgd3JpdGVEaXJlY3RNb2RlKG1vZGUsIHdhaXRGZWVkYmFjaywgLi4uZGF0YSkge1xuICAgICAgICBsb2coJ3dyaXRlRGlyZWN0TW9kZScsIHRoaXMucG9ydElkLCB7bW9kZSwgd2FpdEZlZWRiYWNrIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQod2FpdEZlZWRiYWNrLCAweDUxLCBtb2RlLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm90aWZpY2F0aW9uRW5hYmxlZCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFJbnRlcnZhbCBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICBzZXRNb2RlKG1vZGUsIG5vdGlmaWNhdGlvbkVuYWJsZWQsIGRlbHRhSW50ZXJ2YWwgPSAxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzZXRNb2RlJywgdGhpcy5wb3J0SWQsIHsgbW9kZSwgbm90aWZpY2F0aW9uRW5hYmxlZCB9KVxuXG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGVcblxuICAgICAgICByZXR1cm4gdGhpcy5odWJEZXZpY2Uuc2VuZE1zZyhNZXNzYWdlVHlwZS5QT1JUX0lOUFVUX0ZPUk1BVF9TRVRVUF9TSU5HTEUsXG4gICAgICAgICAgICB0aGlzLnBvcnRJZCwgbW9kZSwgdG9VaW50MzIoZGVsdGFJbnRlcnZhbCksIG5vdGlmaWNhdGlvbkVuYWJsZWQgPyAweDAxIDogMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICovXG4gICAgZGVjb2RlVmFsdWUobXNnKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qge1ZBTFVFX0ZPUk1BVCwgUkFXLCBTSX0gPSB0aGlzLm1vZGVzW3RoaXMubW9kZV1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gJCQudXRpbC5tYXBSYW5nZShSQVcubWluLCBSQVcubWF4LCBTSS5taW4sIFNJLm1heClcbiAgICAgICAgICAgIGxvZygnaW5mbycsIHRoaXMubW9kZXNbdGhpcy5tb2RlXSlcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhVHlwZSwgbnVtVmFsdWVzfSA9IFZBTFVFX0ZPUk1BVFxuICAgICAgICAgICAgY29uc3QgcmV0ID0gW11cbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSA0XG4gICAgICAgICAgICBsZXQgdmFsXG4gICAgICAgICAgICBmb3IobGV0IGlkeCA9IDA7IGlkeCA8IG51bVZhbHVlczsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnMTZiaXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbXNnLmdldEludDE2KG9mZnNldCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOGJpdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtc2cuZ2V0SW50OChvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzMyYml0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG1zZy5nZXRJbnQzMihvZmZzZXQsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG1zZy5nZXRGbG9hdDMyKG9mZnNldCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nKCd2YWwnLCB2YWwpXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goTWF0aC50cnVuYyhyYW5nZSh2YWwpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRcblxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgKi9cbiAgICBoYW5kbGVWYWx1ZShtc2cpIHtcbiAgICAgICAgbG9nKCdoYW5kbGVWYWx1ZScsIHRoaXMucG9ydElkLCBtc2cpXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGVjb2RlVmFsdWUobXNnKVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDYWxsYmFja3MuZW1pdCh2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUZlZWRiYWNrKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZmVlZGJhY2tDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrQ2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgXG4gICAgICogQHJldHVybnMgXG4gICAgKi9cbiAgICBhc3luYyBnZXRWYWx1ZShtb2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXRWYWx1ZScsIHRoaXMucG9ydElkLCB7IG1vZGUgfSlcbiAgICAgICAgaWYgKHRoaXMubW9kZXMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7bW9kZXMsIGNhcGFiaWxpdGllc30gPSBhd2FpdCB0aGlzLmh1YkRldmljZS5nZXRQb3J0SW5mb3JtYXRpb24odGhpcy5wb3J0SWQpXG4gICAgICAgICAgICB0aGlzLm1vZGVzID0gbW9kZXNcbiAgICAgICAgICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKG1vZGUsIGZhbHNlKVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDYWxsYmFja3Mub24oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmh1YkRldmljZS5zZW5kTXNnKE1lc3NhZ2VUeXBlLlBPUlRfSU5GT1JNQVRJT05fUkVRVUVTVCwgdGhpcy5wb3J0SWQsIDB4MDApXG5cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbW9kZSBcbiAgICAgKiBAcGFyYW0geyhkYXRhKSA9PiBib29sZWFufSB0ZXN0Rm4gXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgYXN5bmMgd2FpdFRlc3RWYWx1ZShtb2RlLCB0ZXN0Rm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldE1vZGUobW9kZSwgdHJ1ZSlcbiAgICAgICAgICAgIHRoaXMudmFsdWVDYWxsYmFja3Mub24oYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nKCd3YWl0VGVzdFZhbHVlJywgdmFsdWUpXG4gICAgICAgICAgICAgICAgaWYgKHRlc3RGbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKCd3YWl0VGVzdFZhbHVlIE9LJylcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRNb2RlKG1vZGUsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGFzeW5jIHN1YnNjcmliZShtb2RlLCBjYmssIGRlbHRhSW50ZXJ2YWwgPSAxKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0TW9kZShtb2RlLCB0cnVlLCBkZWx0YUludGVydmFsKVxuICAgICAgICB0aGlzLnZhbHVlQ2FsbGJhY2tzLm9uKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjYmsoZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9KVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZXZpY2UiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBNb3RvciA9IHJlcXVpcmUoJy4vTW90b3InKVxuY29uc3Qge0JyYWtpbmdTdHlsZX0gPSByZXF1aXJlKCcuL0NvbnN0JylcbmNvbnN0IHt0b0ludDE2LCB0b0ludDMyfSA9IHJlcXVpcmUoJy4vVXRpbCcpXG5cbmNvbnN0IG1heFBvd2VyID0gMTAwXG5cbmNsYXNzIERvdWJsZU1vdG9yIGV4dGVuZHMgTW90b3Ige1xuXG5cbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgbmFtZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgJ1ZpcnR1YWwgRGV2aWNlJylcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkMSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWQyIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHNldFNwZWVkKHNwZWVkMSwgc3BlZWQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQoZmFsc2UsIDB4MDgsIHNwZWVkMSwgc3BlZWQyLCBtYXhQb3dlciwgMClcbiAgICB9XG5cbiAgICBzZXRTcGVlZEZvclRpbWUoc3BlZWQxLCBzcGVlZDIsIHRpbWUsIHdhaXRGZWVkYmFjayA9IGZhbHNlLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnc2V0U3BlZWRGb3JUaW1lJywgdGhpcy5wb3J0SWQsIHsgc3BlZWQxLCBzcGVlZDIsIHRpbWUsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQodGhpcy5wb3J0SWQsIHdhaXRGZWVkYmFjaywgMHgwQSwgdG9JbnQxNih0aW1lKSwgc3BlZWQxLCBzcGVlZDIsIG1heFBvd2VyLCBicmFraW5nU3R5bGUpXG4gICAgfVxuXG4gICAgcm90YXRlRGVncmVlcyhkZWdyZWVzLCBzcGVlZDEsIHNwZWVkMiwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgPSBCcmFraW5nU3R5bGUuQlJBS0UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3JvdGF0ZURlZ3JlZXMnLCB0aGlzLnBvcnRJZCwgeyBkZWdyZWVzLCBzcGVlZDEsIHNwZWVkMiwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RmVlZGJhY2ssIDB4MEMsIHRvSW50MzIoZGVncmVlcyksIHNwZWVkMSwgc3BlZWQyLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIGdvdG9BbmdsZShhbmdsZTEsIGFuZ2xlMiwgc3BlZWQsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlID0gQnJha2luZ1N0eWxlLkJSQUtFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnb3RvQW5nbGUnLCB0aGlzLnBvcnRJZCwgeyBhbmdsZTEsIGFuZ2xlMiwgc3BlZWQsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RmVlZGJhY2ssIDB4MEUsIHRvSW50MzIoYW5nbGUxKSwgdG9JbnQzMihhbmdsZTIpLCBzcGVlZCwgbWF4UG93ZXIsIGJyYWtpbmdTdHlsZSlcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRG91YmxlTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jbGFzcyBMZWQgZXh0ZW5kcyBEZXZpY2Uge1xuXG4gICAgLyoqXG4gICAgKiBcbiAgICAqIEBwYXJhbSB7SHViRGV2aWNlfSBodWJEZXZpY2UgXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpXG5cbiAgICB9XG5cbiAgICBzZXRCcmlnaHRuZXNzKGJyaWdodG5lc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldEJyaWdodG5lc3MnLCB0aGlzLnBvcnRJZCwgeyBicmlnaHRuZXNzIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLlBPV0VSLCBmYWxzZSwgYnJpZ2h0bmVzcylcbiAgICB9XG5cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExlZCIsIi8vQHRzLWNoZWNrXG5cbmNvbnN0IERldmljZSA9IHJlcXVpcmUoJy4vRGV2aWNlJylcbmNvbnN0IHtQb3J0TWFwTmFtZXMsIERldmljZU1vZGV9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG5cbmNvbnN0IG1heFBvd2VyID0gMTAwXG5cbmNsYXNzIE1vdG9yIGV4dGVuZHMgRGV2aWNlIHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7SHViRGV2aWNlfSBodWJEZXZpY2UgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcbiAgICB9XG5cbiAgICBzZXRQb3dlcihwb3dlcikge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0UG93ZXInLCB0aGlzLnBvcnRJZCwgeyBwb3dlciB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoRGV2aWNlTW9kZS5QT1dFUiwgZmFsc2UsIHBvd2VyKVxuICAgIH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jbGFzcyBSZ2JMZWQgZXh0ZW5kcyBEZXZpY2Uge1xuXG4gICAgLyoqXG4gICAgKiBcbiAgICAqIEBwYXJhbSB7SHViRGV2aWNlfSBodWJEZXZpY2UgXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICovXG4gICAgY29uc3RydWN0b3IoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoaHViRGV2aWNlLCBwb3J0SWQsIHR5cGUpXG5cbiAgICB9XG5cbiAgICBhc3luYyBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0Q29sb3InLCB0aGlzLnBvcnRJZCwgeyBjb2xvciB9KVxuICAgICAgICBhd2FpdCB0aGlzLnNldE1vZGUoRGV2aWNlTW9kZS5DT0xPUiwgZmFsc2UpXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLkNPTE9SLCBmYWxzZSwgY29sb3IpXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0UkdCQ29sb3IociwgZywgYikge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0Q29sb3InLCB0aGlzLnBvcnRJZCwgeyByLCBnLCBiIH0pXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0TW9kZShEZXZpY2VNb2RlLlJHQiwgZmFsc2UpXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlRGlyZWN0TW9kZShEZXZpY2VNb2RlLlJHQiwgZmFsc2UsIHIsIGcsIGIpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJnYkxlZCIsIi8vQHRzLWNoZWNrXG5cbmNvbnN0IE1vdG9yID0gcmVxdWlyZSgnLi9Nb3RvcicpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlLCBCcmFraW5nU3R5bGV9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG5jb25zdCB7dG9JbnQzMiwgdG9JbnQxNn0gPSByZXF1aXJlKCcuL1V0aWwnKVxuXG5jb25zdCBtYXhQb3dlciA9IDEwMFxuXG5jbGFzcyBUYWNob01vdG9yIGV4dGVuZHMgTW90b3Ige1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtIdWJEZXZpY2V9IGh1YkRldmljZSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9ydElkIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGh1YkRldmljZSwgcG9ydElkLCB0eXBlKVxuICAgIH1cblxuICAgIHNldFNwZWVkKHNwZWVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzZXRTcGVlZCcsIHRoaXMucG9ydElkLCB7IHNwZWVkIH0pXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlUG9ydENvbW1hbmQoZmFsc2UsIDB4MDcsIHNwZWVkLCBtYXhQb3dlciwgMClcbiAgICB9XG5cbiAgICByb3RhdGVEZWdyZWVzKGRlZ3JlZXMsIHNwZWVkLCB3YWl0RmVlZGJhY2ssIGJyYWtpbmdTdHlsZSA9IEJyYWtpbmdTdHlsZS5CUkFLRSkge1xuICAgICAgICBjb25zb2xlLmxvZygncm90YXRlRGVncmVlcycsIHRoaXMucG9ydElkLCB7IGRlZ3JlZXMsIHNwZWVkLCB3YWl0RmVlZGJhY2ssIGJyYWtpbmdTdHlsZSB9KVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRGZWVkYmFjaywgMHgwQiwgdG9JbnQzMihkZWdyZWVzKSwgc3BlZWQsIG1heFBvd2VyLCBicmFraW5nU3R5bGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZCBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdhaXRGZWVkYmFjayBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnJha2luZ1N0eWxlIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIGdvdG9BbmdsZShhbmdsZSwgc3BlZWQsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlID0gQnJha2luZ1N0eWxlLkJSQUtFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnb3RvQW5nbGUnLCB0aGlzLnBvcnRJZCwgeyBhbmdsZSwgc3BlZWQsIHdhaXRGZWVkYmFjaywgYnJha2luZ1N0eWxlIH0pXG5cbiAgICAgICAgaWYgKHRoaXMuY2FsaWJyYXRpb25WYWx1ZSkge1xuICAgICAgICAgICAgYW5nbGUgKj0gdGhpcy5jYWxpYnJhdGlvblZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVBvcnRDb21tYW5kKHdhaXRGZWVkYmFjaywgMHgwRCwgdG9JbnQzMihhbmdsZSksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIHNldFNwZWVkRm9yVGltZShzcGVlZCwgdGltZSwgd2FpdEZlZWRiYWNrID0gZmFsc2UsIGJyYWtpbmdTdHlsZSA9IEJyYWtpbmdTdHlsZS5CUkFLRSkge1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdzZXRTcGVlZEZvclRpbWUnLCB0aGlzLnBvcnRJZCwgeyBzcGVlZCwgdGltZSwgd2FpdEZlZWRiYWNrLCBicmFraW5nU3R5bGUgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVQb3J0Q29tbWFuZCh3YWl0RmVlZGJhY2ssIDB4MDksIHRvSW50MTYodGltZSksIHNwZWVkLCBtYXhQb3dlciwgYnJha2luZ1N0eWxlKVxuICAgIH1cblxuICAgIHJlc2V0WmVybygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0WmVybycsIHRoaXMucG9ydElkKVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZURpcmVjdE1vZGUoRGV2aWNlTW9kZS5ST1RBVElPTiwgdHJ1ZSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMClcbiAgICB9XG5cbiAgICBnZXRTcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5TUEVFRClcbiAgICB9XG5cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoRGV2aWNlTW9kZS5ST1RBVElPTilcbiAgICB9XG5cbiAgICBnZXRBYnNvbHV0ZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShEZXZpY2VNb2RlLkFCU09MVVRFKVxuICAgIH1cblxuICAgIGFzeW5jIGNhbGlicmF0ZSgpIHtcblxuICAgICAgICBjb25zb2xlLmxvZygnY2FsaWJyYXRlJywgdGhpcy5wb3J0SWQpXG4gICAgICAgIHRoaXMuc2V0UG93ZXIoNTApXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdFRlc3RWYWx1ZShEZXZpY2VNb2RlLlNQRUVELCAodmFsdWUpID0+IHZhbHVlID4gMTApXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdFRlc3RWYWx1ZShEZXZpY2VNb2RlLlNQRUVELCAodmFsdWUpID0+IHZhbHVlID09IDApXG5cblxuICAgICAgICB0aGlzLnNldFBvd2VyKDApXG5cbiAgICAgICAgYXdhaXQgJCQudXRpbC53YWl0KDEwMDApXG5cbiAgICAgICAgLy8gYXdhaXQgdGhpcy5odWJEZXZpY2Uuc2V0UG9ydEZvcm1hdCh0aGlzLnBvcnRJZCwgRGV2aWNlTW9kZS5ST1RBVElPTilcbiAgICAgICAgLy8gbGV0IHZhbHVlID0gYXdhaXQgdGhpcy5odWJEZXZpY2UuZ2V0UG9ydFZhbHVlKHRoaXMucG9ydElkKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSlcdFxuXG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRaZXJvKClcblxuXG4gICAgICAgIHRoaXMuc2V0UG93ZXIoLTUwKVxuICAgICAgICBhd2FpdCB0aGlzLndhaXRUZXN0VmFsdWUoRGV2aWNlTW9kZS5TUEVFRCwgKHZhbHVlKSA9PiBNYXRoLmFicyh2YWx1ZSkgPiAxMClcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0VGVzdFZhbHVlKERldmljZU1vZGUuU1BFRUQsICh2YWx1ZSkgPT4gdmFsdWUgPT0gMClcblxuICAgICAgICB0aGlzLnNldFBvd2VyKDApXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXRWYWx1ZShEZXZpY2VNb2RlLlJPVEFUSU9OKVxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSlcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcih2YWx1ZSAvIDIpXG4gICAgICAgIGNvbnNvbGUubG9nKHsgb2Zmc2V0IH0pXG4gICAgICAgIGF3YWl0IHRoaXMuZ290b0FuZ2xlKG9mZnNldCwgMTAsIHRydWUpXG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXRaZXJvKClcbiAgICAgICAgdGhpcy5jYWxpYnJhdGlvblZhbHVlID0gTWF0aC5hYnMob2Zmc2V0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgKi9cbiAgICBkZWNvZGVWYWx1ZShtc2cpIHtcbiAgICAgICAgbGV0IHZhbHVlXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERldmljZU1vZGUuQUJTT0xVVEU6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtc2cuZ2V0SW50MTYoNCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBEZXZpY2VNb2RlLlJPVEFUSU9OOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gbXNnLmdldEludDMyKDQsIHRydWUpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgRGV2aWNlTW9kZS5TUEVFRDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1zZy5nZXRJbnQ4KDQpXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhY2hvTW90b3IiLCIvL0B0cy1jaGVja1xuXG5jb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG5jb25zdCB7UG9ydE1hcE5hbWVzLCBEZXZpY2VNb2RlfSA9IHJlcXVpcmUoJy4vQ29uc3QnKVxuXG5jbGFzcyBUaWx0U2Vuc29yIGV4dGVuZHMgRGV2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSkge1xuICAgICAgICBzdXBlcihodWJEZXZpY2UsIHBvcnRJZCwgdHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICovXG4gICAgZGVjb2RlVmFsdWUobXNnKSB7XG4gICAgICAgIGxldCB2YWx1ZVxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEZXZpY2VNb2RlLlRJTFRfUE9TOlxuICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICB5YXc6IG1zZy5nZXRJbnQxNig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgcGl0Y2g6IG1zZy5nZXRJbnQxNig2LCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgcm9sbDogbXNnLmdldEludDE2KDgsIHRydWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3VwZXIuZGVjb2RlVmFsdWUobXNnKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTZW5zb3JcbiIsIi8vQHRzLWNoZWNrXG5cbi8qKlxuICAqIFxuICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgXG4gICogQHJldHVybnMge0FycmF5fVxuICAqL1xuZnVuY3Rpb24gdG9JbnQxNih2YWwpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoMilcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKVxuICAgIHZpZXcuc2V0SW50MTYoMCwgdmFsLCB0cnVlKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGJ1ZmYpXG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0ludDMyKHZhbCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSg0KVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpXG4gICAgdmlldy5zZXRJbnQzMigwLCB2YWwsIHRydWUpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnVmZilcbn1cblxuZnVuY3Rpb24gdG9VaW50MzIodmFsKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpXG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcilcbiAgICB2aWV3LnNldFVpbnQzMigwLCB2YWwsIHRydWUpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnVmZilcbn1cblxuY29uc3QgZGVidWcgPSBmYWxzZVxuXG5jb25zdCBsb2cgPSBmdW5jdGlvbiAoLi4uZGF0YSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBkYXRhKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdG9JbnQxNixcbiAgICB0b0ludDMyLFxuICAgIHRvVWludDMyLFxuICAgIGxvZ1xufSIsIi8vQHRzLWNoZWNrXG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IENhbGxiYWNrRW1pdHRlciA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tFbWl0dGVyJylcbiAgICBjb25zdCB7IEV2ZW50TmFtZXMsIERldmljZU1vZGUsIERldmljZVR5cGVOYW1lcywgQnJha2luZ1N0eWxlLCBQb3J0TWFwLCBIdWJQcm9wZXJ0eVBheWxvYWROYW1lcywgTW9kZUluZm9ybWF0aW9uVHlwZU5hbWVzLCBFdmVudCwgRGV2aWNlVHlwZSwgUG9ydE1hcE5hbWVzLCBNZXNzYWdlVHlwZSwgSHViUHJvcGVydHlQYXlsb2FkLCBNb2RlSW5mb3JtYXRpb25UeXBlLCBFcnJvckNvZGVOYW1lcywgTWVzc2FnZVR5cGVOYW1lcyB9ID0gcmVxdWlyZSgnLi9Db25zdCcpXG4gICAgY29uc3QgTW90b3IgPSByZXF1aXJlKCcuL01vdG9yJylcbiAgICBjb25zdCBEb3VibGVNb3RvciA9IHJlcXVpcmUoJy4vRG91YmxlTW90b3InKVxuICAgIGNvbnN0IFRhY2hvTW90b3IgPSByZXF1aXJlKCcuL1RhY2hvTW90b3InKTtcbiAgICBjb25zdCBEZXZpY2UgPSByZXF1aXJlKCcuL0RldmljZScpXG4gICAgY29uc3QgUmdiTGVkID0gcmVxdWlyZSgnLi9SZ2JMZWQnKVxuICAgIGNvbnN0IExlZCA9IHJlcXVpcmUoJy4vTGVkJylcbiAgICBjb25zdCBUaWx0U2Vuc29yID0gcmVxdWlyZSgnLi9UaWx0U2Vuc29yJylcbiAgICBjb25zdCB7IGxvZyB9ID0gcmVxdWlyZSgnLi9VdGlsJylcblxuICAgIGNvbnN0IENvbG9yID0ge1xuICAgICAgICBCTEFDSzogMCxcbiAgICAgICAgUElOSzogMSxcbiAgICAgICAgUFVSUExFOiAyLFxuICAgICAgICBCTFVFOiAzLFxuICAgICAgICBMSUdIVF9CTFVFOiA0LFxuICAgICAgICBDWUFOOiA1LFxuICAgICAgICBHUkVFTjogNixcbiAgICAgICAgWUVMTE9XOiA3LFxuICAgICAgICBPUkFOR0U6IDgsXG4gICAgICAgIFJFRDogOSxcbiAgICAgICAgV0hJVEU6IDEwLFxuICAgICAgICBOT05FOiAyNTVcbiAgICB9XG5cbiAgICBjb25zdCBMUEYyX1NFUlZJQ0VfVVVJRCA9ICcwMDAwMTYyMy0xMjEyLWVmZGUtMTYyMy03ODVmZWFiY2QxMjMnXG4gICAgY29uc3QgTFBGMl9DSEFSQUNfVVVJRCA9ICcwMDAwMTYyNC0xMjEyLWVmZGUtMTYyMy03ODVmZWFiY2QxMjMnXG5cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZiBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYlRvU3RyaW5nKGJ1Zikge1xuICAgICAgICBjb25zdCB1aW50OGJ1ZmYgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgICAgIGxldCByZXQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhidWZmLmJ5dGVMZW5ndGggJiYgdWludDhidWZmW2ldICE9IDA7IGkrKykge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhidWZmW2ldKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICB9XG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGRhdGEgXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdE1zZyhtc2dUeXBlLCAuLi5kYXRhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBkYXRhLmZsYXQoMylcbiAgICAgICAgY29uc3QgbXNnTGVuID0gYnVmZi5sZW5ndGggKyAzXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihtc2dMZW4pXG4gICAgICAgIGNvbnN0IHVpbnQ4QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICAgICAgICB1aW50OEJ1ZmZlclswXSA9IG1zZ0xlblxuICAgICAgICB1aW50OEJ1ZmZlclsxXSA9IDBcbiAgICAgICAgdWludDhCdWZmZXJbMl0gPSBtc2dUeXBlXG4gICAgICAgIHVpbnQ4QnVmZmVyLnNldChidWZmLCAzKVxuICAgICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRWaXJ0dWFsUG9ydE5hbWUocG9ydElkMSwgcG9ydElkMikge1xuICAgICAgICBjb25zdCBwb3J0SWRBID0gUG9ydE1hcE5hbWVzW3BvcnRJZDFdXG4gICAgICAgIGNvbnN0IHBvcnRJZEIgPSBQb3J0TWFwTmFtZXNbcG9ydElkMl1cbiAgICAgICAgcmV0dXJuIGAke3BvcnRJZEF9XyR7cG9ydElkQn1gXG4gICAgfVxuXG4gICAgY29uc3QgY29uc3RydWN0b3JNYXAgPSB7XG4gICAgICAgIFtEZXZpY2VUeXBlLlRFQ0hOSUNfTEFSR0VfTElORUFSX01PVE9SXTogVGFjaG9Nb3RvcixcbiAgICAgICAgW0RldmljZVR5cGUuVEVDSE5JQ19MQVJHRV9BTkdVTEFSX01PVE9SX0dSRVldOiBUYWNob01vdG9yLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX1hMQVJHRV9MSU5FQVJfTU9UT1JdOiBUYWNob01vdG9yLFxuICAgICAgICBbRGV2aWNlVHlwZS5URUNITklDX01FRElVTV9IVUJfVElMVF9TRU5TT1JdOiBUaWx0U2Vuc29yLFxuICAgICAgICBbRGV2aWNlVHlwZS5IVUJfTEVEXTogUmdiTGVkLFxuICAgICAgICBbRGV2aWNlVHlwZS5MSUdIVF06IExlZFxuICAgIH1cblxuICAgIC8qKkBpbXBsZW1lbnRzIEhVQi5IdWJEZXZpY2UgKi9cbiAgICBjbGFzcyBIdWJEZXZpY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKClcbiAgICAgICAgICAgIHRoaXMuY2hhcmFjID0gbnVsbFxuICAgICAgICAgICAgdGhpcy5wb3J0Q21kUXVldWUgPSB7fVxuICAgICAgICAgICAgdGhpcy5wb3J0Q21kQ2FsbGJhY2sgPSB7fVxuICAgICAgICAgICAgLyoqQHR5cGUge3tbcG9ydElkOiBzdHJpbmddOiBEZXZpY2V9fSAqL1xuICAgICAgICAgICAgdGhpcy5odWJEZXZpY2VzID0ge31cbiAgICAgICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLmNtZFF1ZXVlID0gW11cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzID0gbmV3IENhbGxiYWNrRW1pdHRlcigpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7Qmx1ZXRvb3RoRGV2aWNlfSBkZXZpY2UgXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBpbml0KGRldmljZSkge1xuXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCBkZXZpY2UuZ2F0dC5jb25uZWN0KClcbiAgICAgICAgICAgIGxvZygnQ29ubmVjdGVkJylcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZXJ2ZXIuZ2V0UHJpbWFyeVNlcnZpY2UoTFBGMl9TRVJWSUNFX1VVSUQpXG4gICAgICAgICAgICB0aGlzLmNoYXJhYyA9IGF3YWl0IHNlcnZpY2UuZ2V0Q2hhcmFjdGVyaXN0aWMoTFBGMl9DSEFSQUNfVVVJRClcblxuICAgICAgICAgICAgY29uc3Qgb25DaGFyYWN0ZXJpc3RpY3ZhbHVlY2hhbmdlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlTXNnKGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGV2aWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2dhdHRzZXJ2ZXJkaXNjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29uR2F0dFNlcnZlckRpc2Nvbm5lY3RlZCcsIHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyYWMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhcmFjdGVyaXN0aWN2YWx1ZWNoYW5nZWQnLCBvbkNoYXJhY3RlcmlzdGljdmFsdWVjaGFuZ2VkKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyYWMgPSBudWxsXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy5jaGFyYWMuYWRkRXZlbnRMaXN0ZW5lcignY2hhcmFjdGVyaXN0aWN2YWx1ZWNoYW5nZWQnLCBvbkNoYXJhY3RlcmlzdGljdmFsdWVjaGFuZ2VkKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGFyYWMuc3RhcnROb3RpZmljYXRpb25zKClcbiAgICAgICAgICAgIGF3YWl0ICQkLnV0aWwud2FpdCgxMDApXG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBzdGFydE5vdGlmaWNhdGlvbigpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUywgSHViUHJvcGVydHlQYXlsb2FkLkJBVFRFUllfVk9MVEFHRSwgMHgwMilcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUywgSHViUHJvcGVydHlQYXlsb2FkLlNZU1RFTV9UWVBFX0lELCAweDA1KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9QUk9QRVJUSUVTLCBIdWJQcm9wZXJ0eVBheWxvYWQuUFJJTUFSWV9NQUNfQUREUkVTUywgMHgwNSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfQUxFUlRTLCAweDAxLCAweDAxKVxuICAgICAgICAgICAgLy8gYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9BTEVSVFMsIDB4MDIsIDB4MDEpXG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX0FMRVJUUywgMHgwMywgMHgwMSlcbiAgICAgICAgICAgIC8vIGF3YWl0IHRoaXMuc2VuZE1zZyhNZXNzYWdlVHlwZS5IVUJfQUxFUlRTLCAweDA0LCAweDAxKVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TW90b3I+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TW90b3IocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuaHViRGV2aWNlc1twb3J0SWRdXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlIGluc3RhbmNlb2YgTW90b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDYWxsYmFja3Mub24oKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS5wb3J0SWQgPT0gcG9ydElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGBkZXZpY2Ugb24gcG9ydElkICR7cG9ydElkfSBpcyByZWFkeWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TW90b3I+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFjaG9Nb3Rvcihwb3J0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgICAgICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UgaW5zdGFuY2VvZiBUYWNob01vdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLm9uKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UucG9ydElkID09IHBvcnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhgZGV2aWNlIG9uIHBvcnRJZCAke3BvcnRJZH0gaXMgcmVhZHlgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VGlsdFNlbnNvcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWx0U2Vuc29yKHBvcnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgICAgIGlmIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZSBpbnN0YW5jZW9mIFRpbHRTZW5zb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDYWxsYmFja3Mub24oKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS5wb3J0SWQgPT0gcG9ydElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGBkZXZpY2Ugb24gcG9ydElkICR7cG9ydElkfSBpcyByZWFkeWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdldFJnYkxlZChwb3J0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgICAgICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UgaW5zdGFuY2VvZiBSZ2JMZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDYWxsYmFja3Mub24oKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS5wb3J0SWQgPT0gcG9ydElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGBkZXZpY2Ugb24gcG9ydElkICR7cG9ydElkfSBpcyByZWFkeWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBnZXRMZWQocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMuaHViRGV2aWNlc1twb3J0SWRdXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlIGluc3RhbmNlb2YgTGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2FsbGJhY2tzLm9uKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2UucG9ydElkID09IHBvcnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhgZGV2aWNlIG9uIHBvcnRJZCAke3BvcnRJZH0gaXMgcmVhZHlgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGdldERibE1vdG9yKHBvcnRJZDEsIHBvcnRJZDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRWaXJ0dWFsUG9ydE5hbWUocG9ydElkMSwgcG9ydElkMilcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSBPYmplY3QudmFsdWVzKHRoaXMuaHViRGV2aWNlcykuZmluZCgoZCkgPT4gZC5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgaWYgKGRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDYWxsYmFja3Mub24oKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgZGV2aWNlIG9uIHBvcnRJZCAke2RldmljZS5wb3J0SWR9IGlzIHJlYWR5YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRldmljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVWaXJ0dWFsUG9ydChwb3J0SWQxLCBwb3J0SWQyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBidWZmZXIgXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzZW5kQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NlbmRCdWZmZXInLCBidWZmZXIpXG4gICAgICAgICAgICBpZiAoIXRoaXMuYnVzeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVzeSA9IHRydWVcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNoYXJhYy53cml0ZVZhbHVlV2l0aG91dFJlc3BvbnNlKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICB0aGlzLmJ1c3kgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNtZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kQnVmZmVyKHRoaXMuY21kUXVldWUuc2hpZnQoKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdidXN5ISBwdXNoIGluIHF1ZXVlJylcbiAgICAgICAgICAgICAgICB0aGlzLmNtZFF1ZXVlLnB1c2goYnVmZmVyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dUeXBlXG4gICAgICAgICAqIEBwYXJhbSAgey4uLmFueX0gZGF0YSBcbiAgICAgICAgICovXG4gICAgICAgIHNlbmRNc2cobXNnVHlwZSwgLi4uZGF0YSkge1xuICAgICAgICAgICAgbG9nKCdzZW5kTXNnJywgTWVzc2FnZVR5cGVOYW1lc1ttc2dUeXBlXSwgZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRCdWZmZXIoZm9ybWF0TXNnKG1zZ1R5cGUsIGRhdGEpKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBvcnRJZEZyb21OYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5mbyBvZiBPYmplY3QudmFsdWVzKHRoaXMuaHViRGV2aWNlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm8ucG9ydElkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQxXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0SWQyXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVWaXJ0dWFsUG9ydChwb3J0SWQxLCBwb3J0SWQyKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRNc2coTWVzc2FnZVR5cGUuVklSVFVBTF9QT1JUX1NFVFVQLCAweDAxLCBwb3J0SWQxLCBwb3J0SWQyKVxuICAgICAgICB9XG5cbiAgICAgICAgc2h1dGRvd24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9BQ1RJT05TLCAweDAxKVxuICAgICAgICB9XG5cblxuICAgICAgICBnZXRIdWJEZXZpY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5odWJEZXZpY2VzKVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0RGV2aWNlVHlwZShwb3J0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh1YkRldmljZXNbcG9ydElkXS50eXBlXG4gICAgICAgIH1cblxuICAgICAgICBnZXREZXZpY2UocG9ydElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRJZCBcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8SFVCLlBvcnRJbmZvcm1hdGlvbj59XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRQb3J0SW5mb3JtYXRpb24ocG9ydElkKSB7XG4gICAgICAgICAgICBsZXQgeyBtb2RlcywgY2FwYWJpbGl0aWVzIH0gPSB0aGlzLmh1YkRldmljZXNbcG9ydElkXVxuICAgICAgICAgICAgaWYgKG1vZGVzICE9IHVuZGVmaW5lZCB8fCBjYXBhYmlsaXRpZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbW9kZXMsIGNhcGFiaWxpdGllcyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3J0SW5mbyA9IGF3YWl0IHRoaXMuZ2V0UG9ydEluZm9ybWF0aW9uUmVxdWVzdChwb3J0SWQpXG4gICAgICAgICAgICBjb25zdCB7IGNvdW50LCBvdXRwdXQsIGlucHV0IH0gPSBwb3J0SW5mb1xuICAgICAgICAgICAgY2FwYWJpbGl0aWVzID0gcG9ydEluZm8uY2FwYWJpbGl0aWVzXG4gICAgICAgICAgICBtb2RlcyA9IFtdXG4gICAgICAgICAgICBmb3IgKGxldCBtb2RlID0gMDsgbW9kZSA8IGNvdW50OyBtb2RlKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge31cbiAgICAgICAgICAgICAgICBsZXQgcmV0XG4gICAgICAgICAgICAgICAgZGF0YS5tb2RlID0gMFxuICAgICAgICAgICAgICAgIHJldCA9IGF3YWl0IHRoaXMuZ2V0UG9ydE1vZGVJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkLCBtb2RlLCBNb2RlSW5mb3JtYXRpb25UeXBlLk5BTUUpXG4gICAgICAgICAgICAgICAgZGF0YS5uYW1lID0gcmV0Lm5hbWVcbiAgICAgICAgICAgICAgICByZXQgPSBhd2FpdCB0aGlzLmdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgTW9kZUluZm9ybWF0aW9uVHlwZS5SQVcpXG4gICAgICAgICAgICAgICAgZGF0YVtyZXQudHlwZV0gPSB7IG1pbjogcmV0Lm1pbiwgbWF4OiByZXQubWF4IH1cbiAgICAgICAgICAgICAgICByZXQgPSBhd2FpdCB0aGlzLmdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgTW9kZUluZm9ybWF0aW9uVHlwZS5TSSlcbiAgICAgICAgICAgICAgICBkYXRhW3JldC50eXBlXSA9IHsgbWluOiByZXQubWluLCBtYXg6IHJldC5tYXggfVxuICAgICAgICAgICAgICAgIHJldCA9IGF3YWl0IHRoaXMuZ2V0UG9ydE1vZGVJbmZvcm1hdGlvblJlcXVlc3QocG9ydElkLCBtb2RlLCBNb2RlSW5mb3JtYXRpb25UeXBlLlNZTUJPTClcbiAgICAgICAgICAgICAgICBkYXRhLnVuaXQgPSByZXQuc3ltYm9sXG4gICAgICAgICAgICAgICAgcmV0ID0gYXdhaXQgdGhpcy5nZXRQb3J0TW9kZUluZm9ybWF0aW9uUmVxdWVzdChwb3J0SWQsIG1vZGUsIE1vZGVJbmZvcm1hdGlvblR5cGUuVkFMVUVfRk9STUFUKVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbnVtVmFsdWVzLCBkYXRhVHlwZSwgdG90YWxGaWd1cmVzLCBkZWNpbWFscyB9ID0gcmV0XG4gICAgICAgICAgICAgICAgZGF0YVtyZXQudHlwZV0gPSB7IG51bVZhbHVlcywgZGF0YVR5cGUsIHRvdGFsRmlndXJlcywgZGVjaW1hbHMgfVxuICAgICAgICAgICAgICAgIGlmICgoaW5wdXQgPj4gbW9kZSkgJiAweDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tb2RlIHw9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChvdXRwdXQgPj4gbW9kZSkgJiAweDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tb2RlIHw9IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kZXMucHVzaChkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5odWJEZXZpY2VzW3BvcnRJZF0ubW9kZXMgPSBtb2Rlc1xuICAgICAgICAgICAgdGhpcy5odWJEZXZpY2VzW3BvcnRJZF0uY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzXG5cbiAgICAgICAgICAgIHJldHVybiB7IG1vZGVzLCBjYXBhYmlsaXRpZXMgfVxuICAgICAgICB9XG5cblxuICAgICAgICBnZXRQb3J0SW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLlBPUlRfSU5GT1JNQVRJT05fUkVRVUVTVCwgcG9ydElkLCAweDAxKVxuICAgICAgICAgICAgICAgIHRoaXMucG9ydENtZENhbGxiYWNrW3BvcnRJZF0gPSByZXNvbHZlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIGdldFBvcnRNb2RlSW5mb3JtYXRpb25SZXF1ZXN0KHBvcnRJZCwgbW9kZSwgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kTXNnKE1lc3NhZ2VUeXBlLlBPUlRfTU9ERV9JTkZPUk1BVElPTl9SRVFVRVNULCBwb3J0SWQsIG1vZGUsIHR5cGUpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0Q21kQ2FsbGJhY2tbcG9ydElkXSA9IHJlc29sdmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZU1zZyhtc2cpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckxlbiA9IG1zZy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICBjb25zdCBtc2dMZW4gPSBtc2cuZ2V0VWludDgoMClcbiAgICAgICAgICAgIGNvbnN0IG1zZ1R5cGUgPSBtc2cuZ2V0VWludDgoMilcbiAgICAgICAgICAgIGxvZygnZGVjb2RlTXNnJywgeyBtc2dUeXBlOiBNZXNzYWdlVHlwZU5hbWVzW21zZ1R5cGVdIH0pXG4gICAgICAgICAgICBzd2l0Y2ggKG1zZ1R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkhVQl9BVFRBQ0hFRF9JTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb3J0TXNnKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5HRU5FUklDX0VSUk9SX01FU1NBR0VTOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUdlbmVyaWNFcnJvck1zZyhtc2cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSHViUHJvcGVydHlSZXNwb25zZShtc2cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5IVUJfQUxFUlRTOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUh1YkFsZXJ0cyhtc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUE9SVF9PVVRQVVRfQ09NTUFORF9GRUVEQkFDSzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb3J0Q29tbWFuZEZlZWRiYWNrKG1zZylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QT1JUX01PREVfSU5GT1JNQVRJT046XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9ydE1vZGVJbmZvcm1hdGlvbihtc2cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUE9SVF9JTkZPUk1BVElPTjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb3J0SW5mb3JtYXRpb24obXNnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBPUlRfVkFMVUVfU0lOR0xFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBvcnRWYWx1ZVNpbmdsZShtc2cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICAqIFxuICAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvcnRWYWx1ZVNpbmdsZShtc2cpIHtcbiAgICAgICAgICAgIC8vbG9nKCdtc2cnLCBtc2cpXG4gICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGNvbnN0IG1zZ0xlbiA9IG1zZy5nZXRVaW50OCgwKVxuICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgICAgIGxvZygnaGFuZGxlUG9ydFZhbHVlU2luZ2xlJywgeyBtc2dMZW4sIHBvcnRJZCB9KVxuICAgICAgICAgICAgZGV2aWNlLmhhbmRsZVZhbHVlKG1zZylcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVQb3J0TW9kZUluZm9ybWF0aW9uKG1zZykge1xuICAgICAgICAgICAgY29uc3QgcG9ydElkID0gbXNnLmdldFVpbnQ4KDMpXG4gICAgICAgICAgICBjb25zdCBtb2RlID0gbXNnLmdldFVpbnQ4KDQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbXNnLmdldFVpbnQ4KDUpXG4gICAgICAgICAgICBjb25zdCBkYXRhID0geyBwb3J0SWQsIG1vZGUsIHR5cGU6IE1vZGVJbmZvcm1hdGlvblR5cGVOYW1lc1t0eXBlXSB9XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVJbmZvcm1hdGlvblR5cGUuTkFNRTpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5uYW1lID0gYWJUb1N0cmluZyhtc2cuYnVmZmVyLnNsaWNlKDYsIG1zZy5ieXRlTGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGVJbmZvcm1hdGlvblR5cGUuUkFXOlxuICAgICAgICAgICAgICAgIGNhc2UgTW9kZUluZm9ybWF0aW9uVHlwZS5QQ1Q6XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlSW5mb3JtYXRpb25UeXBlLlNJOlxuICAgICAgICAgICAgICAgICAgICBkYXRhLm1pbiA9IG1zZy5nZXRGbG9hdDMyKDYsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWF4ID0gbXNnLmdldEZsb2F0MzIoMTAsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlSW5mb3JtYXRpb25UeXBlLlNZTUJPTDpcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zeW1ib2wgPSBhYlRvU3RyaW5nKG1zZy5idWZmZXIuc2xpY2UoNiwgbXNnLmJ5dGVMZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZUluZm9ybWF0aW9uVHlwZS5WQUxVRV9GT1JNQVQ6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubnVtVmFsdWVzID0gbXNnLmdldFVpbnQ4KDYpXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YVR5cGUgPSBbXCI4Yml0XCIsIFwiMTZiaXRcIiwgXCIzMmJpdFwiLCBcImZsb2F0XCJdW21zZy5nZXRVaW50OCg3KV1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS50b3RhbEZpZ3VyZXMgPSBtc2cuZ2V0VWludDgoOClcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kZWNpbWFscyA9IG1zZy5nZXRVaW50OCg5KVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKCdwb3J0TW9kZUluZm9ybWF0aW9uJywgZGF0YSlcbiAgICAgICAgICAgIGNvbnN0IGNiID0gdGhpcy5wb3J0Q21kQ2FsbGJhY2tbcG9ydElkXVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2IoZGF0YSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wb3J0Q21kQ2FsbGJhY2tbcG9ydElkXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9ydEluZm9ybWF0aW9uKG1zZykge1xuICAgICAgICAgICAgY29uc3QgcG9ydElkID0gbXNnLmdldFVpbnQ4KDMpXG4gICAgICAgICAgICBsZXQgY2FwYWJpbGl0aWVzID0gbXNnLmdldFVpbnQ4KDUpXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IG1zZy5nZXRVaW50OCg2KVxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBtc2cuZ2V0VWludDE2KDcsIHRydWUpXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBtc2cuZ2V0VWludDE2KDksIHRydWUpXG4gICAgICAgICAgICBsb2coYFBvcnQgJHtwb3J0SWR9LCBjYXBhYmlsaXRpZXMgJHtjYXBhYmlsaXRpZXN9LCB0b3RhbCBtb2RlcyAke2NvdW50fSwgXG4gICAgICAgICAgICAgICAgICAgIGlucHV0IG1vZGVzICR7aW5wdXR9LCBvdXRwdXQgbW9kZXMgJHtvdXRwdXR9YClcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUNhcHMgPSAnb3V0cHV0LGlucHV0LGxvZ2ljYWwgY29tYmluYWJsZSwgbG9naWNhbCBzeW5jaHJvbmlzYWJsZScuc3BsaXQoJywnKVxuICAgICAgICAgICAgbGV0IGNhcCA9IFtdXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoY2FwYWJpbGl0aWVzID4+IGkpICYgMSkge1xuICAgICAgICAgICAgICAgICAgICBjYXAucHVzaChhdmFpbGFibGVDYXBzW2ldKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IHBvcnRJZCwgY2FwYWJpbGl0aWVzOiBjYXAuam9pbignLCAnKSwgY291bnQsIGlucHV0LCBvdXRwdXQgfVxuICAgICAgICAgICAgY29uc3QgY2IgPSB0aGlzLnBvcnRDbWRDYWxsYmFja1twb3J0SWRdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYihkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICogQHJldHVybnMgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVIdWJQcm9wZXJ0eVJlc3BvbnNlKG1zZykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBtc2cuZ2V0VWludDgoMylcbiAgICAgICAgICAgIGxvZyh7IHByb3BlcnR5OiBIdWJQcm9wZXJ0eVBheWxvYWROYW1lc1twcm9wZXJ0eV0gfSlcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PSBIdWJQcm9wZXJ0eVBheWxvYWQuQkFUVEVSWV9WT0xUQUdFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0dGVyeUxldmVsID0gbXNnLmdldFVpbnQ4KDUpXG4gICAgICAgICAgICAgICAgbG9nKHsgYmF0dGVyeUxldmVsIH0pXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdiYXR0ZXJ5TGV2ZWwnLCB7IGJhdHRlcnlMZXZlbCB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT0gSHViUHJvcGVydHlQYXlsb2FkLkJVVFRPTl9TVEFURSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvblN0YXRlID0gbXNnLmdldFVpbnQ4KDUpXG4gICAgICAgICAgICAgICAgbG9nKHsgYnV0dG9uU3RhdGUgfSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2J1dHRvblN0YXRlJywgeyBidXR0b25TdGF0ZSB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT0gSHViUHJvcGVydHlQYXlsb2FkLlNZU1RFTV9UWVBFX0lEKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzdGVtVHlwZSA9IG1zZy5nZXRVaW50OCg1KVxuICAgICAgICAgICAgICAgIGxvZyh7IHN5c3RlbVR5cGUgfSlcbiAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdCgnYnV0dG9uU3RhdGUnLCB7IGJ1dHRvblN0YXRlIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PSBIdWJQcm9wZXJ0eVBheWxvYWQuUFJJTUFSWV9NQUNfQUREUkVTUykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKG1zZy5nZXRVaW50OCg1ICsgaSkudG9TdHJpbmcoMTYpLnRvTG9jYWxlVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nKHsgYnl0ZXMgfSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FkZHJlc3MnLCB7IGFkZHJlc3M6IGJ5dGVzLmpvaW4oJzonKSB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlR2VuZXJpY0Vycm9yTXNnKG1zZykge1xuICAgICAgICAgICAgY29uc3QgY21kVHlwZSA9IG1zZy5nZXRVaW50OCgzKVxuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gbXNnLmdldFVpbnQ4KDQpXG4gICAgICAgICAgICBsb2coeyBjbWRUeXBlLCBlcnJvckNvZGU6IEVycm9yQ29kZU5hbWVzW2Vycm9yQ29kZV0gfSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IGNtZFR5cGUsIGVycm9yQ29kZTogRXJyb3JDb2RlTmFtZXNbZXJyb3JDb2RlXSB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBtc2cgXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVIdWJBbGVydHMobXNnKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJMZW4gPSBtc2cuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgY29uc3QgbXNnTGVuID0gbXNnLmdldFVpbnQ4KDApXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbXNnLmdldFVpbnQ4KDMpXG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBtc2cuZ2V0VWludDgoNClcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtc2cuZ2V0VWludDgoNSlcblxuICAgICAgICAgICAgbG9nKCdoYW5kbGVIdWJBbGVydHMnLCB7IGJ1ZmZlckxlbiwgbXNnTGVuLCB0eXBlLCBvcGVyYXRpb24sIHBheWxvYWQgfSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnaHViQWxlcnRzJywgeyB0eXBlLCBwYXlsb2FkIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVZpZXd9IG1zZyBcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvcnRDb21tYW5kRmVlZGJhY2sobXNnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAzOyBvZmZzZXQgPCBtc2cuYnl0ZUxlbmd0aDsgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBtc2cuZ2V0VWludDgob2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNvbnN0IGZlZWRiYWNrID0gbXNnLmdldFVpbnQ4KG9mZnNldCArIDEpXG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5odWJEZXZpY2VzW3BvcnRJZF1cbiAgICAgICAgICAgICAgICBsb2coJ2hhbmRsZVBvcnRDb21tYW5kRmVlZGJhY2snLCB7IHBvcnRJZCwgZmVlZGJhY2sgfSlcbiAgICAgICAgICAgICAgICBpZiAoZmVlZGJhY2sgPT0gMTAgJiYgZGV2aWNlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXZpY2UuaGFuZGxlRmVlZGJhY2soKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtEYXRhVmlld30gbXNnIFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUG9ydE1zZyhtc2cpIHtcblxuICAgICAgICAgICAgY29uc3QgcG9ydElkID0gbXNnLmdldFVpbnQ4KDMpXG4gICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBtc2cuZ2V0VWludDgoNClcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBldmVudFR5cGUgPyBtc2cuZ2V0VWludDE2KDUsIHRydWUpIDogMFxuICAgICAgICAgICAgY29uc3QgZGV2aWNlVHlwZU5hbWUgPSBEZXZpY2VUeXBlTmFtZXNbdHlwZV0gfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IEV2ZW50TmFtZXNbZXZlbnRUeXBlXVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaGFuZGxlUG9ydE1zZycsIHsgcG9ydElkLCBldmVudE5hbWUsIGRldmljZVR5cGVOYW1lIH0pXG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09IEV2ZW50LkFUVEFDSEVEX0lPKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvck1hcFt0eXBlXVxuICAgICAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSBEZXZpY2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gbmV3IGNvbnN0cnVjdG9yKHRoaXMsIHBvcnRJZCwgZGV2aWNlVHlwZU5hbWUpXG4gICAgICAgICAgICAgICAgdGhpcy5odWJEZXZpY2VzW3BvcnRJZF0gPSBkZXZpY2VcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaENhbGxiYWNrcy5lbWl0KGRldmljZSlcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYXR0YWNoJywgZGV2aWNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09IEV2ZW50LkRFVEFDSEVEX0lPKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaHViRGV2aWNlc1twb3J0SWRdXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZXRhY2gnLCB7IHBvcnRJZCB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09IEV2ZW50LkFUVEFDSEVEX1ZJUlRVQUxfSU8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0SWQxID0gbXNnLmdldFVpbnQ4KDcpXG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydElkMiA9IG1zZy5nZXRVaW50OCg4KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gbmV3IERvdWJsZU1vdG9yKHRoaXMsIHBvcnRJZCwgZ2V0VmlydHVhbFBvcnROYW1lKHBvcnRJZDEsIHBvcnRJZDIpKVxuICAgICAgICAgICAgICAgIHRoaXMuaHViRGV2aWNlc1twb3J0SWRdID0gZGV2aWNlXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDYWxsYmFja3MuZW1pdChkZXZpY2UpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2F0dGFjaCcsIGRldmljZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICQkLnNlcnZpY2UucmVnaXN0ZXJTZXJ2aWNlKCdodWInLCB7XG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIHtEZXZpY2V9IGRldmljZSBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBpc01vdG9yKGRldmljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2UgaW5zdGFuY2VvZiBNb3RvclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIHtEZXZpY2V9IGRldmljZSBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0RvdWJsZU1vdG9yKGRldmljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2UgaW5zdGFuY2VvZiBEb3VibGVNb3RvclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIHtEZXZpY2V9IGRldmljZSBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0xlZChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlIGluc3RhbmNlb2YgTGVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlIFxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzVGFjaG9Nb3RvcihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlIGluc3RhbmNlb2YgVGFjaG9Nb3RvclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8SHViRGV2aWNlPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgICAgICAgICBsb2coJ2Nvbm5lY3QnKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gYXdhaXQgbmF2aWdhdG9yLmJsdWV0b290aC5yZXF1ZXN0RGV2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0QWxsRGV2aWNlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxTZXJ2aWNlczogW0xQRjJfU0VSVklDRV9VVUlEXVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBjb25zdCBodWJEZXZpY2UgPSBuZXcgSHViRGV2aWNlKClcbiAgICAgICAgICAgICAgICBhd2FpdCBodWJEZXZpY2UuaW5pdChkZXZpY2UpXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaHViRGV2aWNlXG5cbiAgICAgICAgICAgICAgICAvL2F3YWl0IHNlbmRNc2coTWVzc2FnZVR5cGUuSFVCX1BST1BFUlRJRVMsIEh1YlByb3BlcnR5UGF5bG9hZC5CQVRURVJZX1RZUEUsIDB4MDUpXG4gICAgICAgICAgICAgICAgLy9hd2FpdCBzZW5kTXNnKGZvcm1hdE1zZyhNZXNzYWdlVHlwZS5IVUJfUFJPUEVSVElFUywgSHViUHJvcGVydHlQYXlsb2FkLkJBVFRFUllfVk9MVEFHRSwgMHgwMikpXG4gICAgICAgICAgICAgICAgLy9hd2FpdCBzZW5kTXNnKE1lc3NhZ2VUeXBlLkhVQl9QUk9QRVJUSUVTLCBIdWJQcm9wZXJ0eVBheWxvYWQuQlVUVE9OX1NUQVRFLCAweDAyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QsXG4gICAgICAgICAgICAgICAgQ29sb3IsXG4gICAgICAgICAgICAgICAgUG9ydE1hcCxcbiAgICAgICAgICAgICAgICBQb3J0TWFwTmFtZXMsXG4gICAgICAgICAgICAgICAgRGV2aWNlTW9kZSxcbiAgICAgICAgICAgICAgICBCcmFraW5nU3R5bGUsXG4gICAgICAgICAgICAgICAgRGV2aWNlVHlwZU5hbWVzLFxuICAgICAgICAgICAgICAgIGlzTW90b3IsXG4gICAgICAgICAgICAgICAgaXNUYWNob01vdG9yLFxuICAgICAgICAgICAgICAgIGlzTGVkLFxuICAgICAgICAgICAgICAgIGlzRG91YmxlTW90b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KSgpO1xuXG5cbiJdfQ=="}