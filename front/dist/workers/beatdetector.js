function getPeaksAtThreshold(e,t,o){console.log("getPeaksAtThreshold",t);const n=[],s=e.length;for(let a=0;a<s;)e[a]>t&&(n.push(a),a+=o/4-1),a++;return n}function countIntervalsBetweenNearbyPeaks(e){const t=[];return e.forEach((o,n)=>{const s=Math.min(e.length-n,10);for(let a=1;a<s;a++){const s=e[n+a]-o;t.some(e=>e.interval===s&&(e.peaks.push(o),console.log("interval",e),!0))||t.push({interval:s,peaks:[o]})}}),t}function trunc(e){return Math.trunc(10*e)/10}function groupNeighborsByTempo(e,t){const o=[];return e.forEach((e,n)=>{let s=60/(e.interval/t);for(;s<90;)s*=2;for(;s>160;)s/=2;let a=e.peaks.length,r=!1;o.forEach(t=>{if(t.tempo===s&&(t.score+=e.peaks.length,t.peaks=t.peaks.concat(e.peaks),r=!0),t.tempo>s-.5&&t.tempo<s+.5){const e=(1-2*Math.abs(t.tempo-s))*t.peaks.length;a+=e,t.score+=e}}),r||o.push({tempo:s,score:a,peaks:e.peaks})}),console.log("tempoBuckets",o),o}function getMaximumValue(e){let t=0;const o=e.length;for(let n=0;n<o;n+=1)e[n]>t&&(t=e[n]);return t}self.onmessage=function(e){console.log("Message received:",e.data);const{channelData:t,sampleRate:o}=e.data,n=guess(t,o);console.log("tempoInfo",n),self.postMessage(n)};const MINUMUM_NUMBER_OF_PEAKS=30;function computeTempoBuckets(e,t){const o=getMaximumValue(e);console.log("maximumValue",o);const n=.3*o;let s=[],a=o-.05*o;if(console.log("threshold",a),o>.25)for(;s.length<MINUMUM_NUMBER_OF_PEAKS&&a>=n;)s=getPeaksAtThreshold(e,a,t),console.log("peaks length",s.length),a-=.05*o;const r=groupNeighborsByTempo(countIntervalsBetweenNearbyPeaks(s),t);return r.sort((e,t)=>t.score-e.score),r}function guess(e,t){const o=computeTempoBuckets(e,t);if(0===o.length)throw new Error("The given channelData does not contain any detectable beats.");const{peaks:n,tempo:s}=o[0],a=Math.round(s),r=60/a;n.sort((e,t)=>e-t);let c=n[0]/t;for(;c>r;)c-=r;return{bpm:a,offset:c,tempo:s}}